<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>pwn の学习之路</title>
      <link href="/2023/06/21/pwn-%E3%81%AE%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"/>
      <url>/2023/06/21/pwn-%E3%81%AE%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>pwn 是很接近底层的，经常会和汇编这些东西打交道，所以学习过程中不可避免会比较枯燥。pwn方向简单来说就是利用程序漏洞写脚本实施攻击取得权限并拿到flag（有时候sh不够需要提权），pwn手的乐趣也就这了。<del>（拜托~，pwn掉系统什么的真的超帅的！）</del></p><span id="more"></span><h1 id="也许需要nc一下？！"><a href="#也许需要nc一下？！" class="headerlink" title="也许需要nc一下？！"></a>也许需要nc一下？！</h1><p>要pwn肯定要先连接服务器嘛。一般给了地址和端口可以直接用pwntools的remote连接</p><p>比如给你了 <code>114.514.19.19:810</code></p><p>pwntools远程就是<code>io = remote(&#39;114.514.19.19&#39;, 810)</code>，</p><p>本地打就用 <code>io = process(&#39;file_path&#39;)</code></p><p>如果要在kali上就是 <code>$ nc 114.514.19.19 810</code></p><p>当然有时候可能是ssh，telnet之类的</p><p>可以自行上网搜索如何连接。</p><p>这里以ssh为例： 假设用户是ctf 那么就可以用<code>$ ssh ctf@114.514.19.19 -p 810</code>连接，然后再输入密码（没有给就自己爆吧，甚至可能不给端口2333）</p><p>不过有种偷懒的方法就是直接用xshell连接（download: <a href="https://www.xshell.com/zh/xshell/">XSHELL - NetSarang Website</a>)</p><p>具体用法请自行百度</p><h1 id="这是什么？缓冲区？！溢出一下！"><a href="#这是什么？缓冲区？！溢出一下！" class="headerlink" title="这是什么？缓冲区？！溢出一下！"></a>这是什么？缓冲区？！溢出一下！</h1><p>缓冲区溢出就是长数据复制到小的缓冲区里，多出的数据会发生泄露，导致其他数据被破坏。<strong>常见的栈溢出和堆溢出都包含在内，只是发生在栈上和堆上的区别而已。</strong></p><p>而其中，栈溢出是最常见的漏洞，一般来说难度也比较小（也可以很恶心），作为pwn的起点当之无愧吧。</p><h2 id="栈の基础"><a href="#栈の基础" class="headerlink" title="栈の基础"></a>栈の基础</h2><h3 id="什么是栈？（stack）"><a href="#什么是栈？（stack）" class="headerlink" title="什么是栈？（stack）"></a>什么是栈？（stack）</h3><p>栈是一种<strong>先进后出</strong>的数据结构，这也正好满足了调用函数的方式，即：父函数调用子函数，父在前，子在后；返回值时，子函数先返回，父函数后返回。</p><p>对栈有push（压数据入栈），pop（弹出数据，并储存到指定寄存器或内存中）两种操作。</p><p><img src="/2023/06/21/pwn-%E3%81%AE%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/push_pop.png" alt="push&amp;pop"></p><p><strong>需要注意:</strong> </p><p>1）栈的生长是<strong>从高地址往低地址</strong>，对应上面演示的向下生长</p><p>2）<strong>pop后被弹出的数据还在栈内，但是不能直接访问（还是可以访问的）</strong></p><h3 id="什么是栈帧？（stack-frame）"><a href="#什么是栈帧？（stack-frame）" class="headerlink" title="什么是栈帧？（stack frame）"></a>什么是栈帧？（stack frame）</h3><p>其本质就是一种栈，这种栈专门来<strong>保存函数调用过程中的各种信息（参数，返回地址，本地变量等）。</strong></p><p>栈帧有栈顶和栈底之分，<strong>栈顶地址最低，栈底地址最高，SP（栈指针）是一直指向栈顶的。</strong></p><p>下面是一个栈帧示意图：</p><p><img src="/2023/06/21/pwn-%E3%81%AE%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/%E6%A0%88%E5%B8%A7.png" alt="栈帧"></p><p>一般来说，<code>bp</code>（基址指针）到<code>sp</code>之间的区域当作栈帧。<strong>并不是整个栈空间只有一个栈帧，每调用一个函数，就会生成一个新的栈帧</strong>。</p><p>函数调用过程中，我们将调用函数的函数称为 “调用者（caller）“， 被调用的函数称为 “被调用者（callee）”。其中：</p><p>1）caller需要知道在哪里获取callee的返回值</p><p>2）callee需要知道传入的参数在哪里</p><p>3）返回地址在哪里</p><p>同时，<strong>我们要保证在callee返回后，<code>bp</code>, <code>sp</code>等寄存器的值应该和调用前一致</strong>。所以，我们要用栈来保存这些数据。</p><h2 id="bss，data，text，heap-amp-stack"><a href="#bss，data，text，heap-amp-stack" class="headerlink" title="bss，data，text，heap &amp; stack"></a>bss，data，text，heap &amp; stack</h2><h3 id="bss-segment："><a href="#bss-segment：" class="headerlink" title="bss segment："></a>bss segment：</h3><p>bss段通常用来存放程序中<strong>未初始化的全局变量</strong></p><p>bss是 Block Started by Symbol 的简称</p><p>bss段属于静态内存分配</p><h3 id="data-segment："><a href="#data-segment：" class="headerlink" title="data segment："></a>data segment：</h3><p>数据段通常存放<strong>已经初始化的全局变量</strong>，属于静态内存分配</p><h3 id="code-x2F-text-segment："><a href="#code-x2F-text-segment：" class="headerlink" title="code&#x2F;text segment："></a>code&#x2F;text segment：</h3><p>代码段通常用来存放程序执行代码，其大小在编译期确定，并且该内存区域通常为只读（某些架构允许可写，即允许修改程序）</p><h3 id="堆（heap）："><a href="#堆（heap）：" class="headerlink" title="堆（heap）："></a>堆（heap）：</h3><p>堆用于存放程序运行中被动态分配的内存段，大小不固定，可动态扩张或缩减。</p><p>当进程调用malloc等函数分配内存时，新分配的内存会被动态添加到堆上（堆被扩张）；</p><p>使用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）。</p><h3 id="栈（stack）"><a href="#栈（stack）" class="headerlink" title="栈（stack）"></a>栈（stack）</h3><p><strong>栈又称堆栈</strong>，是用户存放程序<strong>临时创建的局部变量</strong>，也就是 {} 中定义的变量（但<strong>不包括static声明的变量</strong>，static意味着在数据段（.data）中存放变量）。</p><p>此外，函数被调用时，其参数也会压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。</p><p>由于栈先进后出的特点，栈特别方便来保存&#x2F;恢复调用现场。</p><p>从这个意义上，<strong>我们可以把堆栈看成一个寄存，交换临时数据的内存区</strong>。</p><h2 id="pwntools基础"><a href="#pwntools基础" class="headerlink" title="pwntools基础"></a>pwntools基础</h2><h3 id="安装pwntools"><a href="#安装pwntools" class="headerlink" title="安装pwntools"></a>安装pwntools</h3><p>使用python自带的pip下载pwntools</p><p><code>$ pip install pwntools</code></p><p>如果在windows上的wsl上直接使用改语句可能会报错</p><p><img src="/2023/06/21/pwn-%E3%81%AE%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/pip-error.png" alt="pip_err"></p><p>不过好在给了你提示，只要在后面加上<code>--break-system-packages</code>即可</p><p>也就是：<code>$ pip install pwntools --break-system-packages</code></p><h3 id="pwntools使用"><a href="#pwntools使用" class="headerlink" title="pwntools使用"></a>pwntools使用</h3><h4 id="基本框架"><a href="#基本框架" class="headerlink" title="基本框架"></a>基本框架</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *<span class="comment"># 导入pwntools模块</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">context.arch = <span class="string">&#x27;i386&#x27;</span><span class="comment"># x64架构应为 &#x27;amd64&#x27;</span></span><br><span class="line">context.os = <span class="string">&#x27;linux&#x27;</span><span class="comment"># 设置为目标机的系统，一般是linux</span></span><br><span class="line">context.log_level = <span class="string">&#x27;deubg&#x27;</span><span class="comment"># 输出调试信息</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">或者直接使用:</span></span><br><span class="line"><span class="string">context(arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;, log_level=&#x27;debug&#x27;)</span></span><br><span class="line"><span class="string">当然一般情况下arch和os不用设置（要生成shellcode时候要设置），只要设置log_level为debug就可以了</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">io = remote(<span class="string">&#x27;114.514.19.198&#x27;</span>, <span class="number">23333</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">用来建立一个远程连接，url或者ip作为地址，然后指明端口</span></span><br><span class="line"><span class="string">也可以仅使用本地文件，方便调试:</span></span><br><span class="line"><span class="string">io = process(&#x27;./test_pwn_file&#x27;)</span></span><br><span class="line"><span class="string">process用来启动一个本地进程，需要注意.elf不能在windows下运行，应在wsl或者虚拟机里，否则程序会报错，.exe等亦然，所以本地打的话记得脚本在匹配的环境里执行</span></span><br><span class="line"><span class="string">process里是文件路径，其中 &#x27;test_pwn_file&#x27; 是文件名</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">asm(shellcraft.sh())</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">asm()接收一个字符串，返回汇编码的机器码(bytes)</span></span><br><span class="line"><span class="string">比如:</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>asm(&#x27;mov eax, 0x10&#x27;)</span></span><br><span class="line"><span class="string">b&#x27;\xb8\x10\x00\x00\x00&#x27;</span></span><br><span class="line"><span class="string">shellcraft模块是shellcode的模块，包含一些生成shellcode的函数</span></span><br><span class="line"><span class="string">这里shellcraft.sh()就是执行/bin/sh的shellcode</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>asm(shellcraft.sh())</span></span><br><span class="line"><span class="string">b&#x27;jhh///sh/bin\x89\xe3h\x01\x01\x01\x01\x814$ri\x01\x011\xc9Qj\x04Y\x01\xe1Q\x89\xe11\xd2j\x0bX\xcd\x80&#x27;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">io.interactive()</span><br><span class="line"><span class="comment"># 将控制权还给用户，即用户可在终端直接与进程交互</span></span><br><span class="line"><span class="comment"># 在getshell之后使用，一般就放在脚本最后就行了</span></span><br></pre></td></tr></table></figure><h4 id="send-or-receive"><a href="#send-or-receive" class="headerlink" title="send or receive"></a>send or receive</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">io.send(payload)<span class="comment"># 将payload发送到远程连接</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;payload叫攻击载荷，实际上就是你要发送的数据，叫这个名字只是惯例了，你也可以叫其他任何合法的变量名&#x27;&#x27;&#x27;</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line"><span class="comment"># 与send相比是在发送完payload后会多发送一个回车(&#x27;\n&#x27;)</span></span><br><span class="line">io.sendafter(message, payload)</span><br><span class="line">io.sendlineafter(message, payload)</span><br><span class="line"><span class="comment"># 这两个很好理解，就是在接收到message之后再发送payload</span></span><br><span class="line"><span class="comment"># message不需要是接受到的一整个消息，可以是其中的片段</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">io.recv()</span><br><span class="line"><span class="comment"># 接收所有数据，返回接收到的数据</span></span><br><span class="line"><span class="comment"># 可以接收一个int参数，表示接收多少个字节</span></span><br><span class="line"><span class="comment"># recv(6) 就表示接收6个字节</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">比如你收到了一段消息: b&#x27;hello,world!&#x27;</span></span><br><span class="line"><span class="string">recv(6) 就会返回 b&#x27;hello,&#x27;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">io.recvuntil(message)</span><br><span class="line"><span class="comment"># 接收到message后停止接收，返回包含message在内的全部数据</span></span><br><span class="line"><span class="comment"># 可以指定一个drop: bool参数，默认为False，若为True则只返回message之前的数据(message被抛弃了)</span></span><br><span class="line"><span class="comment"># 当然如果你继续接收数据的话是不会重新接收一遍message了，只会从message之后继续接收</span></span><br><span class="line">io.recvline()</span><br><span class="line"><span class="comment"># 接收一行数据并返回，等价于 recvuntil(b&#x27;\n&#x27;)</span></span><br></pre></td></tr></table></figure><p><strong>上述发送和接收的方法均能接受<code>str</code>或<code>bytes</code>类型的参数</strong></p><h4 id="数据打包"><a href="#数据打包" class="headerlink" title="数据打包"></a>数据打包</h4><p>pwntools里封装了pack和unpack函数</p><p>一般用对应的简称：</p><p>打包 <code>p16/p32/p64</code>: 把一个整数分别打包为16，32或64位</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p64(<span class="number">0x7ffff3283296</span>)</span><br><span class="line"><span class="string">b&#x27;\x962(\xf3\xff\x7f\x00\x00&#x27;</span></span><br><span class="line"><span class="comment"># 即 b&#x27;\x96\x32\x28\xf3\xff\x7f\x00\x00&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p16(<span class="number">0x256</span>)</span><br><span class="line"><span class="string">b&#x27;V\x20&#x27;</span></span><br><span class="line"><span class="comment"># 即 b&#x27;\x56\x02&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p32(<span class="number">0x8004082</span>)</span><br><span class="line"><span class="string">b&#x27;\x82@\x00\x08</span></span><br><span class="line"><span class="string"># 即 b&#x27;</span>\x82\x40\x00\x08<span class="string">&#x27;</span></span><br></pre></td></tr></table></figure><p>解包 <code>u16/u32/u64</code>: 解包一个字符串（或bytes），得到整数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">`<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">要注意u16,u32,u64接受的参数分别要是2，4，8个字节，否则会报错</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>addr1 = <span class="string">b&#x27;\x962(\xf3\xff\x7f&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>u64(addr1)<span class="comment"># Error!!!</span></span><br><span class="line">...</span><br><span class="line">struct.error: unpack requires a buffer of <span class="number">8</span> <span class="built_in">bytes</span></span><br><span class="line"><span class="comment"># 一般接受数据不确定有多长就可以用ljust来补到8个字节</span></span><br><span class="line"><span class="comment"># 类似的有zfill，rjust等，可以自行体会其中差异</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hex</span>(u64(addr1).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="string">&#x27;0x7ffff3283296&#x27;</span></span><br></pre></td></tr></table></figure><p>需要注意：如果待延长的数据是 <code>bytes</code>，<code>ljust</code>第二个参数也必须<code>bytes</code><br>如上例就是必须是 <code>b&#39;\x00&#39;</code>或者<code>b&#39;\0&#39;</code>, 不能是 <code>&#39;\x00&#39;</code>, <code>&#39;\0&#39;</code><br>如果是 <code>str</code> 类型也是一样道理</p><p><del><strong>当然如果你用 python2 就当我没说</strong></del></p><h4 id="输出数据"><a href="#输出数据" class="headerlink" title="输出数据"></a>输出数据</h4><p>输出当然可以用 <code>print</code></p><p>只不过建议用pwntools自带的输出方式，一方面吻合pwntools本来的格式，一方面看着比较舒适</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>out_str = <span class="string">&#x27;hello, world&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>log.info(out_str)</span><br><span class="line">[*] hello, world</span><br><span class="line"><span class="comment"># info代表log等级，也可以用其他的</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = log.progress(<span class="string">&#x27;Working&#x27;</span>)</span><br><span class="line">[x] Working</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.status(<span class="string">&#x27;Reticulating splines&#x27;</span>)</span><br><span class="line">[x] Working: Reticulating splines</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.success(<span class="string">&#x27;Get a shell!&#x27;</span>)</span><br><span class="line">[+] Working: Get a shell!</span><br><span class="line"><span class="comment"># 要注意如果p使用了success之后，就不能再用p输出了，当然不至于报错</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.status(<span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line">no output</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.success(<span class="string">&#x27;you did&#x27;</span>)</span><br><span class="line">no output</span><br><span class="line"><span class="comment"># 不过直接用success是可以的</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>success(<span class="string">&#x27;you did&#x27;</span>)</span><br><span class="line">[+] you did</span><br></pre></td></tr></table></figure><h4 id="Cyclic-pattern"><a href="#Cyclic-pattern" class="headerlink" title="Cyclic pattern"></a>Cyclic pattern</h4><p>使用pwntools生成一个pattern（一个str），可以通过其中的一部分数据定位其在一个字符串的位置</p><p>做栈溢出题目时，pattern可以减少计算溢出点的时间</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cyclic(<span class="number">0x100</span>)<span class="comment"># 生成长度0x100的pattern</span></span><br><span class="line">cyclic_find(<span class="number">0x61616161</span>)<span class="comment"># 查找该数据在pattern的位置</span></span><br><span class="line">cyclic_find(<span class="string">&#x27;aaaa&#x27;</span>)<span class="comment"># 可以用字符串查找</span></span><br><span class="line"><span class="comment"># 或者 cyclic -l 0x61616161</span></span><br><span class="line"><span class="comment"># 注: 在pwndbg中使用</span></span><br></pre></td></tr></table></figure><p>比如溢出时构造 <code>cyclic(0x100)</code> ，或者更长，输入后 PC的值变味了 <code>0x61616161</code> 通过 <code>cyclic_find(0x61616161) </code> 就可以得到从哪一个字节开始会控制PC寄存器</p><h4 id="ELF文件操作"><a href="#ELF文件操作" class="headerlink" title="ELF文件操作"></a>ELF文件操作</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>elf = ELF(<span class="string">&#x27;./babyheap&#x27;</span>)</span><br><span class="line">[*] <span class="string">&#x27;/mnt/d/myCTFground/Pwn/Signin/ez_stack&#x27;</span></span><br><span class="line">    Arch:     amd64-<span class="number">64</span>-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (<span class="number">0x400000</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br></pre></td></tr></table></figure><p>使用ipython或者log_level &#x3D; ‘debug’ 的话就相当于是checksec了，</p><p>我们加载elf文件主要是为了获取一些符号信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hex</span>(elf.address)</span><br><span class="line"><span class="string">&#x27;0x400000&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hex</span>(elf.symbols[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line"><span class="string">&#x27;0x401040&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hex</span>(elf.got[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line"><span class="string">&#x27;0x404008&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hex</span>(elf.plt[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line"><span class="string">&#x27;0x401040&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>libc = ELF(<span class="string">&#x27;../libc-2.31.so&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hex</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>).__next__())</span><br><span class="line"><span class="string">&#x27;0x1b45bd&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="ELF文件保护机制"><a href="#ELF文件保护机制" class="headerlink" title="ELF文件保护机制"></a>ELF文件保护机制</h2>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
