<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">

<script>
  (function() {
    if ('') {
      var password = window.prompt('INPUT PASSWORD');
      if (password !== '') {
        alert('WRONG PASSWORD');
        history.back();
      }
    }
  })();
</script>
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"hacbit.tech","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":3,"unescape":false,"preload":false},"motion":{"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Include:  This book?  Before Start  Quick Start with a small Game  Improve your Rust code (TODO)  Others (TODO)">
<meta property="og:type" content="article">
<meta property="og:title" content="Rust-QuickStart">
<meta property="og:url" content="http://hacbit.tech/Rust-QuickStart/index.html">
<meta property="og:site_name" content="hacbit&#39;s blog">
<meta property="og:description" content="Include:  This book?  Before Start  Quick Start with a small Game  Improve your Rust code (TODO)  Others (TODO)">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://hacbit.tech/Rust-QuickStart/image-20231126143131252.png">
<meta property="og:image" content="http://hacbit.tech/Rust-QuickStart/image-20231126150439479.png">
<meta property="og:image" content="http://hacbit.tech/Rust-QuickStart/image-20231126151919640.png">
<meta property="og:image" content="http://hacbit.tech/Rust-QuickStart/image-20231128185424273.png">
<meta property="article:published_time" content="2023-11-26T05:47:08.000Z">
<meta property="article:modified_time" content="2025-02-08T10:51:56.051Z">
<meta property="article:author" content="hacbit">
<meta property="article:tag" content="Rust">
<meta property="article:tag" content="Tutorial">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://hacbit.tech/Rust-QuickStart/image-20231126143131252.png">

<link rel="canonical" href="http://hacbit.tech/Rust-QuickStart/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Rust-QuickStart | hacbit's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

  
<link rel="alternate" href="/rss2.xml" title="hacbit's blog" type="application/rss+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
      <a target="_blank" rel="noopener" href="https://github.com/hacbit" class="github-corner" aria-label="View source on GitHub"></a>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">hacbit's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-friends-links">

    <a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>friends links</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/hacbit" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://hacbit.tech/Rust-QuickStart/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="hacbit">
      <meta itemprop="description" content="The world open itself before those with noble heart.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hacbit's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Rust-QuickStart
        </h1>

        <div class="post-meta">
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-11-26 13:47:08" itemprop="dateCreated datePublished" datetime="2023-11-26T13:47:08+08:00">2023-11-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-02-08 18:51:56" itemprop="dateModified" datetime="2025-02-08T18:51:56+08:00">2025-02-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%BC%80%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">开发</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>13k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>24 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><em><strong>Include:</strong></em></p>
<ul>
<li><p><em><strong>This book?</strong></em></p>
</li>
<li><p><em><strong>Before Start</strong></em></p>
</li>
<li><p><em><strong>Quick Start with a small Game</strong></em></p>
</li>
<li><p><em><strong>Improve your Rust code (TODO)</strong></em></p>
</li>
<li><p><em><strong>Others (TODO)</strong></em></p>
</li>
</ul>
<span id="more"></span>

<h1 id="This-book"><a href="#This-book" class="headerlink" title="This book?"></a>This book?</h1><p>本文是为<strong>已经有一定编程基础</strong>（像C&#x2F;Cpp, Python, Ruby, C#等）的读者所编写的Rust快速入门教程，因此本文会假定读者已经对通用的基本的编程语言中的概念（如类型，结构体，流程控制等）具有一定的了解。如果在此之前你没有学习过任何有关编程语言的知识，我们强烈建议你应该先去学习一门其他语言。</p>
<p>如果你有基础且对部分语言比较熟练，可以通过<strong>《Rust语言圣经》</strong>进行更加系统的学习。这本书可以在Rust官网找到， 或者你可以阅读这本不错的中译版：<a target="_blank" rel="noopener" href="https://course.rs/%E3%80%82">https://course.rs/。</a> 另外对于这部分爷（先跪了 Orz），您们完全可以跳过第一阶段（Before Start &amp;&amp; Quick Start with a small Game），直接看后面的部分。</p>
<p>如果你想要快速上手写点什么东西，那么这本书将非常适合你！本书将会带你从一个小项目中逐步学习Rust，比较和其他语言的异同点。另外如果你学习过rust圣经，你可能会发现本书的知识点顺序和圣经差别很大，这是因为本书是以项目讲解为优先的，辅以知识点讲解，每个知识点我都会尽量放在一个比较合适的位置。</p>
<p>最后，祝各位能从中收获乐趣！</p>
<h1 id="Before-Start"><a href="#Before-Start" class="headerlink" title="Before Start"></a>Before Start</h1><h2 id="Install-Rust"><a href="#Install-Rust" class="headerlink" title="Install Rust"></a>Install Rust</h2><p>你可以通过Rust官网下载rustup-init，并在本机运行，根据提示安装。rustup会帮你安装好工具链和一些常用工具，比如cargo，rustc等，并且会添加到PATH，所以无须手动添加环境变量。</p>
<h2 id="Cargo-quick-start"><a href="#Cargo-quick-start" class="headerlink" title="Cargo quick-start"></a>Cargo quick-start</h2><p>cargo是rust自带的包管理器，拥有非常强大的功能，如果你熟练掌握cargo的使用你会很快爱上它~</p>
<p>本部分只介绍一些本人经常使用到的命令。</p>
<p><strong>help</strong>（应该一款正经的工具都该有help功能：D）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo help / cargo</span><br></pre></td></tr></table></figure>

<p><img src="/Rust-QuickStart/image-20231126143131252.png" alt="cargo_help"></p>
<blockquote>
<p>  如果你使用的cargo版本是2023-10-18之前的，可能没有颜色高亮</p>
</blockquote>
<p>你还可以用help命令来查看某个命令的详细信息，比如</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo help new</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  这里不放图了，因为实在太长了：(</p>
</blockquote>
<p><strong>new</strong></p>
<p>通过<code>cargo new</code>在当前文件夹下创建一个新的项目文件夹，里面的结构大概是</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> D:\Rust<span class="literal">-test</span>&gt; cargo new hello</span><br><span class="line">     Created binary (application) `hello` package</span><br><span class="line"><span class="built_in">PS</span> D:\Rust<span class="literal">-test</span>&gt; <span class="built_in">cd</span> hello</span><br><span class="line"><span class="built_in">PS</span> D:\Rust<span class="literal">-test</span>\hello&gt; tree</span><br><span class="line">.</span><br><span class="line">├── Cargo.toml</span><br><span class="line">└── src</span><br><span class="line">    └── main.rs</span><br></pre></td></tr></table></figure>

<p>Cargo.toml里面是一些配置信息，比如name，version，author，dependence之类的。src文件夹存放你的rs源代码。</p>
<p><strong>build</strong></p>
<p>你可以通过build命令来编译当前项目，默认是debug，你可以通过<code>cargo build --release</code>指定为release，它会进行更加激进的优化，当然与之对应的是编译时间也会增加。如果你想要交叉编译到其他平台，比如windows编译到linux，你可以通过<code>cargo build --target x86_64-unknown-linux-musl</code>来指定平台。build命令生成的文件会放在target文件夹下，不同平台，debug，release是分开放的，所以无须担心会覆盖。</p>
<p><strong>run</strong></p>
<p><code>cargo run</code>实际上相当于执行了2个命令：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cargo build</span><br><span class="line">./target/debug/编译得到的可执行文件</span><br></pre></td></tr></table></figure>

<p>所以build命令的参数在run是可以用的。</p>
<p>使用new命令创建的项目中main.rs里默认内容是</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>快去run一下你的第一个rust程序吧：D</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> D:\Rust<span class="literal">-test</span>\hello&gt; cargo run</span><br><span class="line">   Compiling hello v0.<span class="number">1.0</span> (D:\Rust<span class="literal">-test</span>\hello)</span><br><span class="line">    Finished dev <span class="function">[<span class="type">unoptimized</span> + <span class="type">debuginfo</span>] <span class="title">target</span></span>(s) <span class="keyword">in</span> <span class="number">2.80</span>s</span><br><span class="line">     Running `target\debug\hello.exe`</span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure>

<p><strong>check</strong></p>
<p><code>cargo check</code>应该是使用频率最高的命令之一，无他，谁不愿意在写代码的时候有一个帮手能帮你检查代码呢。check命令就是会对你的rust代码做亿点点检查，如果你写的问题，还会贴心的给予你提示。</p>
<p>比如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// path: src/main.rs</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>check一下看看</p>
<p><img src="/Rust-QuickStart/image-20231126150439479.png" alt="check_a"></p>
<p>警告了你a这个变量没有使用，并且给了你提示，可以在变量名前面加一个下划线，这样编译器就不会警告这个值，当然这个值还是可以使用的。check的功能远不止这些，得要靠自己探索了：D</p>
<p><strong>fmt</strong></p>
<p>rust又一大杀器，除了可以帮你控制代码缩进，还可以帮你的代码书写风格变得更加rusty！</p>
<p>比如：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// path: src/main.rs</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        std::io::<span class="title function_ invoke__">stdin</span>().<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> s).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">nums</span> = s.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">split_whitespace</span>().<span class="title function_ invoke__">map</span>(|x| x.parse::&lt;<span class="type">usize</span>&gt;().<span class="title function_ invoke__">unwrap</span>()).collect::&lt;<span class="type">Vec</span>&lt;<span class="type">usize</span>&gt;&gt;();</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, nums);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行<code>cargo fmt</code>后</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    std::io::<span class="title function_ invoke__">stdin</span>().<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> s).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">nums</span> = s</span><br><span class="line">        .<span class="title function_ invoke__">trim</span>()</span><br><span class="line">        .<span class="title function_ invoke__">split_whitespace</span>()</span><br><span class="line">        .<span class="title function_ invoke__">map</span>(|x| x.parse::&lt;<span class="type">usize</span>&gt;().<span class="title function_ invoke__">unwrap</span>())</span><br><span class="line">        .collect::&lt;<span class="type">Vec</span>&lt;<span class="type">usize</span>&gt;&gt;();</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, nums);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是不是看的舒服多了，所以再也不用担心重构时一堆缩进问题的（bushi</p>
<p><strong>clippy</strong></p>
<p>check + fmt + clippy大概就是写代码过程中最常用的3件套了，写rs嘎嘎爽~</p>
<p>clippy类似于check，会对你的代码做一些常见错误的检查，同时也像命令描述中说的，improve your Rust code！</p>
<p>对上面那段代码分别运行check和clippy对比看看</p>
<p><img src="/Rust-QuickStart/image-20231126151919640.png" alt="check_and_clippy"></p>
<p>发现check没有发现语法问题，所以没有任何信息抛出；而clippy则是在语法层面提供了一个简单的优化方案，比如这里提示在<code>.split_whitespace()</code>前不需要使用<code>.trim()</code>， 后面其实还有一个提示说可以用clippy帮你改，不用手动改。我们运行一下<code>cargo clippy --fix --bin &#39;hello&#39; --allow-dirty</code>， 再回去看我们的源代码，果然<code>.trim()</code>已经被去除了。</p>
<p><strong>others</strong></p>
<p>还有一些不是那么的常用但是也很有用的命令，这里简单列一下：</p>
<ul>
<li><code>cargo add</code>  可以把指定的依赖添加到当前项目，比如<code>cargo add regex</code>，就可以把regex库添加到当前项目，使用cargo add会修改你的Cargo.toml文件，默认添加的是最新版本，也可以指定它的版本和feature啥的。当然你也可以直接修改cargo.toml文件来达到一样的效果</li>
<li><code>cargo remove</code> 于cargo add对应，就是把指定的依赖从当前项目去除</li>
<li><code>cargo --version</code> 查看cargo的版本，包括是stable还是nightly</li>
<li><code>cargo install</code> 看起来和add很像，不过install命令是安装二进制文件的，比如运行<code>cargo install tauri-cli</code>，然后你就可以使用<code>cargo tauri</code> 命令来构建你的tauri项目：D</li>
<li><code>cargo clean</code> 这是和build一对的，clean用来删除<code>./target</code>文件夹</li>
<li><code>cargo search</code> 可以在crates.io查找指定的crate，<del>记得科学上网</del>，要不然可能有亿点点慢：(</li>
<li><strong>……</strong></li>
</ul>
<h1 id="Quick-Start-with-a-small-Game"><a href="#Quick-Start-with-a-small-Game" class="headerlink" title="Quick Start with a small Game"></a>Quick Start with a small Game</h1><h2 id="Create-your-Tic-tac-toe"><a href="#Create-your-Tic-tac-toe" class="headerlink" title="Create your Tic-tac-toe"></a>Create your Tic-tac-toe</h2><p>通过一个小项目来快速上手可能是一个好方法。</p>
<p>先找一个你觉得比较舒服的地方，然后通过cargo来创建一个新项目，并且进入项目文件夹</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cargo new tic<span class="literal">-tac-toe</span></span><br><span class="line"><span class="built_in">cd</span> tic<span class="literal">-tac-toe</span></span><br></pre></td></tr></table></figure>

<p>现在你位于当前项目的根目录，你需要确保你的终端的当前目录在项目文件夹内，以便cargo可以定位到你的 <code>cargo.toml</code> 文件，除此之外在根目录还是在其他目录（比如<code>src/</code> 或者 <code>target/</code> 等）没有影响</p>
<p>好！现在你可以使用一个编辑器来打开main.rs文件准备编写项目了！</p>
<h2 id="Start-with-putting-something"><a href="#Start-with-putting-something" class="headerlink" title="Start with putting something"></a>Start with putting something</h2><p>哪怕是终端，交互也是必不可少的，几乎任何语言的教程教你写的第一句代码都十分默契的选择了 Hello, World! <del>（当然在这里我们不是要输出这句话就是了）</del></p>
<p>打开你的rs源文件，它应该位于<code>src/main.rs</code>， 会发现里面已经有内容了，那么如果仔细观察会发现使用的输出<del>函数</del> <code>println!()</code> 带有一个！，按理说<code>!</code>属于非法命名，在rs当然也一样，只是因为这个<code>!</code>不是包含在名字内的罢了，另外，println！不是一个函数，而是<strong>宏</strong></p>
<blockquote>
<p>  在rust里，带有！的就是宏了，比如 print!, println!, write!等，我们这里暂时先不谈宏，只要知道是用来输出的就行了</p>
</blockquote>
<p>把main函数里面清空，并写上这句话</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;Welcome to Rust Tic Tac Toe!&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>记得运行一下确保能看到输出这句话：D</p>
<h2 id="Game-initialize"><a href="#Game-initialize" class="headerlink" title="Game initialize"></a>Game initialize</h2><p>细想一个井字棋需要些什么，嗯哼~，我想需要一个棋盘，两个玩家，当然还有配套的一系列判定系统。那我们就先看棋盘吧！</p>
<p>棋盘显然是一个3x3的，我们可以选择创建一个3x3的二维数组，或者长度为9的一维数组。这里为了更加符合直觉，我选择了前者。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">board</span>: [[<span class="type">char</span>; <span class="number">3</span>]; <span class="number">3</span>] = [[<span class="string">&#x27; &#x27;</span>; <span class="number">3</span>]; <span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<p>在rust中你可以使用let来把一个值绑定到一个变量，如果你写过JavaScript，应该会比较亲切：D， 一个标准的用法就是<code>let 变量名: 类型 = 表达式;</code>， 这里由于rust有强大的类型推导系统，所以你可以不用写名类型，编译器会自动推导出来！所以虽然是强类型语言，但是也不用像C&#x2F;Cpp在创建变量时必须注明类型。</p>
<p>我们再来看看这个类型，是一个嵌套的数组，在rust里面数组是<strong>固定长度</strong>的，也就是说你在声明时<strong>必须显示的标注长度</strong>， 这就导致，哪怕数组内部每个元素的类型相同，长度不同的话也是不同类型，<strong>比如 <code>[u32; 3]</code> 和 <code>[u32; 4]</code>就是两个不同的类型！</strong></p>
<p>右边的表达式就和类型长得差不多，只要把数组里面的类型替换成对于类型的某个具体值就行了，像这里就是使用了空格来初始化这个数组。</p>
<blockquote>
<p>  不是所有类型都可以作为数组的元素，除非实现Copy trait， copy特征简单来说就是能够快速拷贝，性能开销非常的小，一般储存在栈上的数据都默认实现了Copy特征；而像String这种在堆上的数据，无法实现Copy特征（但是实现了Clone特征，可以用.clone()来复制一份），所以不能作为数组的元素，像 [String; 3]，这种类型是不被允许的</p>
</blockquote>
<p>那么地图就这么弄好了，我们每下一步，就只要把数组对应位置的char换成我们下的字符。</p>
<p>比如我们假定玩家使用 ‘X’ 和 ‘O’， X先手。我们先来测试一下吧</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">board[<span class="number">0</span>][<span class="number">0</span>] = <span class="string">&#x27;X&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>ok， 非常完美！直接cargo run 运行一手</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   Compiling playground v0.<span class="number">0.1</span> (/playground)</span><br><span class="line">error[<span class="type">E0594</span>]: cannot assign to `board[<span class="type">_</span>][<span class="type">_</span>]`, as `board` is not declared as mutable</span><br><span class="line"> <span class="literal">--</span>&gt; src/main.rs:<span class="number">3</span>:<span class="number">5</span></span><br><span class="line">  |</span><br><span class="line"><span class="number">3</span> |     board[<span class="number">0</span>][<span class="number">0</span>] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">  |     ^^^^^^^^^^^^^^^^^ cannot assign</span><br><span class="line">  |</span><br><span class="line">help: consider changing this to be mutable</span><br><span class="line">  |</span><br><span class="line"><span class="number">2</span> |     let mut board: [[<span class="built_in">char</span>; <span class="number">3</span>]; <span class="number">3</span>] = [[<span class="string">&#x27; &#x27;</span>; <span class="number">3</span>]; <span class="number">3</span>];</span><br><span class="line">  |         +++</span><br><span class="line"></span><br><span class="line"><span class="keyword">For</span> more information about this error, <span class="keyword">try</span> `rustc <span class="literal">--explain</span> E0594`.</span><br><span class="line">error: could not compile `playground` (bin <span class="string">&quot;playground&quot;</span>) due to previous error</span><br></pre></td></tr></table></figure>

<p>Oh no! 报错了，编译器提醒我们board没有被声明为可变，所以不能再次分配值给<code>board[_][_]</code>， 当然还贴心的给你了提示，在board前面加一个mut关键字即可</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">board</span>: [[<span class="type">char</span>; <span class="number">3</span>]; <span class="number">3</span>] = [[<span class="string">&#x27; &#x27;</span>; <span class="number">3</span>]; <span class="number">3</span>];</span><br><span class="line">board[<span class="number">0</span>][<span class="number">0</span>] = <span class="string">&#x27;X&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>运行一下，编译通过！</p>
<blockquote>
<p>  在rust中用let来声明一个变量默认是不可变的，如果你想要能在后面改变它的值，你必须用 mut 关键字来显示的声明为一个可变变量，当然你也可以重新用let来绑定，比如你可以像这样：</p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = a + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>然后我们可以加一个current_player来记录当前的玩家，和一个input来储存你每次的输入，目前的main应该大概是这样的：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Welcome to Rust Tic Tac Toe!&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">board</span> = [[<span class="string">&#x27; &#x27;</span>; <span class="number">3</span>]; <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">current_player</span> = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">input</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们调用了String类的new方法来申请了一块内存来储存我们的字符串，当然现在还没有读入东西，还是空的。</p>
<p>ok，记得运行确保你的代码是正确的</p>
<h2 id="Game-Update"><a href="#Game-Update" class="headerlink" title="Game Update"></a>Game Update</h2><p>接下来就要构建我们游戏的主要逻辑了，我们肯定要放在一个循环里面，然后当有人获胜，或者棋盘被填满（平局）就退出游戏。那么我们的每次循环要做些什么呢？</p>
<p>首先我们肯定要输出我们的棋盘，不可能盲下吧:cry:， 我们不妨创建一个函数来在每次循环进行调用。</p>
<p>我们先创建一个循环，这里我比较倾向使用 loop，当然你也可以用while true（如果使用while true，编译器应该会给你一个warning，并建议你改成loop）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">loop</span> &#123;</span><br><span class="line">    <span class="comment">// todo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>loop支持常用的流程控制如break等，这跟大部分语言差不多，不做赘述。</p>
<h3 id="Definite-a-function-to-put-chessboard"><a href="#Definite-a-function-to-put-chessboard" class="headerlink" title="Definite a function to put chessboard"></a>Definite a function to put chessboard</h3><p>如果仔细观察过main函数，应该可以猜得出来声明一个函数要使用 <code>fn</code> 关键字，其具体的格式是 <code>fn 函数名&lt;特征和生命周期&gt;(参数名1: 参数类型1, ...) -&gt; 返回值类型 &#123;&#125;</code> ， 特征和生命周期先不用管后面再说，如果不注明特征约束或者生命周期，尖括号的部分是可以省略的，就像main一样函数名后面直接就是圆括号了。那我们就照猫画虎的先写一个函数看看吧！</p>
<blockquote>
<p>  注意函数的类型标注不能省略</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">print_board</span>(board: &amp;[[<span class="type">char</span>; <span class="number">3</span>]; <span class="number">3</span>]) &#123;</span><br><span class="line">    <span class="comment">// todo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于我们只需要输出，所以可以不用返回值，当然实际上是有返回值的，这个函数返回的是一个空元组，或者说是一个单元类型，它长这样 <code>()</code> ， 它可以忽略掉，当然如果你写上 <code>-&gt; () </code> 也不会错。</p>
<p>这个函数只有一个参数board，类型是一个 3x3的char数组的引用，一般来说，我们定义一个函数如果要传入一个复杂类型的参数，我们一般采用传入一个引用的形式，这会涉及到所有权的知识。</p>
<blockquote>
<p>  <strong>所有权和借用</strong>是Rust的一个非常重要的内容。对于内存管理，相信大家都很熟悉GC（比如Java，GO）和手动管理内存的分配和释放（比如C&#x2F;Cpp），而所有权是不同与前2种流派的第三种流派，它会在编译期就根据一系列规则进行检查，因此对于运行期不会有任何性能上的损失。</p>
<p>  这里因为篇幅关系不便详谈，简单来说所有权有以下几条规则：</p>
<p>  1）Rust中的每个值都被一个变量所拥有，该变量被称为值的所有者；</p>
<p>  2）一个值同时只能被一个变量所拥有；</p>
<p>  3）当所有者（变量）离开作用域范围时，这个值将被丢弃（drop）</p>
<p>  以String为例，它是被分配到堆上的数据，所以没有实现Copy特征，那么如果我执行了如下代码</p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Test_string&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = s1;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s2);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s1);</span><br></pre></td></tr></table></figure>

<p>  这段代码会报错，因为let s2 &#x3D; s1 的时候，s1的值的所有权被转移给了s2了，所以后面不能调用s1了</p>
<p>  这里可以把第二行改成 <code>let s2 = &amp;s1;</code> ，这样s2就是s1的值的一个引用（就相当于你借来用用，但是不具有它的所有权）就可以正常运行；或者改为 <code>let s2 = s1.clone();</code>， String实现了clone特征，所以可以调用clone方法来复制一份，注意这会在堆上再申请一块内存，所以使用clone会有一点的性能开销。但是如果我们把这段代码改成：</p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="number">0x114514</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = s1;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:x&#125;&quot;</span>, s2);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:x&#125;&quot;</span>, s1);</span><br></pre></td></tr></table></figure>

<p>  运行发现可以正常输出两行114514，这是因为整型是基本类型，默认实现了Copy特征，可以进行快速拷贝，let s2的时候就是把s1的值拷贝了一份然后在栈上的另一个地方开一块空间存放0x114514作为s2，和上一个例子相比较发现copy和clone都是把值复制了一遍在另外找一块空间来存放，区别就是一个在堆上，一个在栈上。</p>
</blockquote>
<p>好，话说回来，我们该写这个函数的具体逻辑了。其实只要简单的遍历以下board的每个值就可以吧，当然为了好看，我们可以加一个边框，像这样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">print_board</span>(board: &amp;[[<span class="type">char</span>; <span class="number">3</span>]; <span class="number">3</span>]) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;+---+---+---+&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">row</span> <span class="keyword">in</span> board &#123;</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">&quot;| &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">col</span> <span class="keyword">in</span> row &#123;</span><br><span class="line">            <span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; | &quot;</span>, col);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;\n+---+---+---+&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在main里面添加 <code>print_board(&amp;board);</code>， 运行一下，输出的应该是这样：（我在<a target="_blank" rel="noopener" href="https://play.rust-lang.org/%E8%BF%90%E8%A1%8C%E7%9A%84%EF%BC%89">https://play.rust-lang.org/运行的）</a></p>
<p><img src="/Rust-QuickStart/image-20231128185424273.png" alt="board"></p>
<p>这里我用了两个for来遍历数组，rust的for是类似与python这类语言的for，是遍历一个迭代器的值，而不是简单的遍历索引。</p>
<blockquote>
<p>  当然如果想要像c一样或者像python的for i in range(n)这种当然也可以，像这样就可以。</p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="variable">idx</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>  要注意0..10类似python的range是左取又不取的，如果你想要从0遍历到10，可以 0..11, 或者 0..&#x3D;10</p>
</blockquote>
<p><strong>注意for不支持给迭代的变量标注类型</strong>，也就是说比如 <code>for row: &amp;[char; 3] in board &#123;...&#125;</code> 这种是不被允许的！当然也无须担心，因为编译器会自动推导出类型！</p>
<h3 id="Receive-input-and-Process-it"><a href="#Receive-input-and-Process-it" class="headerlink" title="Receive input and Process it"></a>Receive input and Process it</h3><p>你可能期待rust的输入可以像c&#x2F;cpp的scanf&#x2F;fread，或者python的input()一样，可以直接调用一个函数来获取终端输入。但是很遗憾，rust并不直接存在这么一个函数，或者说，它被封装在Stdin类下，比如最常见的是<code>.read_line()</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">stdin</span> = std::io::<span class="title function_ invoke__">stdin</span>();</span><br><span class="line">stdin.<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> input).<span class="title function_ invoke__">unwrap</span>();</span><br></pre></td></tr></table></figure>

<p>这样就会从终端中读取一行（包括换行符）拼接在input结尾处，所以在循环中我们必须在每次开头都清空一下input中的内容。你需要在read_line的上一行插入：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">input.<span class="title function_ invoke__">clear</span>();</span><br></pre></td></tr></table></figure>

<p>需要注意：clear和read_line都是改变input的值，所以我们需要在声明input的时候添加mut关键字使其可变，而 <code>&amp;mut input</code> 是input的可变引用，它也是一种引用，不具有所有权，但是具有其使用权和更改权限，所以可以对input本身进行更改。</p>
<blockquote>
<p>  <strong>一个变量最多只能有一个可变引用，并且有可变引用时，不允许存在不可变引用，也不能通过所有者来访问值</strong></p>
<p>  来看这段代码</p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">a</span> = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">b</span> = &amp;<span class="keyword">mut</span> a;</span><br><span class="line">*b += <span class="number">1</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, a, b);</span><br></pre></td></tr></table></figure>

<p>  运行后果不其然报错了</p>
  <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">error[<span class="type">E0502</span>]: cannot borrow `a` as immutable because it is also borrowed as mutable</span><br><span class="line"> <span class="literal">--</span>&gt; src/main.rs:<span class="number">5</span>:<span class="number">23</span></span><br><span class="line">  |</span><br><span class="line"><span class="number">3</span> |     let b = &amp;mut a;</span><br><span class="line">  |             <span class="literal">------</span> mutable borrow occurs here</span><br><span class="line"><span class="number">4</span> |     *b += <span class="number">1</span>;</span><br><span class="line"><span class="number">5</span> |     println!(<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, a, b);</span><br><span class="line">  |                       ^  - mutable borrow later used here</span><br><span class="line">  |                       |</span><br><span class="line">  |                       immutable borrow occurs here</span><br><span class="line">  |</span><br><span class="line">  = note: this error originates <span class="keyword">in</span> the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (<span class="keyword">in</span> Nightly builds, run with <span class="literal">-Z</span> macro<span class="literal">-backtrace</span> <span class="keyword">for</span> more info)</span><br><span class="line"></span><br><span class="line"><span class="keyword">For</span> more information about this error, <span class="keyword">try</span> `rustc <span class="literal">--explain</span> E0502`.</span><br></pre></td></tr></table></figure>

<p>  可以这么来想，A有一个PS，B借过来玩（可变引用），B在玩的过程中（B的作用范围没有结束），A（所有者）和其他人（其他借用）显然不能借走吧，除非B还回去（B的作用结束），这样就回到A手上了，A又可以继续玩（A可以访问或修改值了）</p>
<p>  如果把上面那段改成这样就Ok了</p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">a</span> = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">b</span> = &amp;<span class="keyword">mut</span> a;		<span class="comment">// 可变借用 b 作用域开始</span></span><br><span class="line">*b += <span class="number">1</span>; <span class="comment">/* ps: *是解引用，因为b是&amp;i32, 没有实现+=，所以要解引用对值本身+= */</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, b);	<span class="comment">// b 作用域结束，因为后面都没有再使用b了</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, a);	<span class="comment">// b 作用结束后值的使用权自动还给a，所以a可以输出</span></span><br></pre></td></tr></table></figure>

<p>  建议自己写写尝试一下：D</p>
</blockquote>
<p>那么read_line后面的 <code>.unwrap()</code> 是干嘛的呢，你可能会有这种疑问。</p>
<p>其实功能就像字面意思那样，“拆开”，这里因为read_line，返回的是一个Result，而result需要手动处理，所以这里就用unwrap来取出里面的值</p>
<blockquote>
<p>  Result是一个枚举类型，定义是这样的</p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Result</span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(T),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  这里T，E都是泛型，一般T是一个你期望的值，E是一个错误。当unwrap遇到Ok时就会正常取出值，而如果是Err，就会<code>panic!</code> ，然后你就发现程序崩溃并且输出了一堆奇奇怪怪的东西。</p>
<p>  一般返回result就是让你自己来错误处理，常常会配合match之类的。在后面讲错误处理的时候再说：D</p>
</blockquote>
<p>哦，差点忘记了，我们需要些什么数据好像还没说。不如输入的格式就是 <code>row col</code>吧。所以我们在输入之前加上一条说明。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">print_board</span>(&amp;board);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;Please input your move: (fmt: row col)&quot;</span>);</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>然后我们得要把行列数据提取出来，我们可以使用split_whitespace，它会去掉空格、tab、回车之类的字符，并且会由此把其他可见字符字串隔开，返回的是一个迭代器。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">input</span> = input</span><br><span class="line">	.<span class="title function_ invoke__">split_whitespace</span>()</span><br><span class="line">	.<span class="title function_ invoke__">map</span>(|x| x.parse::&lt;<span class="type">usize</span>&gt;().<span class="title function_ invoke__">unwrap</span>())</span><br><span class="line">	.collect::&lt;<span class="type">Vec</span>&lt;<span class="type">usize</span>&gt;&gt;();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">row</span> = input[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">col</span> = input[<span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  map其实功能就是你们印象的那个map，在rust里，只要实现了迭代器特征的类型就可以调用map方法，map接收一个闭包作为参数，如果你用过一些函数式语言可能会比较熟悉 “闭包” 这个概念，其实它就是类似lambda的东西，其具体的形式是接近Ruby语言的闭包的。</p>
<p>  <code>||</code> 里面的是入参，闭包会自动把捕获的值绑定到里面的变量，你可以标注类型，但是同样也没必要这样做，因为编译器会自动推导！<code>||</code> 后面是一个表达式，这也意味着，你可以在 {} 中写多行代码，而不用像python的lambda一样只能想办法把表达式压缩到一行</p>
<p>  然后里面的入参 x 是一个&amp;str类型，这里通过parse()方法解析成usize类型（通过 <code>::&lt;&gt;</code> 的格式来指定），返回的也是Result（因为可能解析失败），然后unwrap解包。</p>
<p>  再通过collect方法把map返回的迭代器收集成一个Vec（是不定长的数组，所以创建时不用像数组一样标注长度）</p>
</blockquote>
<h3 id="Move"><a href="#Move" class="headerlink" title="Move"></a>Move</h3><p>接下来就要落子了，我们定义一个on_move，返回值是一个bool，来表示是否落子成功。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">on_move</span>(board: &amp;<span class="keyword">mut</span> [[<span class="type">char</span>; <span class="number">3</span>]; <span class="number">3</span>], row: <span class="type">usize</span>, col: <span class="type">usize</span>, symbol: <span class="type">char</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// symbol 是当前玩家对应的符号</span></span><br><span class="line">    <span class="comment">// 先检验范围，保证只能是0, 1, 2</span></span><br><span class="line">    <span class="comment">// 超出棋盘范围或者该处已经落子了，就代表这一步不成功</span></span><br><span class="line">    <span class="keyword">if</span> row &gt;= <span class="number">3</span> || col &gt;= <span class="number">3</span> || board[row][col] != <span class="string">&#x27; &#x27;</span> &#123;</span><br><span class="line">        <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        board[row][col] = symbol;</span><br><span class="line">        <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  这里得说明一下，每个作用域的最后一个表达式就会作为返回值，这里on_move函数只有一个表达式（最后一句不要有分号，有分号就是语句，语句没有返回值，或者准确来说语句返回一个单元<code>()</code> )，就是if {} else {}，然后if和else里面分别有false和true作为返回值。</p>
<p>  <strong>注意每个语句块只有最后一行才能不写分号，像是if， for，函数，或者仅仅只是{} 包裹的内容就是一个语句块。当然语句块也是一个语句</strong></p>
<p>  而return往往用于一个函数的中间，会直接跳出这个函数并返回值。</p>
<p>  这样的好处是不用写return（PS：本人比较倾向于不写return，一般不是迫不得已我不会写return）</p>
</blockquote>
<p>然后我们得处理一下on_move的结果</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> !<span class="title function_ invoke__">on_move</span>(&amp;<span class="keyword">mut</span> board, row, col, current_player) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Invalid move!&quot;</span>);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后每个人落子成功就轮到下一个玩家，我们写一个next_player来轮换玩家，你可能会想写个if，else if好了，不过这里我们用match来更优雅的实现</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> !<span class="title function_ invoke__">on_move</span>(...) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        current_player = <span class="title function_ invoke__">next_player</span>(current_player);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">next_player</span>(symbol: <span class="type">char</span>) <span class="punctuation">-&gt;</span> <span class="type">char</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> symbol &#123;</span><br><span class="line">        <span class="string">&#x27;X&#x27;</span> =&gt; <span class="string">&#x27;O&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;O&#x27;</span> =&gt; <span class="string">&#x27;X&#x27;</span>,</span><br><span class="line">        _ =&gt; <span class="built_in">unreachable!</span>(),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可能跟C的switch很像，不过match的强大还远远不止这些，match有个大杀器就是模式匹配（没错，又是从函数式语言借鉴的：D），会在后续内容细嗦。</p>
<blockquote>
<p>  顺带一提，在Rust里面，<strong>无论是函数还是全局变量，或者是结构体等的定义，只要有定义就行了，不需要太关注位置，也就是说，你不必像C&#x2F;Cpp一样得先在main前面声明某个函数，才能在main后面写函数的具体实现。</strong></p>
</blockquote>
<h3 id="Win-or-Draw"><a href="#Win-or-Draw" class="headerlink" title="Win or Draw"></a>Win or Draw</h3><p>现在距离一个功能完备的游戏只差胜负判断了，我们得写一个is_win函数来再每次落子后判断是否有人胜利（win），然后还得写一个函数is_full来判断棋盘时候已经下满了，也就意味着平局（draw），当然这个函数得放在is_win后面调用：D， 最后在loop里面调用即可</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> <span class="title function_ invoke__">is_win</span>(&amp;board) &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; win!&quot;</span>, current_player);</span><br><span class="line">            <span class="keyword">break</span>;	<span class="comment">// 或者 return;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="title function_ invoke__">is_full</span>(&amp;board) &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Draw!&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 保证上一步下完既没有人win，也没有下满棋盘，才能轮到下一手</span></span><br><span class="line">        current_player = <span class="title function_ invoke__">next_player</span>(current_player);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">is_win</span>(board: &amp;[[<span class="type">char</span>; <span class="number">3</span>]; <span class="number">3</span>]) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 行</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">row</span> <span class="keyword">in</span> board &#123;</span><br><span class="line">        <span class="keyword">if</span> row[<span class="number">0</span>] == row[<span class="number">1</span>] &amp;&amp; row[<span class="number">1</span>] == row[<span class="number">2</span>] &amp;&amp; row[<span class="number">0</span>] != <span class="string">&#x27; &#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 列</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">col</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">3</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> board[<span class="number">0</span>][col] == board[<span class="number">1</span>][col] &amp;&amp; board[<span class="number">1</span>][col] == board[<span class="number">2</span>][col] &amp;&amp; board[<span class="number">0</span>][col] != <span class="string">&#x27; &#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对角线</span></span><br><span class="line">    <span class="keyword">if</span> board[<span class="number">0</span>][<span class="number">0</span>] == board[<span class="number">1</span>][<span class="number">1</span>] &amp;&amp; board[<span class="number">1</span>][<span class="number">1</span>] == board[<span class="number">2</span>][<span class="number">2</span>] &amp;&amp; board[<span class="number">0</span>][<span class="number">0</span>] != <span class="string">&#x27; &#x27;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> board[<span class="number">0</span>][<span class="number">2</span>] == board[<span class="number">1</span>][<span class="number">1</span>] &amp;&amp; board[<span class="number">1</span>][<span class="number">1</span>] == board[<span class="number">2</span>][<span class="number">0</span>] &amp;&amp; board[<span class="number">0</span>][<span class="number">2</span>] != <span class="string">&#x27; &#x27;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">is_full</span>(board: &amp;[[<span class="type">char</span>; <span class="number">3</span>]; <span class="number">3</span>]) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">row</span> <span class="keyword">in</span> board &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">col</span> <span class="keyword">in</span> row &#123;</span><br><span class="line">            <span class="keyword">if</span> *col == <span class="string">&#x27; &#x27;</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Ok，基本的功能已经基本实现了，可以运行玩一玩。这节内容其实没有涉及多少Rust真正深入的部分，上面遗留的很多问题<del>（挖的很多坑）</del>，会在下一节解答，下一节也会逐渐带你认识rust一些真正吸引人的特性。</p>
<h1 id="Improve-your-Rust-code"><a href="#Improve-your-Rust-code" class="headerlink" title="Improve your Rust code"></a>Improve your Rust code</h1><p>相信大佬们看了上面的很不尽兴吧，<del>我想要看Rust独特的特性（震声</del>，别急，本节会给出一个答复。</p>
<h2 id="使用struct封装"><a href="#使用struct封装" class="headerlink" title="使用struct封装"></a>使用struct封装</h2><p>我们可以定义一个Game结构体，来记录一些游戏属性。</p>
<p>在rust中，定义结构体和C是类似的：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Game</span> &#123;</span><br><span class="line">    board: [<span class="type">char</span>; <span class="number">9</span>],</span><br><span class="line">    players: [<span class="type">char</span>; <span class="number">2</span>],</span><br><span class="line">    current_player: <span class="type">usize</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在原来的版本中，我们是使用X和O来代替玩家，但是这样太草率了，很多读者肯定不会买账的，所以这里我们定义一个Player结构体，储存名字和对应的符号</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Player</span> &#123;</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">    symbol: <span class="type">char</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然前面的Game的players的类型也要做相应的修改。</p>
<p>那么我们怎么封装逻辑呢，这里我们是可以像其他语言的class一样为创建的结构体定义一组方法的。我们可以使用impl （implement）关键字为一个struct定义一组或多组实现</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Game</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> Game &#123;</span><br><span class="line">        Game &#123;</span><br><span class="line">            board: [<span class="string">&#x27; &#x27;</span>; <span class="number">9</span>],</span><br><span class="line">            players: [Player::<span class="title function_ invoke__">new</span>(); <span class="number">2</span>],</span><br><span class="line">            current_turn: <span class="number">0</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Player</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> Player &#123;</span><br><span class="line">        Player &#123;</span><br><span class="line">            name: <span class="string">&quot;Test Player&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">            symbol: <span class="string">&#x27;X&#x27;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在main里创建一个Game试试，</p>
<blockquote>
<p>  会发现爆了一个错误</p>
  <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Compiling playground v0.<span class="number">0.1</span> (/playground)</span><br><span class="line">error[<span class="type">E0277</span>]: the trait bound `Player: <span class="built_in">Copy</span>` is not satisfied</span><br><span class="line">  <span class="literal">--</span>&gt; src/main.rs:<span class="number">21</span>:<span class="number">23</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">21</span> |             players: [<span class="type">Player</span>::<span class="type">new</span>(); <span class="number">2</span>],</span><br><span class="line">   |                       ^^^^^^^^^^^^^ the trait `Copy` is not implemented <span class="keyword">for</span> `Player`</span><br><span class="line">   |</span><br><span class="line">   = note: the `Copy` trait is required because this value will be copied <span class="keyword">for</span> each element of the array</span><br><span class="line"></span><br><span class="line"><span class="keyword">For</span> more information about this error, <span class="keyword">try</span> `rustc <span class="literal">--explain</span> E0277`.</span><br><span class="line">error: could not compile `playground` (bin <span class="string">&quot;playground&quot;</span>) due to previous error</span><br></pre></td></tr></table></figure>

<p>  这个在前面说过，是由于没有实现Copy特征，我们可以试试通过派生宏来快速实现一个特征</p>
  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Copy)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Player</span> &#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  发现还是报错了</p>
  <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Compiling playground v0.<span class="number">0.1</span> (/playground)</span><br><span class="line">error[<span class="type">E0204</span>]: the trait `Copy` cannot be implemented <span class="keyword">for</span> this <span class="built_in">type</span></span><br><span class="line">  <span class="literal">--</span>&gt; src/main.rs:<span class="number">11</span>:<span class="number">10</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">11</span> | <span class="comment">#[derive(Copy)]</span></span><br><span class="line">   |          ^^^^</span><br><span class="line"><span class="number">12</span> | struct Player &#123;</span><br><span class="line"><span class="number">13</span> |     name: String,</span><br><span class="line">   |     <span class="literal">------------</span> this field does not implement `Copy`</span><br><span class="line">   |</span><br><span class="line">   = note: this error originates <span class="keyword">in</span> the derive macro `Copy` (<span class="keyword">in</span> Nightly builds, run with <span class="literal">-Z</span> macro<span class="literal">-backtrace</span> <span class="keyword">for</span> more info)</span><br><span class="line"></span><br><span class="line"><span class="keyword">For</span> more information about this error, <span class="keyword">try</span> `rustc <span class="literal">--explain</span> E0204`.</span><br><span class="line">error: could not compile `playground` (bin <span class="string">&quot;playground&quot;</span>) due to previous error</span><br></pre></td></tr></table></figure>

<p>  由于Player里面包含了String，所以不能为Player实现Copy特征，这是因为数据在堆上，不能快速拷贝，所以无法实现Copy，这也意味着我们不能用这个[xxx; n] 的格式来快速生成了，其实这是一个语法糖，当数据长度比较大，用这个就很方便，当然我们只能采用最普通的方法： <code>[Player::new(), Player::new()]</code>， 就是有几个就写几遍，或者也可以创建一个空的Vec后面在push两个Player进去。</p>
</blockquote>
<p>改好后我们可以输出一下Game的信息看看。</p>
<p>如果你习惯写C，可能会想要依次访问每个成员，再输出，在rust里当然可以，不过更加优雅的方式是为该结构体实现一个Debug特征</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Game</span> &#123;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Player</span> &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里面的#[derive()]是一个派生宏，可以快速实现某些特征，当然如果想要自定义效果，你也可以自己手动实现该特征。通过派生宏来实现的一个条件是必须每个成员都实现了该特征，因为Game里面有成员的类型包含了Player，所以我们得给Player也实现Debug，由于Player里面的String和char是默认实现了该特征，所以Player才能实现Debug，像前面Copy特征正是由于String在堆上，不能实现Copy，导致Player也不能实现Copy特征。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">game</span> = Game::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, &amp;game);</span><br><span class="line">    <span class="comment">// 或者选择更好的输出方式</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:#?&#125;&quot;</span>, &amp;game);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Game &#123; board: [<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27; &#x27;</span>], players: [<span class="type">Player</span> &#123; <span class="type">name</span>: <span class="string">&quot;Test Player&quot;</span>, <span class="type">symbol</span>: <span class="string">&#x27;X&#x27;</span> &#125;, <span class="type">Player</span> &#123; <span class="type">name</span>: <span class="string">&quot;Test Player&quot;</span>, <span class="type">symbol</span>: <span class="string">&#x27;X&#x27;</span> &#125;], current_player: <span class="number">0</span> &#125;</span><br><span class="line">Game &#123;</span><br><span class="line">    board: [</span><br><span class="line">        <span class="string">&#x27; &#x27;</span>,</span><br><span class="line">        <span class="string">&#x27; &#x27;</span>,</span><br><span class="line">        <span class="string">&#x27; &#x27;</span>,</span><br><span class="line">        <span class="string">&#x27; &#x27;</span>,</span><br><span class="line">        <span class="string">&#x27; &#x27;</span>,</span><br><span class="line">        <span class="string">&#x27; &#x27;</span>,</span><br><span class="line">        <span class="string">&#x27; &#x27;</span>,</span><br><span class="line">        <span class="string">&#x27; &#x27;</span>,</span><br><span class="line">        <span class="string">&#x27; &#x27;</span>,</span><br><span class="line">    ],</span><br><span class="line">    players: [</span><br><span class="line">        <span class="type">Player</span> &#123;</span><br><span class="line">            <span class="type">name</span>: <span class="string">&quot;Test Player&quot;</span>,</span><br><span class="line">            <span class="type">symbol</span>: <span class="string">&#x27;X&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="type">Player</span> &#123;</span><br><span class="line">            <span class="type">name</span>: <span class="string">&quot;Test Player&quot;</span>,</span><br><span class="line">            <span class="type">symbol</span>: <span class="string">&#x27;X&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    ],</span><br><span class="line">    current_player: <span class="number">0</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体选择哪种取决你自己实际需求，如果都不合你胃口，就可以自己实现一个Debug特征</p>
<h2 id="自定义Debug样式"><a href="#自定义Debug样式" class="headerlink" title="自定义Debug样式"></a>自定义Debug样式</h2><p>如果学过面向对象，那么肯定知道继承这个概念，但是一上手可能很容易写出屎山，而且不好维护（如果你对某个基类做了修改的话），而Rust选择抛弃了继承这一个糟糕的特性，选择另一种更加优雅的方式来实现类的多态，也就是trait。</p>
<p>Trait（特征）是为一些类定义的一组行为，如果要一个struct使用某个特征的功能，只要为它实现该特征即可，一个struct可以实现多个特征。来看看例子，我们来为Player和Game实现自定义的Debug</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::&#123;<span class="built_in">Debug</span>, Formatter, <span class="type">Result</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Debug</span> <span class="keyword">for</span> <span class="title class_">Player</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> Formatter&lt;<span class="symbol">&#x27;_</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Result</span> &#123;</span><br><span class="line">        <span class="built_in">write!</span>(f, <span class="string">&quot;Player &#123;&#125; with &#123;&#125;&quot;</span>, &amp;<span class="keyword">self</span>.name, &amp;<span class="keyword">self</span>.symbol)</span><br><span class="line">        <span class="comment">// 注意不要带分号，因为要返回Result，带分号就返回()了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Debug</span> <span class="keyword">for</span> <span class="title class_">Game</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> Formatter&lt;<span class="symbol">&#x27;_</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Result</span> &#123;</span><br><span class="line">        f.<span class="title function_ invoke__">debug_struct</span>(<span class="string">&quot;Game&quot;</span>)</span><br><span class="line">            .<span class="title function_ invoke__">field</span>(<span class="string">&quot;board&quot;</span>, &amp;<span class="built_in">format!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, &amp;<span class="keyword">self</span>.board) <span class="keyword">as</span> &amp;<span class="keyword">dyn</span> <span class="built_in">Debug</span>)</span><br><span class="line">            .<span class="title function_ invoke__">field</span>(<span class="string">&quot;players&quot;</span>, &amp;<span class="keyword">self</span>.players)</span><br><span class="line">            .<span class="title function_ invoke__">field</span>(<span class="string">&quot;current_player&quot;</span>, &amp;<span class="keyword">self</span>.current_player)</span><br><span class="line">            .<span class="title function_ invoke__">finish</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再运行看看就发先变成自定义的了，记得去掉<code>#[derive(Debug)]</code>，否则会提示你实现Debug特征冲突了</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Game &#123; board: <span class="string">&quot;[&#x27; &#x27;, &#x27; &#x27;, &#x27; &#x27;, &#x27; &#x27;, &#x27; &#x27;, &#x27; &#x27;, &#x27; &#x27;, &#x27; &#x27;, &#x27; &#x27;]&quot;</span>, players: [<span class="type">Player</span> <span class="type">Test</span> <span class="type">Player</span> <span class="type">with</span> <span class="type">X</span>, <span class="type">Player</span> <span class="type">Test</span> <span class="type">Player</span> <span class="type">with</span> <span class="type">X</span>], current_player: <span class="number">0</span> &#125;</span><br><span class="line">Game &#123;</span><br><span class="line">    board: <span class="string">&quot;[&#x27; &#x27;, &#x27; &#x27;, &#x27; &#x27;, &#x27; &#x27;, &#x27; &#x27;, &#x27; &#x27;, &#x27; &#x27;, &#x27; &#x27;, &#x27; &#x27;]&quot;</span>,</span><br><span class="line">    players: [</span><br><span class="line">        <span class="type">Player</span> <span class="type">Test</span> <span class="type">Player</span> <span class="type">with</span> <span class="type">X</span>,</span><br><span class="line">        <span class="type">Player</span> <span class="type">Test</span> <span class="type">Player</span> <span class="type">with</span> <span class="type">X</span>,</span><br><span class="line">    ],</span><br><span class="line">    current_player: <span class="number">0</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用Option"><a href="#使用Option" class="headerlink" title="使用Option"></a>使用Option</h2><p>我们不妨把函数迁移到我们定义的struct吧，但这里其实会发现：我们很多函数都是直接对与board的操作，那么这里我们如果直接为Game实现这些功能，就会发现非常的丑陋，尤其是is_win，is_full这些只用到了board的函数。那么我们为什么不定义一个Board，而把这部分逻辑封装到board里面呢？</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Board</span> &#123;</span><br><span class="line">    cells: [....]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这次我们就不按照之前的使用char数组了，我们使用char数组时是用空格作为初始值的，但是这样其实并不好<del>（如果我想用空格作为玩家的符号呢）</del>。在这种情况下，Option是一个很好的解决办法！Option和Result的定义很像</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(T),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很好理解吧，要么有值（Some），要么是空（None）。这样设计的好处就是避免了像C一样0和NULL冲突。你只需要吧None作为一个仅代表空这个意义的东西。</p>
<p>那么我们来改写一下board</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Board</span> &#123;</span><br><span class="line">    cells: [<span class="type">Option</span>&lt;<span class="type">char</span>&gt;; <span class="number">9</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Board</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> Board &#123;</span><br><span class="line">        Board &#123; cells: [<span class="literal">None</span>; <span class="number">9</span>] &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// other function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  因为Option是被放在了prelude模块中的，prelude会放一下比较常用的东西，可以不需要导入就可以使用。这里当然也可以使用<code>Option::None</code></p>
</blockquote>
<p>那么该如何处理这些值呢？可以用前面介绍的 <code>.unwrap()</code>，来取出里面的值，但是注意！如果遇到None就会错误（因为None代表空的意义，也就是<strong>没有值</strong>，所以当然unwrap不了），然后程序崩溃。所以前面我也说过<strong>unwrap适合你几乎能确定不会报错的情况下</strong>。</p>
<h2 id="用模式匹配来处理异常"><a href="#用模式匹配来处理异常" class="headerlink" title="用模式匹配来处理异常"></a>用模式匹配来处理异常</h2><p>比如要实现输出board，那么就不可避免的要处理Option，那么就可以像这样</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Board</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">render</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;+---+---+---+&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">row</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">3</span> &#123;</span><br><span class="line">            <span class="built_in">print!</span>(<span class="string">&quot;| &quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> <span class="variable">col</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">3</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">cell</span> = <span class="keyword">self</span>.cells[row * <span class="number">3</span> + col];</span><br><span class="line">                <span class="keyword">match</span> cell &#123;</span><br><span class="line">                    <span class="title function_ invoke__">Some</span>(value) =&gt; <span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; | &quot;</span>, value),</span><br><span class="line">                    <span class="literal">None</span> =&gt; <span class="built_in">print!</span>(<span class="string">&quot;  | &quot;</span>),</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">println!</span>();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;+---+---+---+&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>match会自动匹配到格式一样的模式，如果你是Some，就会匹配到第一种，如果是None就会匹配到第二个。要注意：<strong>match必须穷尽所有可能</strong>， 如果你想不到更多的可能，你可以匹配到 <code>_</code>， 这代表除了上面的模式以外的全部模式（必须放在最后）。</p>
<p>来回去看我们的前面写的读入终端内容的那一行 <code>stdin.read_line(&amp;mut input).unwrap();</code>， 我们如果不能确保是否一定没有问题，我们就可以用match来手动处理，但是这里我们介绍另一种常用的模式匹配 <code>if let</code></p>
<p>因为如果是正常的话我们不需要做额外的处理，所有我们只需要匹配Result::Err这一种模式就可以了<strong>（只要匹配一种或者少量的模式，那么if let就非常适合）</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为让程序自己出现异常来panic的话，会输出很多额外的东西（给开发者看的，但是显然不是用户想看到的）</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(e) = stdin.<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> input) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;[Error]: &#123;&#125;&quot;</span>, e);</span><br><span class="line">    std::process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Move-移动-and-Move-落子"><a href="#Move-移动-and-Move-落子" class="headerlink" title="Move(移动) and Move(落子)"></a>Move(移动) and Move(落子)</h2><h3 id="简单的与C互操作"><a href="#简单的与C互操作" class="headerlink" title="简单的与C互操作"></a>简单的与C互操作</h3><p>如果只是像原来那样输入坐标的话也太难受了，这一点也不游戏！！！相信读者大爹们肯定不会买账的。所以我们来实现一下通过键盘的WASD来选择棋盘的落点（这样也不用担心输入坐标的越界问题），SPACE来确定落子。</p>
<p>也就是说我们需要每次按键后，程序都能及时反应。但是Rust没有直接提供一个类似于C的getch方法，当然还有第三方库可以实现按键监控，不过这里为了介绍与C互操作所以选择了调用C API。</p>
<p>我们需要使用extern关键字</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>我们需要一个getch用来接收按键，和一个kbhit监测是否有按键事件。在extern中定义接口</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">_getch</span>() <span class="punctuation">-&gt;</span> <span class="type">u8</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">_kbhit</span>() <span class="punctuation">-&gt;</span> <span class="type">bool</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就可以封装一个按键监控的函数了，要注意ffi是不安全的，所以代码必须用unsafe包裹，（或者把函数声明为unsafe，但是这会导致每次调用都得使用unsafe）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">getch</span>(on_block: <span class="type">bool</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">u8</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="comment">// 设置了一个on_block来指示是否阻塞，true就会等待按下</span></span><br><span class="line">        <span class="keyword">if</span> on_block || _kbhit() &#123;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(_getch())</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="literal">None</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们把原来的main里面的逻辑迁移到Game的run方法里，为了提供一个更良好的游戏环境，你做了一个决定是清空屏幕！</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::process::Command;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Game</span> &#123;</span><br><span class="line">    <span class="comment">// other fn</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">run</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;you can use WASD to move the cursor, and press &lt;SPACE&gt; to place the symbol.&quot;</span>);</span><br><span class="line">    	<span class="built_in">print!</span>(<span class="string">&quot;We will clear the screen before start.\nAre you sure to start? (Y/n): &quot;</span>);</span><br><span class="line">        std::io::<span class="title function_ invoke__">stdout</span>().<span class="title function_ invoke__">flush</span>().<span class="title function_ invoke__">unwrap</span>();		<span class="comment">// 刷新缓冲区，否则会在输入后才输入print!里面的东西</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">opt</span> = <span class="title function_ invoke__">getch</span>(<span class="literal">true</span>);	<span class="comment">// 等待输入</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(opt) = opt &#123;</span><br><span class="line">            <span class="keyword">if</span> !matches!(opt <span class="keyword">as</span> <span class="type">char</span>, <span class="string">&#x27;Y&#x27;</span>|<span class="string">&#x27;y&#x27;</span>|<span class="string">&#x27;\r&#x27;</span>|<span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Command::<span class="title function_ invoke__">new</span>(<span class="string">&quot;Powershell&quot;</span>)</span><br><span class="line">        	.<span class="title function_ invoke__">args</span>(&amp;[<span class="string">&quot;-c&quot;</span>, <span class="string">&quot;cls&quot;</span>])</span><br><span class="line">        	.<span class="title function_ invoke__">status</span>()</span><br><span class="line">        	.<span class="title function_ invoke__">expect</span>(<span class="string">&quot;failed to clear screen&quot;</span>);</span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后处理输入，给Game添加一个<code>current_pos: usize</code>记录当前位置（记得改new）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in loop</span></span><br><span class="line"><span class="keyword">self</span>.board.<span class="title function_ invoke__">render</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">opt</span> = <span class="title function_ invoke__">getch</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">match</span> opt &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(opt) =&gt; <span class="keyword">match</span> opt &#123;</span><br><span class="line">        <span class="string">b&#x27;q&#x27;</span> =&gt; <span class="keyword">break</span>,</span><br><span class="line">        <span class="string">b&#x27;w&#x27;</span> =&gt; <span class="keyword">if</span> <span class="keyword">self</span>.current_pos &gt;= <span class="number">3</span> &#123; <span class="keyword">self</span>.current_pos -= <span class="number">3</span> &#125;,</span><br><span class="line">        <span class="string">b&#x27;s&#x27;</span> =&gt; <span class="keyword">if</span> <span class="keyword">self</span>.current_pos &lt; <span class="number">6</span> &#123; <span class="keyword">self</span>.current_pos += <span class="number">3</span> &#125;,</span><br><span class="line">        <span class="string">b&#x27;a&#x27;</span> =&gt; <span class="keyword">if</span> <span class="keyword">self</span>.current_pos % <span class="number">3</span> &gt; <span class="number">0</span> &#123; <span class="keyword">self</span>.current_pos -= <span class="number">1</span> &#125;,</span><br><span class="line">        <span class="string">b&#x27;d&#x27;</span> =&gt; <span class="keyword">if</span> <span class="keyword">self</span>.current_pos % <span class="number">3</span> &lt; <span class="number">2</span> &#123; <span class="keyword">self</span>.current_pos += <span class="number">1</span> &#125;,</span><br><span class="line">        <span class="string">b&#x27; &#x27;</span> =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">self</span>.board.cells[<span class="keyword">self</span>.current_pos].<span class="title function_ invoke__">is_none</span>() &#123;</span><br><span class="line">                <span class="keyword">self</span>.board.cells[<span class="keyword">self</span>.current_pos] = </span><br><span class="line">                	<span class="title function_ invoke__">Some</span>(<span class="keyword">self</span>.players[<span class="keyword">self</span>.current_player].<span class="title function_ invoke__">as_ref</span>().<span class="title function_ invoke__">unwrap</span>().symbol);</span><br><span class="line">                <span class="keyword">self</span>.current_player ^= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="literal">None</span> =&gt; &#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// is win and is full</span></span><br></pre></td></tr></table></figure>



<h2 id="Register-players"><a href="#Register-players" class="headerlink" title="Register players"></a>Register players</h2><p>现在好像player还是默认的，我们得实现传参自定义玩家。我们为Game实现一个register_player来注册玩家，所以在注册前玩家是空（None），我们把Game的player字段改成 <code>[Option&lt;Player&gt;; 2]</code>，并在Game::new()初始化为None。</p>
<p>register_player应该接收一个player数组，并且把前2个复制给Game，这里为了能链式调用选择返回本身</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Game</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">register_player</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, players: &amp;[Player]) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">mut</span> Game &#123;</span><br><span class="line">        <span class="keyword">self</span>.players = [</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(players[<span class="number">0</span>].<span class="title function_ invoke__">clone</span>()),</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(players[<span class="number">1</span>].<span class="title function_ invoke__">clone</span>())</span><br><span class="line">        ];</span><br><span class="line">        <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后你可以在像这样调用</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    Game::<span class="title function_ invoke__">new</span>()</span><br><span class="line">    	.<span class="title function_ invoke__">register_player</span>(&amp;<span class="built_in">vec!</span>[</span><br><span class="line">            Player::<span class="title function_ invoke__">new</span>(name: &amp;<span class="type">str</span>, symbol: <span class="type">char</span>),</span><br><span class="line">            Player &#123; name: <span class="string">&quot;B&quot;</span>.<span class="title function_ invoke__">to_string</span>(), symbol: <span class="string">&#x27;O&#x27;</span> &#125;,</span><br><span class="line">    ]).<span class="title function_ invoke__">run</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Player</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(name: &amp;<span class="type">str</span>, symbol: <span class="type">char</span>) <span class="punctuation">-&gt;</span> Player &#123;</span><br><span class="line">        Player &#123;</span><br><span class="line">            name: name.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">            symbol,		<span class="comment">// 变量名和成员名相同可以省略</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是比较麻烦，因为你每个都要new一下，有没有能够更加简化书写的方式呢？</p>
<p>当然有，你可以用宏来实现。</p>
<h3 id="编写一个简单的宏"><a href="#编写一个简单的宏" class="headerlink" title="编写一个简单的宏"></a>编写一个简单的宏</h3><p>Rust的宏非常强大，可以做很多事情，比如不定长参数等等，宏一般分为声明宏（也就是马上要讲的，和派生宏等），相信大家在前面已经见识到了派生宏的强大了，接下来看看如何定义一个宏。</p>
<p>我们定义一个register_player宏来帮我更方便的生成一个Player数组</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> register_player &#123;</span><br><span class="line">    ($($name:expr =&gt; $sym:expr),*) =&gt; &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// return the start two</span></span><br><span class="line">            <span class="built_in">vec!</span>[$(Player::<span class="title function_ invoke__">new</span>($name, $sym),)*][..<span class="number">2</span>].<span class="title function_ invoke__">to_vec</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后你可以这么调用，要注意宏后面可以跟（）, [], {}， 虽然都可以，但是一般会有一个约定的写法，比如println!是 ()， vec!是[]</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    Game::<span class="title function_ invoke__">new</span>()</span><br><span class="line">    	.<span class="title function_ invoke__">register_player</span>(</span><br><span class="line">    		&amp;register_player!&#123;</span><br><span class="line">                <span class="string">&quot;Player1&quot;</span> =&gt; <span class="string">&#x27;X&#x27;</span>，</span><br><span class="line">                <span class="string">&quot;Player2&quot;</span> =&gt; <span class="string">&#x27;O&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">    	).<span class="title function_ invoke__">run</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  宏的定义允许像match一样写多个模式，只不过宏匹配的是一段Rust源代码。</p>
<p>  register_player宏接受一系列的表达式，每个表达式由一个名字和一个符号组成，然后为每个表达式创建一个新的 <code>Player</code> 对象。</p>
<p>  宏的参数使用 <code>$(...),*</code> 的形式定义，这表示宏接受任意数量的参数，每个参数都应该匹配 <code>...</code> 中的模式，参数之间用逗号分隔。</p>
<p>  在宏的主体中，首先使用 <code>vec!</code> 宏创建一个 <code>Player</code> 对象的向量，每个 <code>Player</code> 对象都使用 <code>Player::new($name, $sym)</code> 创建。然后，使用 <code>[..2].to_vec()</code> 取向量的前两个元素并转换为新的向量。</p>
<p>  总的来说，这个宏的作用是接受一系列的名字和符号，为每个名字和符号创建一个 <code>Player</code> 对象，然后返回前两个 <code>Player</code> 对象的向量。</p>
</blockquote>
<h2 id="为不同平台分别实现"><a href="#为不同平台分别实现" class="headerlink" title="为不同平台分别实现"></a>为不同平台分别实现</h2><p>在上面我们实现了getch功能使用了C接口，而其中kbhit是在windows平台的函数（如果没有记错应该在windows.h里面），所以如果你尝试编译为其他平台的可执行文件，就会出问题，在这里问题很可能是编译时找不到kbhit这个符号。（可以自己编译看看错误）</p>
<p>那么如果能找到天然跨平台的实现就好了（显然使用纯rust不会有这种问题），但是这往往比较困难。所以我们可以考虑另一种方式，也就是为不同的平台分别实现相应的方法即可！</p>
<p>假定只要编译到windows和linux，我们来改写一下上面实现的getch</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(target_os = <span class="string">&quot;windows&quot;</span>)]</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">_getch</span>() <span class="punctuation">-&gt;</span> <span class="type">u8</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">_kbhit</span>() <span class="punctuation">-&gt;</span> <span class="type">bool</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们通过cfg来设置一个（块）语句的某些属性，这里是指定这段代码只在windows平台有效，只有编译成windows平台的可执行文件才会编译这部分。</p>
<p>同样我们也给getch标上（这里改了个名字，因为感觉key会更合适一点）</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(target_os = <span class="string">&quot;windows&quot;</span>)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">getkey</span>(on_blocking: <span class="type">bool</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">u8</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> on_blocking || <span class="keyword">unsafe</span> &#123; _kbhit() &#125; &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; <span class="title function_ invoke__">Some</span>(_getch()) &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="literal">None</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来要写linux部分的实现了，linux里并没有（大概？）直接提供类似kbhit的函数，但是我们可以在读一个字节后返回。</p>
<p>我们得先导入libc库 <code>cargo add libc</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(target_os = <span class="string">&quot;linux&quot;</span>)]</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> libc;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(target_os = <span class="string">&quot;linux&quot;</span>)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">getkey</span>(on_blocking: <span class="type">bool</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">u8</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// 建议直接在函数内部use就可以了，毕竟如果不是linux平台也用不到</span></span><br><span class="line">    <span class="keyword">use</span> libc::&#123;termios, ECHO, ICANON, TCSANOW, VMIN, VTIME&#125;;</span><br><span class="line">    <span class="keyword">use</span> std::io::&#123;stdin, Read&#125;;</span><br><span class="line">    <span class="keyword">use</span> std::mem::zeroed;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">termios</span> = <span class="keyword">unsafe</span> &#123; zeroed::&lt;termios&gt;() &#125;;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123; libc::<span class="title function_ invoke__">tcgetattr</span>(<span class="number">0</span>, &amp;<span class="keyword">mut</span> termios) &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">old</span> = termios;</span><br><span class="line">    termios.c_lflag &amp;= !(ICANON | ECHO);</span><br><span class="line">    termios.c_cc[VMIN] = <span class="keyword">if</span> on_blocking &#123; <span class="number">1</span> &#125; <span class="keyword">else</span> &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    termios.c_cc[VTIME] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123; libc::<span class="title function_ invoke__">tcsetattr</span>(<span class="number">0</span>, TCSANOW, &amp;termios) &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">buf</span> = [<span class="number">0_u8</span>; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">res</span> = <span class="keyword">if</span> <span class="title function_ invoke__">stdin</span>().<span class="title function_ invoke__">read</span>(&amp;<span class="keyword">mut</span> buf).<span class="title function_ invoke__">is_ok</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(buf[<span class="number">0</span>])</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="literal">None</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123; libc::<span class="title function_ invoke__">tcsetattr</span>(<span class="number">0</span>, TCSANOW, &amp;old) &#125;;</span><br><span class="line">    res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  首先，这段代码使用了条件编译（<code>#[cfg(target_os = &quot;linux&quot;)]</code>），这意味着这段代码只有在目标操作系统为 Linux 时才会编译和运行。</p>
<p>  然后，函数 <code>getkey</code> 接受一个布尔参数 <code>on_blocking</code>，用于指定是否在等待用户输入时阻塞。</p>
<p>  在函数内部，首先使用 <code>libc</code> 库的 <code>termios</code> 结构体来获取和设置终端的 I&#x2F;O 属性。<code>termios</code> 结构体中的 <code>c_lflag</code> 字段用于控制输入模式，<code>ICANON</code> 和 <code>ECHO</code> 是两个标志位，分别用于控制规范模式（即行缓冲）和回显。通过将这两个标志位清零，函数设置终端为非规范模式和非回显模式，这样就可以立即读取用户的每一个键入，而不需要等待回车键。</p>
<p>  <code>termios</code> 结构体中的 <code>c_cc</code> 字段是一个数组，用于控制特殊字符的行为。<code>VMIN</code> 和 <code>VTIME</code> 是数组中的两个索引，分别用于控制在非规范模式下的最小读取字符数和超时时间。通过设置 <code>VMIN</code> 为 <code>on_blocking</code> 参数（如果 <code>on_blocking</code> 为 <code>true</code>，则 <code>VMIN</code> 为 1，否则为 0），函数可以在没有输入时立即返回，而不是等待用户输入。<code>VTIME</code> 被设置为 0，表示不使用超时。</p>
<p>  然后，函数使用 <code>stdin().read(&amp;mut buf)</code> 从标准输入读取一个字符到 <code>buf</code> 中。如果读取成功，函数返回读取到的字符，否则返回 <code>None</code>。</p>
<p>  最后，函数使用 <code>libc::tcsetattr(0, TCSANOW, &amp;old)</code> 恢复终端的原始 I&#x2F;O 属性。</p>
</blockquote>
<p>当然到这里其实也可以了，但是读者肯定不会买账的，因为每次调用还必须指定bool，我就不能像其他语言一样整个默认参数吗。</p>
<p>由于rust的函数是不支持默认参数的，但是我们可以用宏来实现类似的功能。</p>
<p>前面有提过宏可以像match一样匹配模式，我们这里不妨就设置2种模式，对应阻塞和非阻塞。我们简单把我们的函数包装一下。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> getkey &#123;</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">        <span class="title function_ invoke__">getkey</span>(<span class="literal">false</span>)</span><br><span class="line">    &#125;;</span><br><span class="line">    (block) =&gt; &#123;</span><br><span class="line">        <span class="title function_ invoke__">getkey</span>(<span class="literal">true</span>)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样如果你使用比如 <code>getkey!()</code>， 就会不阻塞。如果使用<code>getkey!(block)</code>，就会阻塞等待用户输入了。这里面的block并不是一个变量，只是一个模式。所以你无须定义block为一个具体的东西，你当然可以写成其他的：D</p>
<h2 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h2><h3 id="编写简单测试"><a href="#编写简单测试" class="headerlink" title="编写简单测试"></a>编写简单测试</h3><p>有时候你想测试某个或着说一部分功能，直接编译整个项目再测试是非常低效的做法。这种情况非常建议你写test模块。</p>
<p>假定我们要测试我们写的register_player宏是否能按照我们想的那样运作，可以像这样写个测试函数</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> test &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">player_reg</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">players</span> = register_player!(</span><br><span class="line">            <span class="string">&quot;Player 1&quot;</span> =&gt; <span class="string">&#x27;X&#x27;</span>,</span><br><span class="line">            <span class="string">&quot;Player 2&quot;</span> =&gt; <span class="string">&#x27;O&#x27;</span></span><br><span class="line">        );</span><br><span class="line">        <span class="comment">/* dbg!(players);</span></span><br><span class="line"><span class="comment">        assert!(false); */</span></span><br><span class="line">        <span class="built_in">assert_eq!</span>(</span><br><span class="line">            players,</span><br><span class="line">            <span class="built_in">vec!</span>[Player::<span class="title function_ invoke__">new</span>(<span class="string">&quot;Player 1&quot;</span>, <span class="string">&#x27;X&#x27;</span>), Player::<span class="title function_ invoke__">new</span>(<span class="string">&quot;Player 2&quot;</span>, <span class="string">&#x27;O&#x27;</span>)]</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在你的终端运行 <code>cargo test</code></p>
<p>如果正常就只能看到ok，出错就会看到你的输出和错误信息。一般如果我们确定大概会有个什么输出，我们就用assert系列的宏，这很好理解。当我们想要比较的内容太多，你懒得输入，你可以主动报错<del>骗它输出</del>， 比如本人就喜欢 <code>assert!(false);</code>， 然后前面记得输出一下，然后你就可以看到回显了：D</p>
<blockquote>
<p>  测试函数可以有很多个，会挨个跑一遍</p>
<p>  super关键字代表当前模块（这里指test）的父模块，所以 <code>use super::*;</code>就是导入父模块的所有项。如果你的register_player等都定义在main.rs中，那么你应该把这段<code>mod test&#123; &#125;</code>放在main.rs中的某个位置（这保证了main是test的父模块）。</p>
</blockquote>
<h3 id="优化你的文件结构（todo）"><a href="#优化你的文件结构（todo）" class="headerlink" title="优化你的文件结构（todo）"></a>优化你的文件结构（todo）</h3>
    </div>

    
    
    

    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>Post author:  </strong>hacbit
  </li>
  <li class="post-copyright-link">
    <strong>Post link: </strong>
    <a href="http://hacbit.tech/Rust-QuickStart/" title="Rust-QuickStart">http://hacbit.tech/Rust-QuickStart/</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> unless stating additionally.
  </li>
</ul>
</div>

        

  <div class="followme">
    <p>Welcome to my other publishing channels</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
        </div>
    </div>
  </div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/Rust/" rel="tag"><i class="fa fa-tag"></i> Rust</a>
              <a href="/tags/Tutorial/" rel="tag"><i class="fa fa-tag"></i> Tutorial</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/Shellcode%E7%BC%96%E5%86%99%E5%85%A5%E9%97%A8/" rel="prev" title="Shellcode编写入门">
      <i class="fa fa-chevron-left"></i> Shellcode编写入门
    </a></div>
      <div class="post-nav-item">
    <a href="/idapython%E5%85%A5%E9%97%A8/" rel="next" title="idapython入门">
      idapython入门 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#This-book"><span class="nav-number">1.</span> <span class="nav-text">This book?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Before-Start"><span class="nav-number">2.</span> <span class="nav-text">Before Start</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Install-Rust"><span class="nav-number">2.1.</span> <span class="nav-text">Install Rust</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Cargo-quick-start"><span class="nav-number">2.2.</span> <span class="nav-text">Cargo quick-start</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Quick-Start-with-a-small-Game"><span class="nav-number">3.</span> <span class="nav-text">Quick Start with a small Game</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Create-your-Tic-tac-toe"><span class="nav-number">3.1.</span> <span class="nav-text">Create your Tic-tac-toe</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Start-with-putting-something"><span class="nav-number">3.2.</span> <span class="nav-text">Start with putting something</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Game-initialize"><span class="nav-number">3.3.</span> <span class="nav-text">Game initialize</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Game-Update"><span class="nav-number">3.4.</span> <span class="nav-text">Game Update</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Definite-a-function-to-put-chessboard"><span class="nav-number">3.4.1.</span> <span class="nav-text">Definite a function to put chessboard</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Receive-input-and-Process-it"><span class="nav-number">3.4.2.</span> <span class="nav-text">Receive input and Process it</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Move"><span class="nav-number">3.4.3.</span> <span class="nav-text">Move</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Win-or-Draw"><span class="nav-number">3.4.4.</span> <span class="nav-text">Win or Draw</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Improve-your-Rust-code"><span class="nav-number">4.</span> <span class="nav-text">Improve your Rust code</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8struct%E5%B0%81%E8%A3%85"><span class="nav-number">4.1.</span> <span class="nav-text">使用struct封装</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89Debug%E6%A0%B7%E5%BC%8F"><span class="nav-number">4.2.</span> <span class="nav-text">自定义Debug样式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8Option"><span class="nav-number">4.3.</span> <span class="nav-text">使用Option</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E6%9D%A5%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8"><span class="nav-number">4.4.</span> <span class="nav-text">用模式匹配来处理异常</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Move-%E7%A7%BB%E5%8A%A8-and-Move-%E8%90%BD%E5%AD%90"><span class="nav-number">4.5.</span> <span class="nav-text">Move(移动) and Move(落子)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E7%9A%84%E4%B8%8EC%E4%BA%92%E6%93%8D%E4%BD%9C"><span class="nav-number">4.5.1.</span> <span class="nav-text">简单的与C互操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Register-players"><span class="nav-number">4.6.</span> <span class="nav-text">Register players</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%AE%8F"><span class="nav-number">4.6.1.</span> <span class="nav-text">编写一个简单的宏</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%B8%8D%E5%90%8C%E5%B9%B3%E5%8F%B0%E5%88%86%E5%88%AB%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.7.</span> <span class="nav-text">为不同平台分别实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Others"><span class="nav-number">4.8.</span> <span class="nav-text">Others</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E5%86%99%E7%AE%80%E5%8D%95%E6%B5%8B%E8%AF%95"><span class="nav-number">4.8.1.</span> <span class="nav-text">编写简单测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E4%BD%A0%E7%9A%84%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%EF%BC%88todo%EF%BC%89"><span class="nav-number">4.8.2.</span> <span class="nav-text">优化你的文件结构（todo）</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="hacbit"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">hacbit</p>
  <div class="site-description" itemprop="description">The world open itself before those with noble heart.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/hacbit" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;hacbit" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:hacbit@foxmail.com" title="E-Mail → mailto:hacbit@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


<div style="">
  <canvas id="canvas" style="width:60%;">当前浏览器不支持canvas，请更换浏览器后再试</canvas>
</div>
<script>
(function(){

   var digit=
    [
        [
            [0,0,1,1,1,0,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,0,1,1,0],
            [0,0,1,1,1,0,0]
        ],//0
        [
            [0,0,0,1,1,0,0],
            [0,1,1,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [1,1,1,1,1,1,1]
        ],//1
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,1,1],
            [1,1,1,1,1,1,1]
        ],//2
        [
            [1,1,1,1,1,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//3
        [
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,0],
            [0,0,1,1,1,1,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,1,1,0],
            [1,1,1,1,1,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,1]
        ],//4
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,1,1,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//5
        [
            [0,0,0,0,1,1,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//6
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0]
        ],//7
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//8
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,1,1,0,0,0,0]
        ],//9
        [
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0]
        ]//:
    ];

var canvas = document.getElementById('canvas');

if(canvas.getContext){
    var cxt = canvas.getContext('2d');
    //声明canvas的宽高
    var H = 100,W = 700;
    canvas.height = H;
    canvas.width = W;
    cxt.fillStyle = '#f00';
    cxt.fillRect(10,10,50,50);

    //存储时间数据
    var data = [];
    //存储运动的小球
    var balls = [];
    //设置粒子半径
    var R = canvas.height/20-1;
    (function(){
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        //存储时间数字，由十位小时、个位小时、冒号、十位分钟、个位分钟、冒号、十位秒钟、个位秒钟这7个数字组成
        data.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
    })();

    /*生成点阵数字*/
    function renderDigit(index,num){
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    cxt.beginPath();
                    cxt.arc(14*(R+2)*index + j*2*(R+1)+(R+1),i*2*(R+1)+(R+1),R,0,2*Math.PI);
                    cxt.closePath();
                    cxt.fill();
                }
            }
        }
    }

    /*更新时钟*/
    function updateDigitTime(){
        var changeNumArray = [];
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        var NewData = [];
        NewData.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
        for(var i = data.length-1; i >=0 ; i--){
            //时间发生变化
            if(NewData[i] !== data[i]){
                //将变化的数字值和在data数组中的索引存储在changeNumArray数组中
                changeNumArray.push(i+'_'+(Number(data[i])+1)%10);
            }
        }
        //增加小球
        for(var i = 0; i< changeNumArray.length; i++){
            addBalls.apply(this,changeNumArray[i].split('_'));
        }
        data = NewData.concat();
    }

    /*更新小球状态*/
    function updateBalls(){
        for(var i = 0; i < balls.length; i++){
            balls[i].stepY += balls[i].disY;
            balls[i].x += balls[i].stepX;
            balls[i].y += balls[i].stepY;
            if(balls[i].x > W + R || balls[i].y > H + R){
                balls.splice(i,1);
                i--;
            }
        }
    }

    /*增加要运动的小球*/
    function addBalls(index,num){
        var numArray = [1,2,3];
        var colorArray =  ["#3BE","#09C","#A6C","#93C","#9C0","#690","#FB3","#F80","#F44","#C00"];
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    var ball = {
                        x:14*(R+2)*index + j*2*(R+1)+(R+1),
                        y:i*2*(R+1)+(R+1),
                        stepX:Math.floor(Math.random() * 4 -2),
                        stepY:-2*numArray[Math.floor(Math.random()*numArray.length)],
                        color:colorArray[Math.floor(Math.random()*colorArray.length)],
                        disY:1
                    };
                    balls.push(ball);
                }
            }
        }
    }

    /*渲染*/
    function render(){
        //重置画布宽度，达到清空画布的效果
        canvas.height = 100;
        //渲染时钟
        for(var i = 0; i < data.length; i++){
            renderDigit(i,data[i]);
        }
        //渲染小球
        for(var i = 0; i < balls.length; i++){
            cxt.beginPath();
            cxt.arc(balls[i].x,balls[i].y,R,0,2*Math.PI);
            cxt.fillStyle = balls[i].color;
            cxt.closePath();
            cxt.fill();
        }
    }

    clearInterval(oTimer);
    var oTimer = setInterval(function(){
        //更新时钟
        updateDigitTime();
        //更新小球状态
        updateBalls();
        //渲染
        render();
    },50);
}

})();
</script>
      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; Tue Jun 20 2023 08:00:00 GMT+0800 (中国标准时间) – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hacbit</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">Symbols count total: </span>
    <span title="Symbols count total">48k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">Reading time total &asymp;</span>
    <span title="Reading time total">1:27</span>
</div>
  <div class="powered-by">
    <!--Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> -->
  </div>

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">The blog has a total of 43.6k words</span>
</div>


  <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  <span id="busuanzi_container_site_pv">total visits<span id="busuanzi_value_site_pv"></span> times</span>
  <span class="post-meta-divider">|</span>
  <span id="busuanzi_container_site_uv">total visitors<span id="busuanzi_value_site_uv"></span> people</span>
  <span class="post-meta-divider">|</span>

<!-- 初始值纠正 -->
<script>
  $(document).ready(function() {
    var int = setInterval(fixCount, 50); // 每50毫秒执行一次fixCount函数
    var countOffset = 20000; // 初始值偏移量
    var fixCount = function() {
      if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
      if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        } 
    }
  });
</script>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='123,174,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>











<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'neutral',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  





    <script type="text/javascript" src="/js/firework.js"></script>



  <script type="text/javascript" src="/js/click_show_text.js"></script>




</body>
</html>
