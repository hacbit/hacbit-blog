<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>hacbit&#39;s blog</title>
    <link>http://hacbit.tech/</link>
    
    <atom:link href="http://hacbit.tech/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>The world open itself before those with noble heart.</description>
    <pubDate>Sun, 25 May 2025 17:41:05 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>使用CSharp表达式树优化代码</title>
      <link>http://hacbit.tech/%E4%BD%BF%E7%94%A8CSharp%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91%E4%BC%98%E5%8C%96%E4%BB%A3%E7%A0%81/</link>
      <guid>http://hacbit.tech/%E4%BD%BF%E7%94%A8CSharp%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91%E4%BC%98%E5%8C%96%E4%BB%A3%E7%A0%81/</guid>
      <pubDate>Sun, 25 May 2025 03:52:18 GMT</pubDate>
      
      <description>&lt;p&gt;近期在研究 C# 的表达式树，感觉部分场景下使用表达式树会很有优势，不知道表达式树是什么直接看&lt;a href=&quot;https://learn.microsoft.com/zh-cn/dotnet/csharp/advanced-topics/expression-trees/expression-trees-explained&quot;&gt;官方文档&lt;/a&gt;吧&lt;/p&gt;
&lt;p&gt;下面是我遇到的几种觉得可以使用表达式树的场景（具体情况具体分析，建议辩证的看待）&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>近期在研究 C# 的表达式树，感觉部分场景下使用表达式树会很有优势，不知道表达式树是什么直接看<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/advanced-topics/expression-trees/expression-trees-explained">官方文档</a>吧</p><p>下面是我遇到的几种觉得可以使用表达式树的场景（具体情况具体分析，建议辩证的看待）</p><span id="more"></span><h2 id="使用-Expression-代替嵌套-Lambda"><a href="#使用-Expression-代替嵌套-Lambda" class="headerlink" title="使用 Expression 代替嵌套 Lambda"></a>使用 Expression 代替嵌套 Lambda</h2><p>假设一种场景，我们需要构建一个节点树（简单点就只用一个单链了），然后根据节点上的一些信息构建成一个 lambda，比如这样：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">Foo</span>(<span class="params"><span class="built_in">int</span> x</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> Operation</span><br><span class="line">&#123;</span><br><span class="line">    Add,</span><br><span class="line">    Sub,</span><br><span class="line">    Mul,</span><br><span class="line">    Div,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> required Operation Op &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> required <span class="built_in">int</span> Value &#123; <span class="keyword">get</span>; <span class="keyword">init</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Node? Next = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Foo <span class="title">BuildLambda</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Foo proc = Op <span class="keyword">switch</span></span><br><span class="line">        &#123;</span><br><span class="line">            Operation.Add =&gt; x =&gt; x + Value,</span><br><span class="line">            Operation.Sub =&gt; x =&gt; x - Value,</span><br><span class="line">            Operation.Mul =&gt; x =&gt; x * Value,</span><br><span class="line">            Operation.Div =&gt; x =&gt; x / Value,</span><br><span class="line">            _ =&gt; x =&gt; x,</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> x =&gt; proc((Next?.BuildLambda() ?? (x =&gt; x))(x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很容易发现问题，如果树比较复杂，会导致 lambda 套了很多层，自然就导致运行效率不高</p><p>编写一段测试代码</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">const</span> <span class="built_in">int</span> N = <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;Test <span class="subst">&#123;N&#125;</span>&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> node = Generate();</span><br><span class="line">    <span class="keyword">var</span> sw = <span class="keyword">new</span> Stopwatch();</span><br><span class="line">    sw.Start();</span><br><span class="line">    <span class="keyword">var</span> f = node.BuildLambda();</span><br><span class="line">    sw.Stop();</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;Lambda Build used <span class="subst">&#123;sw.ElapsedMilliseconds&#125;</span> ms&quot;</span>);</span><br><span class="line">    sw.Restart();</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        f(i);</span><br><span class="line">    &#125;</span><br><span class="line">    sw.Stop();</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;Lambda Run used <span class="subst">&#123;sw.ElapsedMilliseconds&#125;</span> ms&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">Generate</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> root = <span class="keyword">new</span> Node &#123; Op = Operation.Add, Value = <span class="number">114514</span> &#125;;</span><br><span class="line">    <span class="keyword">var</span> node = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> op = (Operation)Random.Shared.Next(<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">var</span> val = Random.Shared.Next(<span class="number">1919810</span>);</span><br><span class="line">        node!.Next = <span class="keyword">new</span> Node &#123; Op = op, Value = val &#125;;</span><br><span class="line">        node = root.Next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单生成了一个套了大概10层的节点，然后构建成 lambda 去跑数据，测试了几个 N 得到了如下数据</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Test <span class="number">1000</span></span><br><span class="line">Lambda Build used <span class="number">0</span> ms</span><br><span class="line">Lambda Run used <span class="number">0</span> ms</span><br><span class="line"></span><br><span class="line">Test <span class="number">10000</span></span><br><span class="line">Lambda Build used <span class="number">0</span> ms</span><br><span class="line">Lambda Run used <span class="number">21</span> ms</span><br><span class="line"></span><br><span class="line">Test <span class="number">100000</span></span><br><span class="line">Lambda Build used <span class="number">0</span> ms</span><br><span class="line">Lambda Run used <span class="number">36</span> ms</span><br><span class="line"></span><br><span class="line">Test <span class="number">1000000</span></span><br><span class="line">Lambda Build used <span class="number">0</span> ms</span><br><span class="line">Lambda Run used <span class="number">102</span> ms</span><br></pre></td></tr></table></figure><p>接下来可以考虑一下表达式树会有什么优势，很显然，我们可以操作节点树，自下而上合并成一个函数</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Expression&lt;Foo&gt; <span class="title">BuildExpression</span>(<span class="params">ParameterExpression param</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">value</span> = Expression.Constant(Value);</span><br><span class="line">    Expression next = Next?.BuildExpression(param).Body ?? param;</span><br><span class="line">    Expression proc = Op <span class="keyword">switch</span></span><br><span class="line">    &#123;</span><br><span class="line">        Operation.Add =&gt; Expression.Add(next, <span class="keyword">value</span>),</span><br><span class="line">        Operation.Sub =&gt; Expression.Subtract(next, <span class="keyword">value</span>),</span><br><span class="line">        Operation.Mul =&gt; Expression.Multiply(next, <span class="keyword">value</span>),</span><br><span class="line">        Operation.Div =&gt; Expression.Divide(next, <span class="keyword">value</span>),</span><br><span class="line">        _ =&gt; next,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> Expression.Lambda&lt;Foo&gt;(proc, param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过每次获取子表达式，然后把函数体拼接，其实就是把一个树状结构平坦化了</p><blockquote><p>  这里要注意，参数通过函数来传递而不是每次build都在里面定义一个变量是因为即便设置的变量名一样，但是本质也是绑定的不同的参数，这时候就不能直接使用 Body 拼接，否则会运行时异常</p></blockquote><p>做一下基准测试</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Benchmark</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Node node;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">int</span> N = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">GlobalSetup</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Setup</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        node = Program.Generate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Benchmark</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestExpression</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> param = Expression.Parameter(<span class="keyword">typeof</span>(<span class="built_in">int</span>), <span class="string">&quot;x&quot;</span>);</span><br><span class="line">        <span class="keyword">var</span> expr = node.BuildExpression(param);</span><br><span class="line">        <span class="keyword">var</span> f2 = expr.Compile();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            f2(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Benchmark</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestLambda</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> f = node.BuildLambda();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            f(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> summary = BenchmarkRunner.Run&lt;Benchmark&gt;();</span><br><span class="line">        Console.WriteLine(summary);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// other code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/%E4%BD%BF%E7%94%A8CSharp%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91%E4%BC%98%E5%8C%96%E4%BB%A3%E7%A0%81/image-20250526011451685.png" alt="benchmark"></p><p>基本上这个表达式树需要大概 15-30 ms 的时间编译，而运行的性能非常高，这个优势会在数据数量级越高，树结构越复杂的时候由很显著的表现</p><p>不过 expression 缺点是写起来很麻烦，也不直观，而且容易写出 bug，特别是类型对应不上的情况，往往要到运行时报错了才能发现</p><p>一般的情况用嵌套函数已经够了</p><h2 id="反射-Expression-代替纯反射"><a href="#反射-Expression-代替纯反射" class="headerlink" title="反射 + Expression 代替纯反射"></a>反射 + Expression 代替纯反射</h2><p>比如通过反射获取一个 MethodInfo，调用它的方式亦有差别。通常可能会直接 <code>.Invoke(...)</code> 调用了，但是这种动态调用机制会在运行时对传入进行参数类型检查，装拆箱等操作，以及方法的动态派发，同时也没有 JIT 的优化，这导致就算是缓存了这个 info，多次调用也不能有很高的性能。</p><p>这时候可以通过表达式树来提供更好的性能</p><p>比如我们要获取一个类型的 property 的 setter 来进行赋值操作</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Benchmark2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Bar bar;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">int</span> N = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">GlobalSetup</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Setup</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        bar = <span class="keyword">new</span> Bar(<span class="number">114514</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MethodInfo? setter;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">Benchmark</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestReflection</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        setter ??= <span class="keyword">typeof</span>(Bar).GetProperty(<span class="string">&quot;value&quot;</span>, BindingFlags.NonPublic | BindingFlags.Instance)?</span><br><span class="line">            .GetSetMethod(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            setter?.Invoke(bar, <span class="keyword">new</span> <span class="built_in">object</span>[] &#123; i &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是很自然的操作，如果需要多次调用，把这个 methodInfo 缓存下来，之后直接 invoke 这个 methodinfo</p><p>然后我们使用同样的逻辑来使用表达式树，这里使用 <code>Expression.Call</code> 来调用一个 MethodInfo</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Action&lt;Bar, <span class="built_in">int</span>&gt;? setter2;</span><br><span class="line"></span><br><span class="line">[<span class="meta">Benchmark</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestExpression</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (setter2 <span class="keyword">is</span> <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> barParam = Expression.Parameter(<span class="keyword">typeof</span>(Bar), <span class="string">&quot;bar&quot;</span>);</span><br><span class="line">        <span class="keyword">var</span> valueParam = Expression.Parameter(<span class="keyword">typeof</span>(<span class="built_in">int</span>), <span class="string">&quot;value&quot;</span>);</span><br><span class="line">        <span class="keyword">var</span> setterMethod = <span class="keyword">typeof</span>(Bar).GetProperty(<span class="string">&quot;value&quot;</span>, BindingFlags.NonPublic | BindingFlags.Instance)?</span><br><span class="line">            .GetSetMethod(<span class="literal">true</span>);</span><br><span class="line">        setter2 = Expression.Lambda&lt;Action&lt;Bar, <span class="built_in">int</span>&gt;&gt;(</span><br><span class="line">            Expression.Call(barParam, setterMethod!, valueParam),</span><br><span class="line">            barParam, valueParam</span><br><span class="line">        ).Compile();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        setter2(bar, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次我们不需要缓存这个 methodInfo，而是编译成一个委托然后缓存该委托</p><p>同样跑一下基准测试</p><p><img src="/%E4%BD%BF%E7%94%A8CSharp%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91%E4%BC%98%E5%8C%96%E4%BB%A3%E7%A0%81/image-20250526014002834.png" alt="benchmark2"></p><blockquote><p>  表达式树编译后的委托是直接去调用目标方法的 IL 代码，性能几乎是接近直接调用的，避免动态调用开销，所以性能会远高于 MethodInfo.Invoke</p></blockquote>]]></content:encoded>
      
      
      <category domain="http://hacbit.tech/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/">游戏开发</category>
      
      
      <category domain="http://hacbit.tech/tags/CSharp/">CSharp</category>
      
      
      <comments>http://hacbit.tech/%E4%BD%BF%E7%94%A8CSharp%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91%E4%BC%98%E5%8C%96%E4%BB%A3%E7%A0%81/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>基于ValueDropdown拓展以支持自定义icon</title>
      <link>http://hacbit.tech/%E5%9F%BA%E4%BA%8EValueDropdown%E6%8B%93%E5%B1%95%E4%BB%A5%E6%94%AF%E6%8C%81%E8%87%AA%E5%AE%9A%E4%B9%89icon/</link>
      <guid>http://hacbit.tech/%E5%9F%BA%E4%BA%8EValueDropdown%E6%8B%93%E5%B1%95%E4%BB%A5%E6%94%AF%E6%8C%81%E8%87%AA%E5%AE%9A%E4%B9%89icon/</guid>
      <pubDate>Tue, 13 May 2025 13:56:12 GMT</pubDate>
      
      <description>&lt;p&gt;之前遇到过一个需求是要在下拉框的目录做一个标记来指示状态，应该很自然就可以想到能不能修改一下 icon，比如把文件夹的那个icon改成其他颜色的，这样会比修改显示名字毫无疑问更加显眼。&lt;/p&gt;
&lt;p&gt;不过其实想要进行更大限度的修改是完全可以的，只需要魔改一下 ValueDropdown 就行。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>之前遇到过一个需求是要在下拉框的目录做一个标记来指示状态，应该很自然就可以想到能不能修改一下 icon，比如把文件夹的那个icon改成其他颜色的，这样会比修改显示名字毫无疑问更加显眼。</p><p>不过其实想要进行更大限度的修改是完全可以的，只需要魔改一下 ValueDropdown 就行。</p><span id="more"></span><p>先说一下简单的解决先前提到的需求的办法吧——改显示名字。</p><p>一般是使用 <code>ValueDropdownList&lt;T&gt;</code> 或者 <code>IEnumerable&lt;ValueDropdownItem&lt;T&gt;&gt;</code>  (二者是等价的) 作为函数的返回值，比如：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">ShowInInspector, LabelText(<span class="string">&quot;测试下拉框&quot;</span>)</span>]</span><br><span class="line">[<span class="meta">ValueDropdown(nameof(GetAllowIndexs))</span>]</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> Index;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ValueDropdownList&lt;<span class="built_in">int</span>&gt; <span class="title">GetAllowIndexs</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> list = <span class="keyword">new</span> ValueDropdownList&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        list.Add(<span class="string">$&quot;The <span class="subst">&#123;i + <span class="number">1</span>&#125;</span> item&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下，可以给每个 value 都指定自定义的名字，不过更复杂的操作似乎就不行了（或者我没有找到？）</p><p><img src="/%E5%9F%BA%E4%BA%8EValueDropdown%E6%8B%93%E5%B1%95%E4%BB%A5%E6%94%AF%E6%8C%81%E8%87%AA%E5%AE%9A%E4%B9%89icon/image-20250513221635581.png" alt="测试下拉框"></p><h2 id="拓展-ValueDropdown"><a href="#拓展-ValueDropdown" class="headerlink" title="拓展 ValueDropdown"></a>拓展 ValueDropdown</h2><p>既然原本的 ValueDropdown 无法满足需求，那就自己搓一个吧，写一个类继承原来的 ValueDropdown 特性。</p><p>然后我们再原来的基础上，再添加一个回调字段</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> UNITY_EDITOR &amp;&amp; ODIN_INSPECTOR</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Diagnostics;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Sirenix.OdinInspector</span>;</span><br><span class="line"></span><br><span class="line">[<span class="meta">AttributeUsage(AttributeTargets.All, AllowMultiple = false, Inherited = true)</span>]</span><br><span class="line">[<span class="meta">Conditional(<span class="string">&quot;UNITY_EDITOR&quot;</span>)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CustomValueDropdownAttribute</span> : <span class="title">ValueDropdownAttribute</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> ItemAction;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomValueDropdownAttribute</span>(<span class="params"><span class="built_in">string</span> valueGetter, <span class="built_in">string</span> itemAction</span>)</span></span><br><span class="line"><span class="function">        : <span class="title">base</span>(<span class="params">valueGetter</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ItemAction = itemAction;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>然后自定义 attribute drawer</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Sirenix.OdinInspector.Editor.Drawers</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">CustomValueDropdownAttributeDrawer</span> : <span class="title">OdinAttributeDrawer</span>&lt;<span class="title">CustomValueDropdownAttribute</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单看一下 <code>ValueDropdownAttributeDrawer</code> 的实现，就会发现是基于 OdinMenuTree 做的，每一项其实都是一个 OdinMenuItem，所以不妨让我们的自定义的回调的参数是 OdinMenuItem，这样就可以实现更大限度的自定义每一项。</p><p>添加一个 ActionResolver 字段原来解析传入的方法名</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ActionResolver? itemAction;</span><br></pre></td></tr></table></figure><p>然后在初始化函数中添加解析逻辑，（也别忘了设置错误信息）</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">base</span>.Attribute.ItemAction <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    itemAction = ActionResolver.Get(</span><br><span class="line">        <span class="keyword">base</span>.Property,</span><br><span class="line">        <span class="keyword">base</span>.Attribute.ItemAction,</span><br><span class="line"><span class="keyword">new</span>[] &#123; <span class="keyword">new</span> ActionResolvers.NamedValue(<span class="string">&quot;item&quot;</span>, <span class="keyword">typeof</span>(OdinMenuItem)) &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">error = rawGetter.ErrorMessage ?? itemAction?.ErrorMessage;</span><br></pre></td></tr></table></figure><p>翻一下逻辑，会发现设置 icon 是通过 <code>AddThumbnailIcons(preferAssetPreviewAsIcon: true);</code> 调用。所以我们修改一下这部分的逻辑，当 itemAction 为空时，就继续走老逻辑，如果不为空，那就尝试调用解析的逻辑</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    genericSelector.SelectionTree.EnumerateTree(x =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        itemAction?.Context.NamedValues.Set(<span class="string">&quot;item&quot;</span>, x);</span><br><span class="line">        itemAction?.DoAction();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x.Icon == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            x.AddThumbnailIcon(preferAssetPreviewAsIcon: <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试效果"><a href="#测试效果" class="headerlink" title="测试效果"></a>测试效果</h2><p>在原来的测试代码那里添加一个函数</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">HandleItem</span>(<span class="params">OdinMenuItem item</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    item.Icon = EditorIcons.Flag.Active;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且修改字段的特性</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">CustomValueDropdown(nameof(GetAllowIndexs), nameof(HandleItem))</span>]</span><br></pre></td></tr></table></figure><p><img src="/%E5%9F%BA%E4%BA%8EValueDropdown%E6%8B%93%E5%B1%95%E4%BB%A5%E6%94%AF%E6%8C%81%E8%87%AA%E5%AE%9A%E4%B9%89icon/image-20250513231709716.png" alt="image-20250513231709716"></p>]]></content:encoded>
      
      
      <category domain="http://hacbit.tech/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/">游戏开发</category>
      
      
      <category domain="http://hacbit.tech/tags/Unity/">Unity</category>
      
      <category domain="http://hacbit.tech/tags/CSharp/">CSharp</category>
      
      <category domain="http://hacbit.tech/tags/Odin/">Odin</category>
      
      
      <comments>http://hacbit.tech/%E5%9F%BA%E4%BA%8EValueDropdown%E6%8B%93%E5%B1%95%E4%BB%A5%E6%94%AF%E6%8C%81%E8%87%AA%E5%AE%9A%E4%B9%89icon/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>春招笔试总结</title>
      <link>http://hacbit.tech/%E6%98%A5%E6%8B%9B%E7%AC%94%E8%AF%95%E6%80%BB%E7%BB%93/</link>
      <guid>http://hacbit.tech/%E6%98%A5%E6%8B%9B%E7%AC%94%E8%AF%95%E6%80%BB%E7%BB%93/</guid>
      <pubDate>Sat, 08 Mar 2025 05:38:06 GMT</pubDate>
      
      <description>&lt;p&gt;第一场笔试，后面做的懒得记录了&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>第一场笔试，后面做的懒得记录了</p><span id="more"></span><h3 id="加油站"><a href="#加油站" class="headerlink" title="加油站"></a>加油站</h3><p>leetcode 原题，不过我没有做到过：<a href="https://leetcode.cn/problems/gas-station/description/">https://leetcode.cn/problems/gas-station/description/</a></p><p>在一条环路上有 <code>n</code> 个加油站，其中第 <code>i</code> 个加油站有汽油 <code>gas[i]</code> 升。</p><p>你有一辆油箱容量无限的的汽车，从第 <code>i</code> 个加油站开往第 <code>i+1</code> 个加油站需要消耗汽油 <code>cost[i]</code> 升。你从其中的一个加油站出发，开始时油箱为空。</p><p>给定两个整数数组 <code>gas</code> 和 <code>cost</code> ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 <code>-1</code> 。如果存在解，则 <strong>保证</strong> 它是 <strong>唯一</strong> 的。</p><p><strong>示例 1:</strong></p><blockquote><p>输入: gas &#x3D; [1,2,3,4,5], cost &#x3D; [3,4,5,1,2]<br>输出: 3<br>解释:<br>从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 &#x3D; 0 + 4 &#x3D; 4 升汽油<br>开往 4 号加油站，此时油箱有 4 - 1 + 5 &#x3D; 8 升汽油<br>开往 0 号加油站，此时油箱有 8 - 2 + 1 &#x3D; 7 升汽油<br>开往 1 号加油站，此时油箱有 7 - 3 + 2 &#x3D; 6 升汽油<br>开往 2 号加油站，此时油箱有 6 - 4 + 3 &#x3D; 5 升汽油<br>开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。<br>因此，3 可为起始索引。</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p>输入: gas &#x3D; [2,3,4], cost &#x3D; [3,4,3]<br>输出: -1<br>解释:<br>你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。<br>我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 &#x3D; 0 + 4 &#x3D; 4 升汽油<br>开往 0 号加油站，此时油箱有 4 - 3 + 2 &#x3D; 3 升汽油<br>开往 1 号加油站，此时油箱有 3 - 3 + 3 &#x3D; 3 升汽油<br>你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。<br>因此，无论怎样，你都不可能绕环路行驶一周。</p></blockquote><h4 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h4><p>思路很简单，直接贪心，先两个数组做差，算出每个点到下一个点的油量变化，然后遍历数组，从第一个正值开始，依次累加，当累加变成负值就继续找下一个正值。</p><p>遍历完如果最后累加结果是负值，说明找不到，直接返回 -1，如果为正值，就考虑把开始计算的节点前的所有盈亏加起来（因为是要跑一个环形）和 0 比较即可</p><p>所以其实是找到一个位置，使得左边的和与右边（包括当前点）的和相加 &gt; 0，同时保证右边的子数组的前缀和不能有小于零的</p><blockquote><p>  做了两题发现可以用 C#，后面都是直接写 C# 了</p><p>  <strong>输入按照实际笔试中的来写</strong></p></blockquote><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="keyword">var</span> n = <span class="built_in">int</span>.Parse(Console.ReadLine());</span><br><span class="line">        <span class="keyword">var</span> gas = Console.ReadLine().Split().Select(<span class="built_in">int</span>.Parse);</span><br><span class="line">        <span class="keyword">var</span> cost = Console.ReadLine().Split().Select(<span class="built_in">int</span>.Parse);</span><br><span class="line">        <span class="keyword">var</span> sub = gas.Zip(cost, (g, c) =&gt; g - c).ToList();</span><br><span class="line">        <span class="keyword">var</span> start = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">var</span> leftSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">var</span> s = sub[i];</span><br><span class="line">            <span class="keyword">if</span> (s &gt;= <span class="number">0</span> &amp;&amp; start == <span class="number">-1</span>) &#123;</span><br><span class="line">                start = i;</span><br><span class="line">                leftSum += sum;</span><br><span class="line">                sum = s;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sum += s;</span><br><span class="line">                <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) start = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; start) leftSum += s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (leftSum + sum &lt; <span class="number">0</span>) start = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="other"><a href="#other" class="headerlink" title="other"></a>other</h3><p>第四题样例没有全部通过，思路还是贪心。</p><p>题目大意：</p><blockquote><p>  给出 a b c 并且构造一个 nums 数组，要求满足：</p><ul><li><p><code>nums.length = a</code></p></li><li><p><code>0 &lt;= a &lt;= c &lt;= 1e9</code></p></li><li><p><code>nums[i]</code> 是正整数（<code>0 &lt;= i &lt; a</code> ）</p></li><li><p><code>abs(nums[i] - nums[i+1]) &lt;= 1 (0 &lt;= i &lt; a - 1)</code></p></li><li><p><code>0 &lt;= b &lt; a</code></p></li><li><p>使得 <code>nums[b]</code> 最大</p></li><li><p><code>sum(nums) &lt;= c</code></p></li></ul><p>  最后返回 <code>nums[b]</code></p></blockquote><p>要找到符合全部要求的 nums，首先考虑极端情况，也就是从 b 位置开始，往两侧依次递减到 1，类似这种形状的数组 <code>[1, 1, 2, 3, 2]</code>， 在这种情况下，所有数值的和一定是最小的。</p><p>所以可以计算 x &#x3D; b 处的  y_b 的值的范围，从大到小遍历，依次构造相应的函数 f(x) 并且判断其积分 F(x) &lt;&#x3D; c，返回第一个符合题意的 y_b 即可。</p><p>实际做的时候因为计算面积导致数量级会达到 1e18，超过了 int 的上限。（下次一定记得换 long）</p><p>然后如果 c 远远大于 a，就会导致遍历很久，所以我们根据差值来逼近目标值。</p><p>一个可能的解法（本地测了一些样例， 不确定行不行）：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> abc = Console.ReadLine()!.Split().Select(<span class="built_in">long</span>.Parse).ToArray();</span><br><span class="line">    <span class="keyword">var</span> (a, b, c) = (abc[<span class="number">0</span>], abc[<span class="number">1</span>], abc[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">var</span> maxNumsB = c - a + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = maxNumsB; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> totalS = Calc(a, b, i);</span><br><span class="line">        <span class="keyword">if</span> (totalS &lt;= c)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// approaching the target based on the difference</span></span><br><span class="line">        <span class="keyword">var</span> delta = totalS - c;</span><br><span class="line">        i -= delta / (a + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">long</span> <span class="title">Calc</span>(<span class="params"><span class="built_in">long</span> a, <span class="built_in">long</span> b, <span class="built_in">long</span> y</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 0 &lt;= b &lt; a</span></span><br><span class="line">    <span class="comment">// calculate left triangle and right triangle (or trapezoid)</span></span><br><span class="line">    <span class="comment">// left is f(x) = x + r (y = b + r =&gt; r = y - b), so get f(x) = x + y - b</span></span><br><span class="line">    <span class="keyword">var</span> leftX = y - <span class="number">1</span> &gt; b ? <span class="number">0</span> : b - y + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> leftY = leftX + y - b;</span><br><span class="line">    <span class="comment">// right is f(x) = -x + r (y = -b + r =&gt; r = y + b), so get f(x) = -x + y + b</span></span><br><span class="line">    <span class="keyword">var</span> rightX = y + b &lt; a ? y - <span class="number">1</span> + b : a - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> rightY = -rightX + y + b;</span><br><span class="line">    <span class="comment">// S = (Y + y) * abs(b - X) / 2</span></span><br><span class="line">    <span class="comment">// and add rest of the area (always 1)</span></span><br><span class="line">    <span class="keyword">var</span> leftS = (leftY + y) * (b - leftX + <span class="number">1</span>) / <span class="number">2</span> + leftX;</span><br><span class="line">    <span class="keyword">var</span> rightS = (rightY + y) * (rightX - b + <span class="number">1</span>) / <span class="number">2</span> + (a - rightX - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">var</span> totalS = leftS + rightS - y;</span><br><span class="line">    <span class="comment">// Console.WriteLine($&quot;&#123;y&#125;: &#123;leftX&#125;, &#123;leftY&#125;, &#123;rightX&#125;, &#123;rightY&#125;, &#123;leftS&#125;, &#123;rightS&#125;, &#123;totalS&#125;&quot;);</span></span><br><span class="line">    <span class="keyword">return</span> totalS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://hacbit.tech/categories/%E6%9D%82%E8%AE%B0/">杂记</category>
      
      
      <category domain="http://hacbit.tech/tags/%E7%AE%97%E6%B3%95/">算法</category>
      
      
      <comments>http://hacbit.tech/%E6%98%A5%E6%8B%9B%E7%AC%94%E8%AF%95%E6%80%BB%E7%BB%93/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>浅谈CSharp与Rust的元编程机制</title>
      <link>http://hacbit.tech/%E6%B5%85%E8%B0%88CSharp%E4%B8%8ERust%E7%9A%84%E5%85%83%E7%BC%96%E7%A8%8B%E6%9C%BA%E5%88%B6/</link>
      <guid>http://hacbit.tech/%E6%B5%85%E8%B0%88CSharp%E4%B8%8ERust%E7%9A%84%E5%85%83%E7%BC%96%E7%A8%8B%E6%9C%BA%E5%88%B6/</guid>
      <pubDate>Wed, 05 Mar 2025 15:33:16 GMT</pubDate>
      
      <description>&lt;p&gt;大部分的语言或多或少提供了一些元编程机制，使得开发者能够对现有的语法语义进行拓展，能够极大的提高编程体验和开发效率。可能一提到元编程，大家很容易想到大名鼎鼎的 &lt;code&gt;Lisp&lt;/code&gt; 语言（你可能会说：“难道不是 Cpp？”，我又不会模板元编程，你让我讲啥 x）。得益于其本身接近语法树的语法，使得 Lisp 开发者可以很容易操作语法节点，甚至实现 “自己的 Lisp”，于是就才涌现了很多的 Lisp 方言。当然，本篇文章并不是为了讨论 Lisp，只是想要就 “元编程” 这一个角度，来谈谈 C# 和 Rust 语言各自的机制。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;  关于&lt;strong&gt;元编程&lt;/strong&gt;是什么，简单来说是用&lt;strong&gt;程序编写程序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  更详细的描述建议参考 wiki ： &lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%85%83%E7%BC%96%E7%A8%8B&quot;&gt;https://zh.wikipedia.org/wiki/%E5%85%83%E7%BC%96%E7%A8%8B&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>大部分的语言或多或少提供了一些元编程机制，使得开发者能够对现有的语法语义进行拓展，能够极大的提高编程体验和开发效率。可能一提到元编程，大家很容易想到大名鼎鼎的 <code>Lisp</code> 语言（你可能会说：“难道不是 Cpp？”，我又不会模板元编程，你让我讲啥 x）。得益于其本身接近语法树的语法，使得 Lisp 开发者可以很容易操作语法节点，甚至实现 “自己的 Lisp”，于是就才涌现了很多的 Lisp 方言。当然，本篇文章并不是为了讨论 Lisp，只是想要就 “元编程” 这一个角度，来谈谈 C# 和 Rust 语言各自的机制。</p><blockquote><p>  关于<strong>元编程</strong>是什么，简单来说是用<strong>程序编写程序</strong></p><p>  更详细的描述建议参考 wiki ： <a href="https://zh.wikipedia.org/wiki/%E5%85%83%E7%BC%96%E7%A8%8B">https://zh.wikipedia.org/wiki/%E5%85%83%E7%BC%96%E7%A8%8B</a></p></blockquote><span id="more"></span><h2 id="元编程概述"><a href="#元编程概述" class="headerlink" title="元编程概述"></a>元编程概述</h2><p>元编程一般有两种实现方式：一是通过使用内部暴露的 API 来直接处理语法节点，二是能够动态执行字符串表达式。</p><p>对于后者来说，典型的是 Python 的 <code>eval</code>  和 <code>exec</code> 函数，JS 中也有类似的功能。对于这类实现来说，固然十分方便，但是也会带来很严重的安全问题。如果对于外部用户来说，<code>eval</code> 这类的危险函数的输入是可控的，那么用户就可以传入一段精心构造的字符串来执行恶意命令导致可能的信息泄露、提权等安全问题。</p><p>所以我个人会更倾向于前者（虽然这往往意味着更加抽象的语法和更高的编写难度），比如 C# 和 Rust 便是如此。</p><p>在 C# 中，Roslyn 编译器提供了一系列 API （<code>Microsoft.CodeAnalysis.CSharp</code>）用于编写源生成器，源生成器会在编译时被调用，访问每个语法节点，然后根据你的实现去动态的生成代码给编译器（如果不开 emit，那么这些代码不会以实际的源文件形式出现在你的文件夹中）；而 Rust 则是提供了极其强大，堪比 Lisp 的宏系统。普通的函数宏会依据用户编写的规则去在编译期展开，过程宏则有点接近 C#，不过 Rust 并不提供直接遍历全局的语法节点，而只是限制在该宏的使用者本身。</p><h2 id="一些简单实践"><a href="#一些简单实践" class="headerlink" title="一些简单实践"></a>一些简单实践</h2><p>以下是关于 C# 和 Rust 元编程的简单实践，可以观察一下他们之间的差异。</p><blockquote><p>  以下代码并非是为了教学，只是从一些简单的示例来比较他们之间的差异性，以及讨论各自的优劣。</p><p>  关于代码的解释，会在后面一起分析</p></blockquote><h3 id="C-增量生成器（IncrementalGenerator）实践"><a href="#C-增量生成器（IncrementalGenerator）实践" class="headerlink" title="C# 增量生成器（IncrementalGenerator）实践"></a>C# 增量生成器（IncrementalGenerator）实践</h3><blockquote><p>  由于 C# 的<strong>源生成器</strong>每次都要遍历所有语法节点，十分影响性能，微软已经将其标记为<strong>弃用</strong>，取而代之的是新的增量生成器 API</p><p>  <strong>增量生成器</strong>中提供了多种管道进行分析，比如 <code>CompilationProvider</code> , <code>SyntaxProvider</code>, <code>AdditionalTextsProvider</code> 等等。相比于旧的 <code>ISourceGenerator</code> ，可以提供更细粒度的分析，接受的分析对象也不局限于源代码。</p></blockquote><p>首先需要新建一个 C# 库项目，我推荐目标框架是 netstandard2.0，使用的 <code>Microsoft.CodeAnalysis.CSharp</code> 版本为 <code>4.3.0</code> （这可以保证该源生成器能在大部分的项目中使用，甚至 Unity）</p><p>简单写一个小 demo：</p><p>对于该生成器，需要实现 <code>IIncrementalGenerator</code>  接口的 <code>Initialize</code> 方法。然后我们从语法节点的角度切入，比如我们需要给具有 <code>[Test]</code> Attribute 的 class 分部实现一个方法，那么就可以像下面这样。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> Microsoft.CodeAnalysis;</span><br><span class="line"><span class="keyword">using</span> Microsoft.CodeAnalysis.CSharp.Syntax;</span><br><span class="line"><span class="keyword">using</span> Microsoft.CodeAnalysis.Text;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Test.Analysis</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Generator(LanguageNames.CSharp)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">TestGenerator</span> : <span class="title">IIncrementalGenerator</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Initialize</span>(<span class="params">IncrementalGeneratorInitializationContext context</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> provider = context.SyntaxProvider</span><br><span class="line">                .CreateSyntaxProvider(</span><br><span class="line">                    (s, _) =&gt; s <span class="keyword">is</span> ClassDeclarationSyntax classDecl &amp;&amp; </span><br><span class="line">                        classDecl.AttributeLists</span><br><span class="line">                            .SelectMany(al =&gt; al.Attributes)</span><br><span class="line">                            .Any(a =&gt; a.Name.ToString() == <span class="string">&quot;Test&quot;</span>),</span><br><span class="line">                    (ctx, _) =&gt; ctx.Node <span class="keyword">as</span> ClassDeclarationSyntax</span><br><span class="line">                ).Collect();</span><br><span class="line"></span><br><span class="line">            context.RegisterSourceOutput(provider, (spc, source) =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">foreach</span> (<span class="keyword">var</span> @class <span class="keyword">in</span> source)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">var</span> namespaceName = @class.FirstAncestorOrSelf&lt;NamespaceDeclarationSyntax&gt;().Name.ToString();</span><br><span class="line">                    <span class="comment">// Add Test method to the class</span></span><br><span class="line">                    <span class="keyword">var</span> code = <span class="string">$@&quot;// &lt;auto-generated/&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">using System;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">namespace <span class="subst">&#123;namespaceName&#125;</span></span></span><br><span class="line"><span class="string">&#123;&#123;</span></span><br><span class="line"><span class="string">    public partial class <span class="subst">&#123;@<span class="keyword">class</span>.Identifier&#125;</span></span></span><br><span class="line"><span class="string">    &#123;&#123;</span></span><br><span class="line"><span class="string">        public void Test() =&gt; Console.WriteLine(&quot;&quot;Test&quot;&quot;);</span></span><br><span class="line"><span class="string">    &#125;&#125;</span></span><br><span class="line"><span class="string">&#125;&#125;&quot;</span>;</span><br><span class="line">                    spc.AddSource(<span class="string">$&quot;<span class="subst">&#123;@<span class="keyword">class</span>.Identifier&#125;</span>_Test.g.cs&quot;</span>, SourceText.From(code, Encoding.UTF8));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外在一个终端项目中引用该项目，我们需要定义一个 TestAttribute，然后在一个分部类上使用它，然后这个类就会自动实现 Test() 方法了。</p><blockquote><p>  说明:information_source: ： 由于测试项目使用的是 net9.0， 支持顶级表达式，所以可以不需要写静态 Main 函数。</p></blockquote><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="keyword">new</span> Test.TestClass();</span><br><span class="line">test.Test();</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Test</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">TestClass</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">AttributeUsage(AttributeTargets.Class, AllowMultiple = true, Inherited = true)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestAttribute</span> : <span class="title">Attribute</span> &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行一下就会发现正确输出了 <code>&quot;Test&quot;</code></p><h3 id="C-诊断分析器（DiagnosticAnalyzer）实践"><a href="#C-诊断分析器（DiagnosticAnalyzer）实践" class="headerlink" title="C# 诊断分析器（DiagnosticAnalyzer）实践"></a>C# 诊断分析器（DiagnosticAnalyzer）实践</h3><p>比如我希望 <code>[Test]</code> 所在的 class 是密封的，那么我可以创建一个诊断器来分析，当不是 sealed 时抛出一个错误。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span> disable RS2008</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> System.Collections.Immutable;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> Microsoft.CodeAnalysis;</span><br><span class="line"><span class="keyword">using</span> Microsoft.CodeAnalysis.CSharp;</span><br><span class="line"><span class="keyword">using</span> Microsoft.CodeAnalysis.CSharp.Syntax;</span><br><span class="line"><span class="keyword">using</span> Microsoft.CodeAnalysis.Diagnostics;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Test.Analysis</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">DiagnosticAnalyzer(LanguageNames.CSharp)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">TestAnalyzer</span> : <span class="title">DiagnosticAnalyzer</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">override</span> ImmutableArray&lt;DiagnosticDescriptor&gt; SupportedDiagnostics =&gt; ImmutableArray.Create(Rule);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> DiagnosticDescriptor Rule = <span class="keyword">new</span> DiagnosticDescriptor(</span><br><span class="line">            id: <span class="string">&quot;TEST001&quot;</span>,</span><br><span class="line">            title: <span class="string">&quot;Test class must be sealed&quot;</span>,</span><br><span class="line">            messageFormat: <span class="string">&quot;class &#x27;&#123;0&#125;&#x27; must be sealed&quot;</span>,</span><br><span class="line">            category: <span class="string">&quot;Test&quot;</span>,</span><br><span class="line">            defaultSeverity: DiagnosticSeverity.Error,</span><br><span class="line">            isEnabledByDefault: <span class="literal">true</span>,</span><br><span class="line">            description: <span class="string">&quot;Test class must be sealed.&quot;</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Initialize</span>(<span class="params">AnalysisContext context</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            context.ConfigureGeneratedCodeAnalysis(GeneratedCodeAnalysisFlags.Analyze | GeneratedCodeAnalysisFlags.ReportDiagnostics);</span><br><span class="line">            context.EnableConcurrentExecution();</span><br><span class="line">            context.RegisterSyntaxNodeAction(AnalyzeSyntax, SyntaxKind.ClassDeclaration);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">AnalyzeSyntax</span>(<span class="params">SyntaxNodeAnalysisContext context</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (context.Node <span class="keyword">is</span> <span class="keyword">not</span> ClassDeclarationSyntax classDecl) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> hasTestAttribute = classDecl.AttributeLists</span><br><span class="line">                .SelectMany(al =&gt; al.Attributes)</span><br><span class="line">                .Any(a =&gt; a.Name.ToString() == <span class="string">&quot;Test&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (hasTestAttribute == <span class="literal">false</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> isSealed = classDecl.Modifiers.Any(m =&gt; m.IsKind(SyntaxKind.SealedKeyword));</span><br><span class="line">            <span class="keyword">if</span> (isSealed == <span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                context.ReportDiagnostic(Diagnostic.Create(SupportedDiagnostics[<span class="number">0</span>], classDecl.GetLocation(), classDecl.Identifier.Text));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后回到测试项目尝试 build，就可以看到有条报错：<code>error TEST001: class &#39;TestClass&#39; must be sealed</code></p><h3 id="Rust-函数宏（声明宏）实践"><a href="#Rust-函数宏（声明宏）实践" class="headerlink" title="Rust 函数宏（声明宏）实践"></a>Rust 函数宏（声明宏）实践</h3><blockquote><p>  我使用的是新的宏声明方式，旧的方式是使用 <code>macro_rules!</code> 进行声明</p><p>  <code>#![feature(decl_macro)]</code> 需要使用 Rust 的 nightly 或 beta 版本 :warning:</p></blockquote><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![feature(decl_macro)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    macros::hello!(world);</span><br><span class="line">    macros::muti_hello!(world, rust, <span class="keyword">macro</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> macros &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">macro</span> <span class="title function_ invoke__">hello</span>($n:ident) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Hello, &#123;&#125;!&quot;</span>, <span class="built_in">stringify!</span>($n));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">macro</span> <span class="title function_ invoke__">muti_hello</span>($( $n:ident ),*$(,)?) &#123;</span><br><span class="line">        $(</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Hello, &#123;&#125;!&quot;</span>, <span class="built_in">stringify!</span>($n));</span><br><span class="line">        )*</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行一下观察输出：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Hello,</span> world!</span><br><span class="line"><span class="built_in">Hello,</span> world!</span><br><span class="line"><span class="built_in">Hello,</span> rust!</span><br><span class="line"><span class="built_in">Hello,</span> macro!</span><br></pre></td></tr></table></figure><h3 id="Rust-过程宏（proc-macro）实践"><a href="#Rust-过程宏（proc-macro）实践" class="headerlink" title="Rust 过程宏（proc-macro）实践"></a>Rust 过程宏（proc-macro）实践</h3><p>Rust 写过程宏类似于 C# 的增量生成器或诊断器，也是需要新建一个 Rust 项目，在新的过程宏项目中添加 quote, syn 依赖，然后简单写一个 Hello 特征的 derive</p><blockquote><p>  Rust trait （特征） 可以类比于其他语言的 interface（接口）</p></blockquote><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> proc_macro;</span><br><span class="line"><span class="keyword">use</span> proc_macro::TokenStream;</span><br><span class="line"><span class="keyword">use</span> quote::quote;</span><br><span class="line"><span class="keyword">use</span> syn::&#123;parse::Parse, parse_macro_input, DeriveInput, Token&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[proc_macro_derive(Hello)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">hello_derive</span>(input: TokenStream) <span class="punctuation">-&gt;</span> TokenStream &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">input</span> = parse_macro_input!(input <span class="keyword">as</span> DeriveInput);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">name</span> = &amp;input.ident;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">expanded</span> = quote! &#123;</span><br><span class="line">        <span class="keyword">impl</span> <span class="title class_">Hello</span> <span class="keyword">for</span> #name &#123;</span><br><span class="line">            <span class="keyword">fn</span> <span class="title function_">hello</span>() &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;Hello, &#123;&#125;!&quot;</span>, <span class="built_in">stringify!</span>(#name));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    expanded.<span class="title function_ invoke__">into</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SingleHelloInput</span> &#123;</span><br><span class="line">    from: syn::Ident,</span><br><span class="line">    to: syn::Ident,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HelloInput</span> &#123;</span><br><span class="line">    some_hellos: <span class="type">Vec</span>&lt;SingleHelloInput&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Parse</span> <span class="keyword">for</span> <span class="title class_">HelloInput</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">parse</span>(input: syn::parse::ParseStream) <span class="punctuation">-&gt;</span> syn::<span class="type">Result</span>&lt;<span class="keyword">Self</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">some_hellos</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        <span class="keyword">while</span> !input.<span class="title function_ invoke__">is_empty</span>() &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">from</span> = input.<span class="title function_ invoke__">parse</span>()?;</span><br><span class="line">            input.parse::&lt;Token![=&gt;]&gt;()</span><br><span class="line">                .<span class="title function_ invoke__">map_err</span>(|e| syn::Error::<span class="title function_ invoke__">new</span>(e.<span class="title function_ invoke__">span</span>(), <span class="string">&quot;Expected `=&gt;`&quot;</span>))?;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">to</span> = input.<span class="title function_ invoke__">parse</span>()?;</span><br><span class="line">            some_hellos.<span class="title function_ invoke__">push</span>(SingleHelloInput &#123; from, to &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(HelloInput &#123; some_hellos &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[proc_macro]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">say_hello</span>(input: TokenStream) <span class="punctuation">-&gt;</span> TokenStream &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">input</span> = parse_macro_input!(input <span class="keyword">as</span> HelloInput);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">hellos</span> = input.some_hellos.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">map</span>(|SingleHelloInput &#123; from, to &#125;| &#123;</span><br><span class="line">        quote! &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;say hello from &#123;&#125; to &#123;&#125;!&quot;</span>, <span class="built_in">stringify!</span>(#from), <span class="built_in">stringify!</span>(#to));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">expanded</span> = quote! &#123;</span><br><span class="line">        #(#hellos)*</span><br><span class="line">    &#125;;</span><br><span class="line">    expanded.<span class="title function_ invoke__">into</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把该项目添加到另一个项目的依赖，并测试宏的功能：</p><blockquote><p>  <code>hello_derive</code> 宏的功能是给目标实现 <code>Hello</code> 特征（当然，这得你自己定义），于是可以调用 <code>World::hello()</code> 方法</p><p>  注意:warning: ：此处不是静态方法，Rust 并不能直接在 struct 中定义静态方法（实际上也没有这个概念x），此处是由于 World 结构体没有任何成员，所以创建 World 实例可以直接简化成 <code>World</code> ，而不需要 <code>World &#123; &#125;</code></p><p>  <code>say_hello</code> 宏则是可以接受任意多组输入，每一组的格式必须是 <code>标识符 =&gt; 标识符</code> ，该宏的解析是自定义的。</p></blockquote><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> test_macro::&#123;Hello, say_hello&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    World::<span class="title function_ invoke__">hello</span>();</span><br><span class="line">    say_hello!(World =&gt; Rust);</span><br><span class="line">    say_hello! &#123;</span><br><span class="line">        Hacbit =&gt; Rust</span><br><span class="line">        Rust =&gt; Hacbit     My =&gt; ABAB</span><br><span class="line">            My =&gt; Anii</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Hello)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">World</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">hello</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Hello, World!</span><br><span class="line"><span class="built_in">say</span> hello <span class="keyword">from</span> World <span class="keyword">to</span> Rust!</span><br><span class="line"><span class="built_in">say</span> hello <span class="keyword">from</span> Hacbit <span class="keyword">to</span> Rust!</span><br><span class="line"><span class="built_in">say</span> hello <span class="keyword">from</span> Rust <span class="keyword">to</span> Hacbit!</span><br><span class="line"><span class="built_in">say</span> hello <span class="keyword">from</span> My <span class="keyword">to</span> ABAB!</span><br><span class="line"><span class="built_in">say</span> hello <span class="keyword">from</span> My <span class="keyword">to</span> Anii!</span><br></pre></td></tr></table></figure><h2 id="C-和Rust在元编程实现上的异同"><a href="#C-和Rust在元编程实现上的异同" class="headerlink" title="C#和Rust在元编程实现上的异同"></a>C#和Rust在元编程实现上的异同</h2><p>看了上面的几个示例，应该对两者的元编程机制有了一定的印象。</p><p>对于 C# 和 Rust 的相同的地方（虽然上面的例子可能没有很好的体现）：</p><ul><li>都是把源代码解析成 AST （抽象语法树），然后分析节点对象</li><li>需要额外引入库项目作为类似编译器插件的东西，以此实现在编译期对原有代码的功能进行拓展</li></ul><p>不过差异也十分显著：</p><ul><li>C# 提供多个管道（比如 <code>context.SyntaxProvider</code>）来访问各种节点（比如 <code>ClassDeclarationSyntax</code>）对象，生成器可以自定义筛选条件，并分析筛选出来的节点来生成相关拓展； Rust 则需要用户显示的去 “使用” 宏，比如 <code>#[derive(Hello)]</code> 就是直接指定了宏的使用目标，因而无需筛选。所以实际上，<strong>C# 在获取元信息的范围更广，Rust 只能获取目标的元信息，而无法得知目标以外的元信息。</strong></li><li>但是另一方面，<strong>受限于 C# 本身的语法，C# 无法提供更细粒度的指令流分析</strong>。而 Rust 在这方面就十分灵活，可以自定义 Token 流解析器，你可以把各种符号（允许的 Token）塞进的宏规则中，而无需在意语法（就像上面的 <code>say_hello!</code> 那样）。这意味着，<strong>在 Rust 中你可以定义自己语法。</strong></li></ul><p>无论是 C# 的生成器&#x2F;分析器，还是 Rust 的宏，其实核心区别无非就是作用范围的不同，一个是全局，一个是局部。而由这两点分歧，又很容易想到，C# 的元编程机制只能进行<strong>增量</strong>，是不能够修改原有代码的（因为生成器&#x2F;分析器是并行的，而元信息作为共享资源，自然不能随意修改）；Rust 的宏作用范围只有局部，每个宏之间是独立（或者包含），而不会产生交叉，因而可以<strong>随意修改原有逻辑</strong>。</p><p>不管具体实现如何，毫无疑问他们都是具有相当程度可定制化的，并且也能保证运行时性能和安全性。不同于反射、或者运行时动态执行字符串等运行时特性，他们本质上是<strong>将一部分运行时逻辑提前到编译期</strong>，因而减少运行时的性能损耗（当然，这也意味着你需要付出更长编译时间的代价 :laughing: ），也就是 Rust 中特别提倡的<strong>零成本抽象</strong>。同时，由于这些编译期特性只会在编译期产生作用，就不会有运行时特性那样潜在的注入漏洞等安全风险。（除非黑客能够控制你的编译管线 x :laughing: ）</p><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>有什么比较合适的使用场景呢？</p><p>按照我的经验可能往往是用来动态实现一些接口，函数之类的。不过这个应该更容易在 Rust 中实现（也十分自然），因为 Rust 的 <code>struct</code> 可以在任何地方去实现新功能，只需要定义一个新的 <code>trait</code> （如果是在该 <code>struct</code> 定义所在的模块之外）。而放在 C# 就有点麻烦，通常我们不得不需要强制用户使用 <code>partial</code> 关键字，并且也无法对一些内置的（或第三方库中的）类型进行更大限度的拓展，比如我们不能给 <code>int</code> 添加新的接口实现。</p><p>生成一些桥接代码可能是不错的选择，比如我们想要在 c 端和 s 端交换数据，那么肯定需要对两端的数据结构进行一个适配，这时候就可以根据配置动态生成；或者是想要和其他语言走 FFI，那么也可以通过元编程机制生成相关代码（比如 pyo3 项目对 Rust 和 Python 的 FFI 通信的处理）。</p><p>不过 C# 的诊断器确实是个很有意思的东西，天然适合写框架。毕竟可以全局检查你的代码，并且添加各种约束，以减少使用框架时的未定义行为，所以如果去翻各种第三方库，他们大多都会写一些 Analyzer 。Rust 的确做不了这块，原因如前文所述，Rust 不提供能够直接访问全局语法树的 API，不过 Rust 本身也有 rust-analyzer ，还可以配合 cargo-clippy，因此对于代码本身的检查也很严格就是了（）</p><h2 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h2><p>要我说的话，肯定是 Rust 的机制写的更爽（），毕竟可以自定义语法欸，超帅的吧！</p><p>Rust 独立开发的话，随便写点宏自娱自乐其实挺有趣的，之前也写过一些<del>奇奇怪怪的</del>功能，比如使用宏加载 json 文件自动生成 enum。（C# 当然也很容易实现）</p><p>由于我是 Rust 出身，代码风格极大程度受到了 Rust 设计哲学的影响，在使用 C# 的时候，说实话多次尝试将一些 Rust 特性在 C# 中实现（），不过确实有点麻烦，特别是我想要实现类似过程宏的东西时候遇到了很大的阻碍（一大理由就是 C# 不允许用户自己分析 TokenStream，使得不可能像 Rust 那样自由），我尝试的一个思路是使用字符串，然后我就自己设计语法（参考 Rust），搓了词法分析，语法分析。不过话说回来，这样就不像是 C#，固然人家 Lisp，Rust 可以设计自己的语法，但是他们都还是 Lisp，Rust，而 C# 既然本身设计哲学就是这样，强行改变写法只会显得抽象和丑陋。</p><p>当然 Rust 和 C# 都是极其优秀的语言，写工程确实舒服。<del>（叠个甲）</del></p><p>不知道看本篇文章的读者有没有玩过所学语言的元编程机制，如果本文给你打开了一扇新世界的大门<del>（大概不是深渊吧）</del>，将是我的荣幸。</p>]]></content:encoded>
      
      
      <category domain="http://hacbit.tech/categories/%E6%9D%82%E8%AE%B0/">杂记</category>
      
      
      <category domain="http://hacbit.tech/tags/Rust/">Rust</category>
      
      <category domain="http://hacbit.tech/tags/CSharp/">CSharp</category>
      
      
      <comments>http://hacbit.tech/%E6%B5%85%E8%B0%88CSharp%E4%B8%8ERust%E7%9A%84%E5%85%83%E7%BC%96%E7%A8%8B%E6%9C%BA%E5%88%B6/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>在Unity中解放高版本C#特性</title>
      <link>http://hacbit.tech/%E5%9C%A8Unity%E4%B8%AD%E8%A7%A3%E6%94%BE%E9%AB%98%E7%89%88%E6%9C%ACCS%E7%89%B9%E6%80%A7/</link>
      <guid>http://hacbit.tech/%E5%9C%A8Unity%E4%B8%AD%E8%A7%A3%E6%94%BE%E9%AB%98%E7%89%88%E6%9C%ACCS%E7%89%B9%E6%80%A7/</guid>
      <pubDate>Mon, 24 Feb 2025 14:10:35 GMT</pubDate>
      
      <description>&lt;p&gt;之前我在知乎问过相关问题，后面参考了几个知友的回答，借鉴了一些项目，也算是基本解决了这个问题&lt;/p&gt;
&lt;p&gt;也顺便附上我的知乎回答：&lt;a href=&quot;https://www.zhihu.com/question/11672499668/answer/103930816515&quot;&gt;https://www.zhihu.com/question/11672499668/answer/103930816515&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;以下是关于如何在 Unity 中使用&lt;strong&gt;更高版本的 C# 特性&lt;/strong&gt;的详细解决办法（&lt;strong&gt;具有一定局限性&lt;/strong&gt;）&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>之前我在知乎问过相关问题，后面参考了几个知友的回答，借鉴了一些项目，也算是基本解决了这个问题</p><p>也顺便附上我的知乎回答：<a href="https://www.zhihu.com/question/11672499668/answer/103930816515">https://www.zhihu.com/question/11672499668/answer/103930816515</a></p><p>以下是关于如何在 Unity 中使用<strong>更高版本的 C# 特性</strong>的详细解决办法（<strong>具有一定局限性</strong>）</p><span id="more"></span><h2 id="Comfirm-the-C-version-that-Unity-supports"><a href="#Comfirm-the-C-version-that-Unity-supports" class="headerlink" title="Comfirm the C# version that Unity supports"></a>Comfirm the C# version that Unity supports</h2><p>关于你的 unity editor <strong>本身能够支持</strong>到多高的 C# 版本，以我的 unity 2022.3.52f1c1 为例，去 unity editor 所在的目录下面这个路径，打开 README 里面有 dotnet sdk 版本</p><img src="/%E5%9C%A8Unity%E4%B8%AD%E8%A7%A3%E6%94%BE%E9%AB%98%E7%89%88%E6%9C%ACCS%E7%89%B9%E6%80%A7/dotnet_sdk.png" alt="dotnet_sdk" style="zoom: 67%;"><p>然后去官方搜索一下该版本的相关信息：</p><img src="/%E5%9C%A8Unity%E4%B8%AD%E8%A7%A3%E6%94%BE%E9%AB%98%E7%89%88%E6%9C%ACCS%E7%89%B9%E6%80%A7/sdk_search.png" alt="sdk_search" style="zoom: 67%;"><p>发现可以支持到 C#10，在这个版本中，C#处于可预览状态，如果是一般的 cs 项目（使用该 sdk），可以直接在 csproj 指定 <code>&lt;LangVersion&gt;preview&lt;/LangVersion&gt;</code>  来使用部分的 C#11 特性。</p><p>但是 Unity 中的所谓 C# 项目并不是这么一回事，项目根目录里面的一堆 .csproj 文件，只是 Unity 自动生成给 IDE 看的，这也是为什么用 Rider，VSCode 之类的 IDE 打开项目后能进行解析（）</p><h2 id="Unity-Compile"><a href="#Unity-Compile" class="headerlink" title="Unity Compile"></a>Unity Compile</h2><p>在<a href="https://docs.unity3d.com/2022.3/Documentation/Manual/CSharpCompiler.html">官方手册</a>里面有关于这个的说明：Unity editor 会指定默认的编译选项给后端的 Roslyn 编译器（也就是C#版本指定 9.0）</p><img src="/%E5%9C%A8Unity%E4%B8%AD%E8%A7%A3%E6%94%BE%E9%AB%98%E7%89%88%E6%9C%ACCS%E7%89%B9%E6%80%A7/compiler.png" alt="compiler" style="zoom:67%;"><p>不过后面也说明了可以传递别的参数（），于是可以在<a href="https://docs.unity3d.com/2022.3/Documentation/Manual/CustomScriptingSymbols.html">这篇文章</a>找到答案，用户可以在 Assets&#x2F; 目录下添加 csc.rsp 文件来指定编译参数，文档给的例子是在 .rsp 文件里通过 <code>-define:XXXX</code> 来定义宏，用以条件编译。</p><p>但是我们显然能玩点别的东西，比如指定 <code>-langversion</code> ，按照前文的思路，我们可以启用 C#11 的部分特性。</p><p>所以我们创建一个 <code>csc.rsp</code> 文件放在 <strong>Assets&#x2F; 目录</strong>下（<strong>或者你的程序集的同目录</strong>），写入以下内容：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-langversion:preview -<span class="literal">null</span>able</span><br></pre></td></tr></table></figure><p>这些指令是将语言版本<strong>设置为预览状态</strong>，然后<strong>启用nullable编译</strong></p><blockquote><p>  关于后者，你可以在代码中使用  ? 来声明一个类型<strong>可为 null</strong>，比如：</p>  <figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> Example</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span>? ValueInt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  如果不启用的 nullable，使用 ？ 会警告你 “需要在 #nullable 的上下文使用”。</p></blockquote><p>然后你可以在你的脚本里面使用 C#11 的特性，<strong>回到 UnityEditor 中</strong>看看能不能通过编译。以下是一段简单的测试代码：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> DefaultValue</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// set default value in struct field</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Value = <span class="number">114514</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> NonArgConstructor</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// struct constructor with no-args</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NonArgConstructor</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">Value = <span class="string">&quot;1145141919810&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你使用的较新的 unity 2022.3 （&gt;&#x3D; 2022.3.12f1）那么这段代码是可以通过编译的（当然你也可以整个 mono 类去创建这两个 struct 输出确认是否真的设置成了指定的默认值）</p><p>不过你在编写上述代码的时候，IDE 里面一定是一片爆红吧 :laughing: 。</p><p>不用担心，让 csproj 来救你（x</p><h2 id="Change-csproj-files"><a href="#Change-csproj-files" class="headerlink" title="Change .csproj files"></a>Change .csproj files</h2><p>在前面有说过，Unity 项目根目录的 .csproj 文件都是给 IDE 看的，你可以随便打开一个 .csproj 文件，里面应该很容易找到一行内容是：<code>&lt;LangVersion&gt;9.0&lt;/LangVersion&gt;</code></p><p>这会导致你的 IDE 会认为你的项目使用 C#9 ，所以前面编写 C#11 的代码的时候自然是会报错的啦（），你可以手动修改一下文件试试。</p><p>尝试将你的 <code>Assembly-CSharp.csproj</code>  文件里面的 langversion 那一行改成 <code>&lt;LangVersion&gt;preview&lt;/LangVersion&gt;</code></p><blockquote><p>  如果你使用程序集，比如有一个 <code>My.Test.asmdef</code> 的程序集，那么 UnityEditor 会自动给这个程序集生成一个 <code>My.Test.csproj</code> （当然也是在项目根目录），那么 IDE 对该程序集中的代码的解析，就会受到 <code>My.Test.csproj</code> 的影响，这时候需要去修改 <code>My.Test.csproj</code> 里面的 langversion 选项了（）</p></blockquote><p>回到你的 IDE 里面应该就不会报错了。</p><p>当然每次编译后，unity 都会重新生成一遍，所以建议写个脚本，读取 csproj， 然后修改相关的选项，然后可以监听 <code>compilationFinished</code> 事件自动执行。</p><h2 id="Some-lunatic-ideas-for-higher-version-P-S"><a href="#Some-lunatic-ideas-for-higher-version-P-S" class="headerlink" title="Some lunatic ideas for higher version (P.S.)"></a>Some lunatic ideas for higher version (P.S.)</h2><p>还有一些本人没有实践过的想法，有些已经被别人尝试过，有些不确定有没有人试过，感兴趣的可以玩玩 :laughing:</p><ul><li>开一个 C# 项目，目标框架设置 <code>&lt;TargetFramework&gt;netstandard2.1&lt;/TargetFramework&gt;</code>，然后语言版本设置 <code>&lt;TargetFramework&gt;latest&lt;/TargetFramework&gt;</code> ，应该能够使用到 C#12 甚至更高的特性，当然部分特性可能缺少预定义类，可以通过 PolySharp 来补充（），详情可以参考 R3 项目。</li><li>修改你的 Unity Editor 的 Roslyn 编译器依赖的 SDK 版本（？）（如果要尝试建议备份一下）</li></ul>]]></content:encoded>
      
      
      <category domain="http://hacbit.tech/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/">游戏开发</category>
      
      
      <category domain="http://hacbit.tech/tags/Unity/">Unity</category>
      
      <category domain="http://hacbit.tech/tags/Tutorial/">Tutorial</category>
      
      <category domain="http://hacbit.tech/tags/CSharp/">CSharp</category>
      
      
      <comments>http://hacbit.tech/%E5%9C%A8Unity%E4%B8%AD%E8%A7%A3%E6%94%BE%E9%AB%98%E7%89%88%E6%9C%ACCS%E7%89%B9%E6%80%A7/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>CSharp实现强制类型限定</title>
      <link>http://hacbit.tech/CSharp%E5%AE%9E%E7%8E%B0%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E9%99%90%E5%AE%9A/</link>
      <guid>http://hacbit.tech/CSharp%E5%AE%9E%E7%8E%B0%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E9%99%90%E5%AE%9A/</guid>
      <pubDate>Sat, 15 Feb 2025 05:43:43 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;CSharp-实现强制类型限定&quot;&gt;&lt;a href=&quot;#CSharp-实现强制类型限定&quot; class=&quot;headerlink&quot; title=&quot;CSharp 实现强制类型限定&quot;&gt;&lt;/a&gt;CSharp 实现强制类型限定&lt;/h1&gt;&lt;p&gt;之前偶然有些灵感，想着如果遇到了如下情景，需要此处的 object 只能是某种特定类型，比如实现了 &lt;code&gt;ITestInterface&lt;/code&gt; 这个接口，那么大概会写成下面这样。&lt;/p&gt;
&lt;figure class=&quot;highlight cs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Method&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;object&lt;/span&gt; obj&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (obj &lt;span class=&quot;keyword&quot;&gt;is&lt;/span&gt; ITestInterface target)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;这样做自然没啥问题，但是只有到运行时才知道 obj 的类型到底符不符合要求，那么能不能把&lt;strong&gt;检查提前到编译期&lt;/strong&gt;呢？也就是在编写代码的时候就能够很大程度避免使用不合要求的类型。&lt;/p&gt;
&lt;p&gt;对于 C# 来说，其实可以写一个诊断分析器来实现。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;  以下使用 Unity 2022.3 对应的环境&lt;/p&gt;
&lt;/blockquote&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="CSharp-实现强制类型限定"><a href="#CSharp-实现强制类型限定" class="headerlink" title="CSharp 实现强制类型限定"></a>CSharp 实现强制类型限定</h1><p>之前偶然有些灵感，想着如果遇到了如下情景，需要此处的 object 只能是某种特定类型，比如实现了 <code>ITestInterface</code> 这个接口，那么大概会写成下面这样。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Method</span>(<span class="params"><span class="built_in">object</span> obj</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">is</span> ITestInterface target)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做自然没啥问题，但是只有到运行时才知道 obj 的类型到底符不符合要求，那么能不能把<strong>检查提前到编译期</strong>呢？也就是在编写代码的时候就能够很大程度避免使用不合要求的类型。</p><p>对于 C# 来说，其实可以写一个诊断分析器来实现。</p><blockquote><p>  以下使用 Unity 2022.3 对应的环境</p></blockquote><span id="more"></span><h2 id="编写之前"><a href="#编写之前" class="headerlink" title="编写之前"></a>编写之前</h2><p>那么按照我的个人习惯。这里先定义一个 <code>TypeConstraintAttribute</code> ，要注意由于是给参数做一个限定，所以这里需要指定这个 attribute 的目标为 <code>Parameter</code> ，后面的两个一般都是设置 <code>false</code> 就行了。</p><blockquote><p>  这里 <code>AllowMultiple</code> 可以考虑设置成 true（也就是一个参数可以挂多个 <code>[TypeConstraint]</code> ），理由后面再说（</p></blockquote><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">AttributeUsage(AttributeTargets.Parameter, AllowMultiple = false, Inherited = false)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">TypeConstraintAttribute</span> : <span class="title">Attribute</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> Type[] Constraints &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TypeConstraintAttribute</span>(<span class="params"><span class="keyword">params</span> Type[] constraints</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Constraints = constraints;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是只定义 attr 自然是没啥用的，一般可能会经常配合反射，源生成器，分析器之类的来用。</p><blockquote><p>  根据 Unity 官方手册中的说明，对于 Unity2022.3 的 editor，使用的源生成器项目目标框架需要是 <code>netstandard2.0</code> ，然后依赖的 <code>Microsoft.CodeAnalysis.CSharp</code> 需要是 <code>3.8.0</code> 版本</p></blockquote><p>所以去另外创建一个新项目：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dotnet new classlib <span class="literal">-n</span> Analysis <span class="operator">-f</span> netstandard2.<span class="number">0</span></span><br><span class="line"><span class="built_in">cd</span> Analysis</span><br><span class="line">dotnet add package Microsoft.CodeAnalysis.CSharp <span class="literal">--version</span> <span class="number">3.8</span>.<span class="number">0</span></span><br></pre></td></tr></table></figure><p>然后顺便打开 <code>Analysis.csproj</code> 把语言版本设置成 <code>9.0</code> （要不然默认就只有 <code>C#7.3</code> ）</p><p>现在配置文件里面应该大概是这样的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Project</span> <span class="attr">Sdk</span>=<span class="string">&quot;Microsoft.NET.Sdk&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TargetFramework</span>&gt;</span>netstandard2.0<span class="tag">&lt;/<span class="name">TargetFramework</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">LangVersion</span>&gt;</span>9.0<span class="tag">&lt;/<span class="name">LangVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">PropertyGroup</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">ItemGroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">PackageReference</span> <span class="attr">Include</span>=<span class="string">&quot;Microsoft.CodeAnalysis.CSharp&quot;</span> <span class="attr">Version</span>=<span class="string">&quot;3.8.0&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ItemGroup</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">Project</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="编写分析器"><a href="#编写分析器" class="headerlink" title="编写分析器"></a>编写分析器</h2><p>在项目文件夹中新建一个 <code>TypeConstraintAnalyzer.cs</code> ，然后在就是诊断器的起手式（x</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">Analysis</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">DiagnosticAnalyzer(LanguageNames.CSharp)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">TypeConstraintAnalyzer</span> : <span class="title">DiagnosticAnalyzer</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">override</span> ImmutableArray&lt;DiagnosticDescriptor&gt; SupportedDiagnostics =&gt; <span class="keyword">throw</span> <span class="keyword">new</span> NotImplement();</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Initialize</span>(<span class="params">AnalysisContext context</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            context.ConfigureGeneratedCodeAnalysis(GeneratedCodeAnalysisFlags.None);</span><br><span class="line">            context.EnableConcurrentExecution();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SupportedDiagnostics</code> 可以先不管，然后就是注册一些行为，一般可能注册符号行为或者语法节点行为（）</p><p>对于我们要实现对类型的限定，那么第一步就是先解析<strong>函数定义</strong>处，其参数上的 <code>[TypeConstraint(...)]</code> 中的提供的那些限定类型。这意味我们需要把解析到的相关信息储存，然后第二步解析函数调用时根据先前的信息类判断是否符合限定。</p><h3 id="分析-Attribute"><a href="#分析-Attribute" class="headerlink" title="分析 Attribute"></a>分析 Attribute</h3><p>定义一个 <code>AnalyzeSymbol</code> ，并注册：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Initialize</span>(<span class="params">AnalysisContext context</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// SymbolKind.Method 表示 AnalyzeSymbol 会用来分析函数的符号信息</span></span><br><span class="line">    context.RegisterSymbolAction(AnalyzeSymbol, SymbolKind.Method);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AnalyzeSymbol</span>(<span class="params">SymbolAnalysisContext context</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就是检查参数是否有 <code>TypeConstraintAttribute</code> 之类的，最后把对应的参数信息储存，这里我们可以定义一个字段来储存</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> Dictionary&lt;IMethodSymbol, Dictionary&lt;IParameterSymbol, ImmutableHashSet&lt;INamedTypeSymbol&gt;&gt;&gt; MethodConstraints = <span class="keyword">new</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AnalyzeSymbol</span>(<span class="params">SymbolAnalysisContext context</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (context.Symbol <span class="keyword">is</span> <span class="keyword">not</span> IMethodSymbol methodSymbol) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (methodSymbol.Parameters.Length <span class="keyword">is</span> <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> parametersConstraints = <span class="keyword">new</span> Dictionary&lt;IParameterSymbol, ImmutableHashSet&lt;INamedTypeSymbol&gt;&gt;();</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> parameter <span class="keyword">in</span> methodSymbol.Parameters)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// check if the parameter have TypeConstraintAttribute</span></span><br><span class="line">        <span class="comment">// 这里有点忘了，&quot;TypeConstraintAttribute&quot; 不行的话就改成 &quot;TypeConstraint&quot; 吧</span></span><br><span class="line">        <span class="keyword">var</span> attrs = parameter.GetAttributes().Where(attr =&gt; attr.AttributeClass.Name == <span class="string">&quot;TypeConstraintAttribute&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (attrs.Any() <span class="keyword">is</span> <span class="literal">false</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> typeConstraintAttr = attrs.First();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Correctly handle the type of ConstructorArguments</span></span><br><span class="line">        <span class="keyword">var</span> allowedTypes = typeConstraintAttr.ConstructorArguments</span><br><span class="line">            .SelectMany(arg =&gt; arg.Values)</span><br><span class="line">            .Select(arg =&gt; arg.Value <span class="keyword">as</span> INamedTypeSymbol)</span><br><span class="line">            .Where(type =&gt; type <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span>)</span><br><span class="line">            .ToImmutableHashSet();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (allowedTypes.Any() <span class="keyword">is</span> <span class="literal">false</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        parametersConstraints.Add(parameter, allowedTypes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (parametersConstraints.Any())</span><br><span class="line">    &#123;</span><br><span class="line">        MethodConstraints[methodSymbol] = parametersConstraints;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>  如果想要测试有没有正确去解析，可以打一些 log 到文件里面（如果要方便点建议使用绝对路径吧）</p></blockquote><p>这里的直接储存到字段会给你一个警告：<em>不要将每次编译的数据存储到诊断分析器的字段中</em></p><p>如果懒得去优化的话，就直接在文件开头添加一行 <code>#pragma warning disable RS1008</code>  就行。</p><p>顺便说明一下上面的 <code>allowedTypes</code> 吧：</p><blockquote><p>  在 roslyn 分析器中不能直接去获取一个 Attribute 内部的字段信息，一般是从构造函数来获取信息。</p><p>  在先前我们定义的 attr 时候是这样的：</p>  <figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TypeConstraintAttribute</span>(<span class="params"><span class="keyword">params</span> Type[] constraints</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Constraints = constraints;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  也就是 constraints 参数是一个 Type[] ，虽然使用的时候可以像是任意数量参数那样，但是解析符号的时候这里是一个参数，所以就需要先 SelectMany 再 Select ，如果直接 <code>typeConstraintAttr.ConstructorArguments.Select(...)</code>  就会异常，具体的表现就是在别的项目里使用该分析器的时候会没有任何表现（因为分析器运行到这里就崩溃了）</p></blockquote><h3 id="分析调用"><a href="#分析调用" class="headerlink" title="分析调用"></a>分析调用</h3><p>注册一个新的行为，这次我们注册到 <code>SyntaxNodeAction</code> （因为这个是在 <code>SymbolAction</code> 之后执行的，不过我猜这一步注册 <code>SymbolAction</code> 应该没啥问题）</p><p>然后分析的目标是调用表达式（<code>Invocation Expression</code>）</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Initialize</span>(<span class="params">AnalysisContext context</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    context.RegisterSyntaxNodeAction(AnalyzeMethodCall, SyntaxKind.InvocationExpression);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AnalyzeMethodCall</span>(<span class="params">SyntaxNodeAnalysisContext context</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断被调用的函数是不是有 <code>[TypeConstraint(...)]</code> 限定过的函数（也就是检查是不是在之前储存的那个字典就行），并获取调用时的实参，以及定义时的参数信息</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">AnalyzeMethodCall</span>(<span class="params">SyntaxNodeAnalysisContext context</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> invocation = (InvocationExpressionSyntax)context.Node;</span><br><span class="line">    <span class="keyword">if</span> (context.SemanticModel.GetSymbolInfo(invocation).Symbol <span class="keyword">is</span> <span class="keyword">not</span> IMethodSymbol methodSymbol</span><br><span class="line">        || MethodConstraints.ContainsKey(methodSymbol) <span class="keyword">is</span> <span class="literal">false</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> parametersConstraints = MethodConstraints[methodSymbol];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> arguments = invocation.ArgumentList.Arguments;</span><br><span class="line">    <span class="keyword">var</span> parameters = methodSymbol.Parameters;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后遍历参数，并判断是否满足限制，这里需要注意 arg 和 param 要对应上</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> (argument, parameter) <span class="keyword">in</span> arguments.Zip(parameters, (arg, param) =&gt; (arg, param)))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> argumentType = context.SemanticModel.GetTypeInfo(argument.Expression).Type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (parametersConstraints.TryGetValue(parameter, <span class="keyword">out</span> <span class="keyword">var</span> allowedTypes))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> isValid = allowedTypes.Any(allowed =&gt;</span><br><span class="line">            SymbolEqualityComparer.Default.Equals(allowed, argumentType) ||</span><br><span class="line">            argumentType.AllInterfaces.Any(i =&gt; SymbolEqualityComparer.Default.Equals(i, allowed)) ||</span><br><span class="line">            (argumentType.BaseType != <span class="literal">null</span> &amp;&amp; SymbolEqualityComparer.Default.Equals(argumentType.BaseType, allowed)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后就是根据实参是否合法，来抛出提示就行了。我们定义一个新的规则，比如这样：</p><blockquote><p>  这里应该也会有一个警告，懒得搞也是在文件开头加一行： <code>#pragma warning disable RS2008</code></p><p>  也可以按照官方的说明：<a href="https://github.com/dotnet/roslyn-analyzers/blob/main/src/Microsoft.CodeAnalysis.Analyzers/ReleaseTrackingAnalyzers.Help.md">https://github.com/dotnet/roslyn-analyzers/blob/main/src/Microsoft.CodeAnalysis.Analyzers/ReleaseTrackingAnalyzers.Help.md</a></p><p>  创建 <code>AnalyzerReleases.Unshipped.md</code> 和 <code>AnalyzerReleases.Shipped.md</code> 两个文件，并且按照格式把规则信息补充（</p></blockquote><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> DiagnosticDescriptor Rule = <span class="keyword">new</span> DiagnosticDescriptor(</span><br><span class="line">    id: <span class="string">&quot;ANALY001&quot;</span>,</span><br><span class="line">    title: <span class="string">&quot;无效的参数类型&quot;</span>,</span><br><span class="line">    messageFormat: <span class="string">&quot;参数类型 &#x27;&#123;0&#125;&#x27; 不满足 TypeConstraintAttribute 中的约束条件, 类型 &#x27;&#123;0&#125;&#x27; 需要为 &#x27;&#123;1&#125;&#x27; 中的一种, 或派生于其中之一。&quot;</span>,</span><br><span class="line">    category: <span class="string">&quot;Usage&quot;</span>,</span><br><span class="line">    defaultSeverity: DiagnosticSeverity.Error,</span><br><span class="line">    isEnabledByDefault: <span class="literal">true</span>,</span><br><span class="line">    description: <span class="string">&quot;参数类型不满足 TypeConstraintAttribute 中的约束条件&quot;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">override</span> ImmutableArray&lt;DiagnosticDescriptor&gt; SupportedDiagnostics =&gt; ImmutableArray.Create(Rule);</span><br></pre></td></tr></table></figure><p>然后在原来检测的地方获取上下文并抛出错误</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isValid <span class="keyword">is</span> <span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> diagnostic = Diagnostic.Create(Rule, argument.GetLocation(), argumentType, <span class="built_in">string</span>.Join(<span class="string">&quot;, &quot;</span>, allowedTypes.Select(type =&gt; type.Name)));</span><br><span class="line">    context.ReportDiagnostic(diagnostic);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在-Unity-中使用分析器"><a href="#在-Unity-中使用分析器" class="headerlink" title="在 Unity 中使用分析器"></a>在 Unity 中使用分析器</h2><p>把项目 build 一下，把 dll 文件按照 Unity 官方手册的说明 <a href="https://docs.unity3d.com/cn/2022.3/Manual/roslyn-analyzers.html">https://docs.unity3d.com/cn/2022.3/Manual/roslyn-analyzers.html</a> 应用到项目中，之后就可以测试了。</p><blockquote><p>  在前面的实现中，我由于是判断只有满足多个限制中的一个就行，所以多个类型之间其实是 <code>or</code> 的关系。</p><p>  在最开始我说定义 <code>TypeConstraintAttribute</code> 的时候，可以把 <code>AllowMultiple</code> 设置为 true，这样的话就可以考虑多个 <code>[TypeConstraint(...)]</code> 之间是 <code>and</code> 关系，这里我就不实现了（</p></blockquote><p><img src="/CSharp%E5%AE%9E%E7%8E%B0%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E9%99%90%E5%AE%9A/Test.png" alt="Test"></p>]]></content:encoded>
      
      
      <category domain="http://hacbit.tech/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/">游戏开发</category>
      
      
      <category domain="http://hacbit.tech/tags/Tutorial/">Tutorial</category>
      
      <category domain="http://hacbit.tech/tags/CSharp/">CSharp</category>
      
      <category domain="http://hacbit.tech/tags/Analysis/">Analysis</category>
      
      
      <comments>http://hacbit.tech/CSharp%E5%AE%9E%E7%8E%B0%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E9%99%90%E5%AE%9A/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Unity 项目文档生成</title>
      <link>http://hacbit.tech/Unity-%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3%E7%94%9F%E6%88%90/</link>
      <guid>http://hacbit.tech/Unity-%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3%E7%94%9F%E6%88%90/</guid>
      <pubDate>Sat, 08 Feb 2025 09:06:38 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;Unity-项目文档生成&quot;&gt;&lt;a href=&quot;#Unity-项目文档生成&quot; class=&quot;headerlink&quot; title=&quot;Unity 项目文档生成&quot;&gt;&lt;/a&gt;Unity 项目文档生成&lt;/h1&gt;&lt;p&gt;对于 C# 项目来说，可以使用 docfx 这个开源工具来生成代码文档，这个工具也同样能用在 Unity 的项目中。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="Unity-项目文档生成"><a href="#Unity-项目文档生成" class="headerlink" title="Unity 项目文档生成"></a>Unity 项目文档生成</h1><p>对于 C# 项目来说，可以使用 docfx 这个开源工具来生成代码文档，这个工具也同样能用在 Unity 的项目中。</p><span id="more"></span><p>以我的 KimerA 框架的项目结构为例吧：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">KimerA</span><br><span class="line">├─Docs</span><br><span class="line">└─Src</span><br><span class="line">    ├─KimerA</span><br><span class="line">    │  ├─<span class="string">.vscode</span></span><br><span class="line">    │  ├─Assets</span><br><span class="line"><span class="string">......</span></span><br></pre></td></tr></table></figure><p>其中 <strong>KimerA&#x2F;Src&#x2F;KimerA</strong> 就是 unity 项目的根目录。</p><blockquote><p>  首先保证至少有 DotNet8 的环境</p><p>  运行 <code>dotnet tool update -g docfx</code> 来全局安装 docfx 工具</p></blockquote><p><em>关于 docfx 的入门，建议直接看官方的  <a href="https://dotnet.github.io/docfx/index.html">https://dotnet.github.io/docfx/index.html</a></em></p><p>在 <strong>KimerA&#x2F;Docs</strong> 打开一个终端，输入 <code>docfx init</code> 初始化相关设置</p><p>然后应该就看到了 Docs 文件夹下多了 <code>docfx.json, index.md, toc.yml</code>  这三个文件</p><blockquote><p>  启动 docfx 服务后的主界面就是根据 index.md 来的</p><p>  toc.yml （Table of Config），就和名字一样，是指示文档结构的</p><p>  docfx.json 就是生成文档时的相关配置</p></blockquote><p>docfx.json 中 metadata -&gt; src 应该默认是指向一个 .csproj 路径，但是对于 unity 项目，建议改成 .cs 文件的路径</p><p>下面是一个示例的 docfx.json 文件内容，（当然，由于我是为了打包成 unitypackage 我才放到 Plugins 下面，如果只是要给项目核心逻辑的哪些脚本生成文档，大可改成类似  <code>TestProj/Assets/Scripts/*.cs</code> ,  <code>TestProj/Assets/Scripts/**/*.cs</code> 这样的）</p><blockquote><p>  需要解释一下为什么在 metadata 中会添加一个   <code>&quot;references&quot;: [ &quot;*.dll&quot; ]</code></p><p>  因为我依赖了 UnityEngine，所以当 docfx 尝试 build 的时候（生成文档前会先build）就会缺少依赖，我的做法是直接去编辑器文件夹下面复制了一个 UnityEngine.dll （不知道有没有更好的办法）</p><p>  然后 “references” 字段需要的是模式，可以填  “UnityEngine.dll”, “*.dll”，但是不能 “.&#x2F;UnityEngine.dll”</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;metadata&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;src&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;files&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="string">&quot;KimerA/Assets/Plugins/KimerA/Runtime/**/*.cs&quot;</span></span><br><span class="line">          <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;src&quot;</span><span class="punctuation">:</span> <span class="string">&quot;../Src&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;dest&quot;</span><span class="punctuation">:</span> <span class="string">&quot;api&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;disableGitFeatures&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;disableDefaultFilter&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;references&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;*.dll&quot;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;globalMetadata&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;_disableContribution&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;_appTitle&quot;</span><span class="punctuation">:</span> <span class="string">&quot;KimerA&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;files&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">          <span class="string">&quot;api/**.yml&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="string">&quot;api/index.md&quot;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;files&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">          <span class="string">&quot;articles/**.md&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="string">&quot;articles/**/toc.yml&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="string">&quot;toc.yml&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="string">&quot;*.md&quot;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;resource&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;files&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">          <span class="string">&quot;images/**&quot;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;overwrite&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;files&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">          <span class="string">&quot;apidoc/**.md&quot;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;exclude&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">          <span class="string">&quot;obj/**&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="string">&quot;_site/**&quot;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;dest&quot;</span><span class="punctuation">:</span> <span class="string">&quot;_site&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;globalMetadataFiles&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;fileMetadataFiles&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;template&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="string">&quot;default&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;modern&quot;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;postProcessors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;markdownEngineName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;markdig&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;noLangKeyword&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;keepFileLink&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;cleanupCacheHistory&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>toc.yml</strong></p><blockquote><p>  生成的 yml 文件名是根据命名空间来的，我希望一打开就是 <code>KimerA.Core</code> 这个命名空间内的东西，那么 homepage 就这么写（</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">KimerA</span> <span class="string">API</span> <span class="string">Documentation</span></span><br><span class="line">  <span class="attr">href:</span> <span class="string">api/</span></span><br><span class="line">  <span class="attr">homepage:</span> <span class="string">api/KimerA.Core.yml</span></span><br></pre></td></tr></table></figure><p>然后 index.md 里面随便写点东西，就可以直接 <code>docfx .\docfx.json --serve</code> 了</p><img src="/Unity-%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3%E7%94%9F%E6%88%90/Home.png" alt="Home" style="zoom:67%;"><p>点上方按钮进去就是大概这样</p><img src="/Unity-%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3%E7%94%9F%E6%88%90/Core.png" alt="Core" style="zoom: 67%;"><h2 id="一些可能的问题"><a href="#一些可能的问题" class="headerlink" title="一些可能的问题"></a>一些可能的问题</h2><ul><li><p>使用了 unsafe 代码，无法直接编译</p><blockquote><p>  可以在 docfx.json 中的 metadata 中添加 <code>&quot;properties&quot;: &#123; &quot;AllowUnsafeBlocks&quot;: &quot;true&quot; &#125;</code></p><p>  但是要注意， properties 中的属性的值都必须是 String 类型，这里填  true 会无法解析（x</p></blockquote></li><li><p>最近使用的时候遇到了 UnityEngine.dll 中缺少符号的问题，大概是 UnityEngine.dll 还会依赖其他的 dll，所以我直接把 editor 里面的 <code>Data/Managed/UnityEngine/</code> 这个目录一起复制过去了，然后把配置文件里面的 references 改成 <code>&quot;UnityEngine/*.dll&quot;</code> 就可以了。</p></li></ul>]]></content:encoded>
      
      
      <category domain="http://hacbit.tech/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/">游戏开发</category>
      
      
      <category domain="http://hacbit.tech/tags/Unity/">Unity</category>
      
      <category domain="http://hacbit.tech/tags/Tutorial/">Tutorial</category>
      
      
      <comments>http://hacbit.tech/Unity-%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3%E7%94%9F%E6%88%90/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>rust宏魔法-2</title>
      <link>http://hacbit.tech/rust%E5%AE%8F%E9%AD%94%E6%B3%95-2/</link>
      <guid>http://hacbit.tech/rust%E5%AE%8F%E9%AD%94%E6%B3%95-2/</guid>
      <pubDate>Mon, 26 Aug 2024 14:31:29 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;Rust宏魔法——第二辑（&quot;&gt;&lt;a href=&quot;#Rust宏魔法——第二辑（&quot; class=&quot;headerlink&quot; title=&quot;Rust宏魔法——第二辑（&quot;&gt;&lt;/a&gt;Rust宏魔法——第二辑（&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;  又来整点奇技淫巧了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这期就玩玩用声明宏来生成宏（&lt;/p&gt;
&lt;p&gt;总结可以直接看 👉 &lt;a href=&quot;#%E7%9C%81%E6%B5%81&quot;&gt;省流&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;假设有以下的奇怪情景：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;  你整了一个日志系统，但是其中的输出内容是预设好的（当然也应该预留一个比如 Other 的来自定义内容）&lt;/p&gt;
&lt;p&gt;  然后你想要给每一种输出内容都注册一个宏，并且有些输出是带有 “{}” 的，因此你希望能够有类似下面这个效果：&lt;/p&gt;
  &lt;figure class=&quot;highlight rust&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;app_start_failed!(e)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// App start failed due to the error : &amp;#123;e&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;  也就是像 &lt;code&gt;println!&lt;/code&gt; 之类的宏能够接受不定数量的参数，具体看格式（也就是你预设字符串里面有几个 “{}” )&lt;/p&gt;
&lt;/blockquote&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="Rust宏魔法——第二辑（"><a href="#Rust宏魔法——第二辑（" class="headerlink" title="Rust宏魔法——第二辑（"></a>Rust宏魔法——第二辑（</h1><blockquote><p>  又来整点奇技淫巧了</p></blockquote><p>这期就玩玩用声明宏来生成宏（</p><p>总结可以直接看 👉 <a href="#%E7%9C%81%E6%B5%81">省流</a></p><p>假设有以下的奇怪情景：</p><blockquote><p>  你整了一个日志系统，但是其中的输出内容是预设好的（当然也应该预留一个比如 Other 的来自定义内容）</p><p>  然后你想要给每一种输出内容都注册一个宏，并且有些输出是带有 “{}” 的，因此你希望能够有类似下面这个效果：</p>  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app_start_failed!(e)</span><br><span class="line"><span class="comment">// App start failed due to the error : &#123;e&#125;</span></span><br></pre></td></tr></table></figure><p>  也就是像 <code>println!</code> 之类的宏能够接受不定数量的参数，具体看格式（也就是你预设字符串里面有几个 “{}” )</p></blockquote><span id="more"></span><p>为了方便演示，就以以下作为例子吧</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app_started : <span class="string">&quot;App start!&quot;</span></span><br><span class="line">app_start_failed : <span class="string">&quot;App start failed due to the error: &#123;&#125;&quot;</span></span><br></pre></td></tr></table></figure><p>如果只是考虑上面这种，应该很容易写成这样：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> generate_macros &#123;</span><br><span class="line">    ( $( $id:ident =&gt; $e:expr ),*$(,)? ) =&gt; &#123;</span><br><span class="line">        $(</span><br><span class="line">            <span class="meta">#[macro_export]</span></span><br><span class="line">            <span class="built_in">macro_rules!</span> $id &#123;</span><br><span class="line">                () =&gt; &#123;</span><br><span class="line">                    <span class="built_in">println!</span>($e);</span><br><span class="line">    &#125;;</span><br><span class="line">                ($tt:tt) =&gt; &#123;</span><br><span class="line">                    <span class="built_in">println!</span>($e, $tt);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        )*</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">generate_macros! &#123;</span><br><span class="line">    app_started =&gt; <span class="string">&quot;App start!&quot;</span>,</span><br><span class="line">    app_start_failed =&gt; <span class="string">&quot;App start failed due to the error: &#123;&#125;&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    app_started!();</span><br><span class="line">    app_start_failed!(<span class="string">&quot;AAAAAAA&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样自然能够正常运行，但是也不难发现问题，就是如果增加了一个有两个 “{}” 的字段，那就不得不给 generate_macros 里面新增一个规则。</p><p>当然，对于 macro 烂熟于心的你，肯定想到可以把这个里面的匹配模式统一成  <code>$($tt:tt)*</code> ，也就是类似下面这种：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> generate_macros &#123;</span><br><span class="line">    ( $( $id:ident =&gt; $e:expr ),*$(,)? ) =&gt; &#123;</span><br><span class="line">        $(</span><br><span class="line">            <span class="meta">#[macro_export]</span></span><br><span class="line">            <span class="built_in">macro_rules!</span> $id &#123;</span><br><span class="line">                ($($tt:tt)*) =&gt; &#123;</span><br><span class="line">                    <span class="built_in">println!</span>($e, $tt);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        )*</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接自信运行！</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">error: attempted to repeat an expression containing no syntax variables matched as repeating at this depth</span><br><span class="line"> <span class="literal">--</span>&gt; src/main.rs:<span class="number">9</span>:<span class="number">19</span></span><br><span class="line">  |</span><br><span class="line"><span class="number">9</span> |                 (<span class="variable">$</span>(<span class="variable">$tt:tt</span>)*) =&gt; &#123;</span><br><span class="line">  |                   ^^^^^^^</span><br></pre></td></tr></table></figure><p>报错了，悲（</p><p>这个原因主要是像 <code>$( #[macro_export] xxxxx )*</code> 这样，被递归展开了，但是在 <code>macro_rules! $id &#123;&#125;</code> 中这么写，就不知道什么时候结束，因为 <code>$tt</code> 也是没有在 <code>macro_rules! generate_macros</code> 中声明（</p><p>但是这里如果是通过 <code>proc-macro</code> 包上一层就可以正确解析了</p><p>新建一个 <code>proc-macro</code> 类型的crate，写上以下代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> proc_macro;</span><br><span class="line"><span class="keyword">use</span> proc_macro::TokenStream;</span><br><span class="line"><span class="keyword">use</span> quote::quote;</span><br><span class="line"><span class="keyword">use</span> syn::&#123;parse_macro_input, parse::&#123;Parse, ParseBuffer&#125;, Token, Ident, LitStr&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MacroInfo</span> &#123;</span><br><span class="line">    id: Ident,</span><br><span class="line">    msg: LitStr,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Parse</span> <span class="keyword">for</span> <span class="title class_">MacroInfo</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">parse</span>(input: &amp;ParseBuffer) <span class="punctuation">-&gt;</span> syn::<span class="type">Result</span>&lt;<span class="keyword">Self</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">id</span> = input.parse::&lt;Ident&gt;()?;</span><br><span class="line">        input.parse::&lt;Token![=&gt;]&gt;()?;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">msg</span> = input.parse::&lt;LitStr&gt;()?;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(<span class="keyword">Self</span> &#123; id, msg &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[proc_macro]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">make_macro</span>(input: TokenStream) <span class="punctuation">-&gt;</span> TokenStream &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">input</span> = parse_macro_input!(input <span class="keyword">as</span> MacroInfo);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">id</span> = &amp;input.id;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">msg</span> = &amp;input.msg;</span><br><span class="line">    </span><br><span class="line">    quote! &#123;</span><br><span class="line">        <span class="built_in">macro_rules!</span> #id &#123;</span><br><span class="line">            ($($tt:tt)*) =&gt; &#123;</span><br><span class="line">                <span class="built_in">println!</span>(#msg, $($tt)*);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.<span class="title function_ invoke__">into</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后 <code>generate_macros</code> 这边替换一下就好了</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> generate_macros &#123;</span><br><span class="line">    ( $( $id:ident =&gt; $e:expr ),*$(,)? ) =&gt; &#123;</span><br><span class="line">        $(</span><br><span class="line">            make_macro! &#123;</span><br><span class="line">                $id =&gt; $e</span><br><span class="line">            &#125;</span><br><span class="line">        )*</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用示范：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">generate_macros! &#123;</span><br><span class="line">    hello =&gt; <span class="string">&quot;Hello, &#123;&#125;!&quot;</span>,</span><br><span class="line">    goodbye =&gt; <span class="string">&quot;Goodbye, &#123;&#125;!&quot;</span>,</span><br><span class="line">    hhh =&gt; <span class="string">&quot;hhh, &#123;&#125; and &#123;&#125;!&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    hello!(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">    goodbye!(<span class="string">&quot;world&quot;</span>); </span><br><span class="line">    hhh!(<span class="string">&quot;world&quot;</span>, <span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此，写任意格式的字符串就不需要在 generate_macros 那里添加新的匹配模式了。</p><h2 id="省流"><a href="#省流" class="headerlink" title="省流"></a>省流</h2><p>为了避免在 macro_rules 中定义 macro_rules 时错误的解析内层声明宏的 <code>$( xxx )*</code> 这一类模式，需要把这部分移动到 <code>proc-macro</code> 中。</p>]]></content:encoded>
      
      
      <category domain="http://hacbit.tech/categories/%E5%BC%80%E5%8F%91/">开发</category>
      
      
      <category domain="http://hacbit.tech/tags/Rust/">Rust</category>
      
      
      <comments>http://hacbit.tech/rust%E5%AE%8F%E9%AD%94%E6%B3%95-2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>rust宏魔法(1)</title>
      <link>http://hacbit.tech/rust%E5%AE%8F%E9%AD%94%E6%B3%95-1/</link>
      <guid>http://hacbit.tech/rust%E5%AE%8F%E9%AD%94%E6%B3%95-1/</guid>
      <pubDate>Wed, 17 Apr 2024 00:29:14 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;Rust宏魔法——第一辑（不知道后面还会不会更新，总之这是个系列）&quot;&gt;&lt;a href=&quot;#Rust宏魔法——第一辑（不知道后面还会不会更新，总之这是个系列）&quot; class=&quot;headerlink&quot; title=&quot;Rust宏魔法——第一辑（不知道后面还会不会更新，总之这是个系列）&quot;&gt;&lt;/a&gt;Rust宏魔法——第一辑（不知道后面还会不会更新，总之这是个系列）&lt;/h1&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;注：本文默认你已经有一定的Rust基础&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;rust的宏的强大相信大家肯定听的不少，本篇就简单说说rust的过程宏&lt;/p&gt;
&lt;p&gt;rust的宏有好几种，有基于模式匹配的，还有可以直接对语法树动手的，过程宏就是可以修改语法树，可以在编译器派生代码：比如有个test crate，然后它依赖于test_macro crate，而后者是一个proc-macro库，也就是里面定义了过程宏，编译时就会先编译test_macro然后用test_macro的对test的语法解析流修改再丢给编译器，所以可以实现很多非常抽象的操作。&lt;/p&gt;
&lt;p&gt;写本文的契机是，前段时间在Rust中文社区群里看到有人问能不能用宏把json生成一个enum（json只有一层），这个需求和过程宏还是很契合的，所以就简单实现了一下，以下内容就是对实现的讲解&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="Rust宏魔法——第一辑（不知道后面还会不会更新，总之这是个系列）"><a href="#Rust宏魔法——第一辑（不知道后面还会不会更新，总之这是个系列）" class="headerlink" title="Rust宏魔法——第一辑（不知道后面还会不会更新，总之这是个系列）"></a>Rust宏魔法——第一辑（不知道后面还会不会更新，总之这是个系列）</h1><p><em><strong>注：本文默认你已经有一定的Rust基础</strong></em></p><p>rust的宏的强大相信大家肯定听的不少，本篇就简单说说rust的过程宏</p><p>rust的宏有好几种，有基于模式匹配的，还有可以直接对语法树动手的，过程宏就是可以修改语法树，可以在编译器派生代码：比如有个test crate，然后它依赖于test_macro crate，而后者是一个proc-macro库，也就是里面定义了过程宏，编译时就会先编译test_macro然后用test_macro的对test的语法解析流修改再丢给编译器，所以可以实现很多非常抽象的操作。</p><p>写本文的契机是，前段时间在Rust中文社区群里看到有人问能不能用宏把json生成一个enum（json只有一层），这个需求和过程宏还是很契合的，所以就简单实现了一下，以下内容就是对实现的讲解</p><span id="more"></span><p>首先开个crate吧</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo new json_to_enum</span><br></pre></td></tr></table></figure><blockquote><p>  直到撰写本文时，想要定义过程宏还是必须要单独开个crate，并且在<code>cargo.toml</code>里面设置 <code>lib.proc-macro = true</code></p><p>  至于原因是rust的编译单元是crate，而前面也说要拿过程宏的库编译好对其他库使用的，所以就不可避免要分割，单独开个crate。</p></blockquote><p>然后创建过程宏库，这里我一般喜欢把依赖的其他自己写的库放在src下</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> src</span><br><span class="line">cargo new <span class="literal">--lib</span> json_to_enum_macro</span><br><span class="line"><span class="built_in">cd</span> ..</span><br></pre></td></tr></table></figure><p>然后创建一个json文件用于测试，内容比如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.json</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;app_name_not_set&quot;</span><span class="punctuation">:</span> <span class="string">&quot;应用名称未设置&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;app_name_too_long&quot;</span><span class="punctuation">:</span> <span class="string">&quot;应用名称过长&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;app_name_invalid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;应用名称无效&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;app_name_already_exists&quot;</span><span class="punctuation">:</span> <span class="string">&quot;应用名称已存在&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>现在的文件结构应该是：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├─src</span><br><span class="line">│  ├─main.rs</span><br><span class="line">│  └─json_to_enum_macro</span><br><span class="line">│      └─src</span><br><span class="line">│   └─lib.rs</span><br><span class="line">└─test.json</span><br></pre></td></tr></table></figure><p>emm，先展示一下调用的效果吧</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> json_to_enum_macro::json_to_enum;</span><br><span class="line"></span><br><span class="line">json_to_enum! &#123;</span><br><span class="line">    <span class="meta">#[from_json(<span class="string">&quot;test.json&quot;</span>)]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Test</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">4</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">t</span> = <span class="keyword">unsafe</span> &#123; std::mem::transmute::&lt;<span class="type">u8</span>, Test&gt;(i) &#125;;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125; &#123;&#125;&quot;</span>, t, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">AppNameAlreadyExists &quot;应用名称已存在&quot;</span></span><br><span class="line"><span class="comment">AppNameInvalid &quot;应用名称无效&quot;</span></span><br><span class="line"><span class="comment">AppNameNotSet &quot;应用名称未设置&quot;</span></span><br><span class="line"><span class="comment">AppNameTooLong &quot;应用名称过长&quot;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><code>json_to_enum</code>宏里面的匹配规则是一看到这个需求时的想法，所以别问我为什么要这样写（）</p><p>里面塞一个空的enum也是方便指定这个解析出的enum的名字而已，最终的效果是会替换掉enum的内容，所以里面写什么内容都没有用</p><p>好了，现在开始正式编写！</p><h2 id="开始编写你的proc-macro"><a href="#开始编写你的proc-macro" class="headerlink" title="开始编写你的proc-macro"></a>开始编写你的proc-macro</h2><p>先在json_to_enum_macro的<code>cargo.toml</code>里面设置 <code>lib.proc-macro = true</code></p><p>然后导入proc-macro的依赖 quote，syn，以及用于解析json文件的serde_json库</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo add quote syn serde_json</span><br></pre></td></tr></table></figure><p>现在文件应该是这样</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;json_to_enum_macro&quot;</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line"><span class="attr">edition</span> = <span class="string">&quot;2021&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[lib]</span></span><br><span class="line"><span class="attr">proc-macro</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">quote</span> = <span class="string">&quot;1.0.36&quot;</span></span><br><span class="line"><span class="attr">serde_json</span> = <span class="string">&quot;1.0.116&quot;</span></span><br><span class="line"><span class="attr">syn</span> = <span class="string">&quot;2.0.59&quot;</span></span><br></pre></td></tr></table></figure><p>把这个库添加到json_to_enum的依赖</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[workspace]</span></span><br><span class="line"><span class="attr">members</span> = [</span><br><span class="line">    <span class="string">&quot;src/json_to_enum_macro&quot;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;json_to_enum&quot;</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line"><span class="attr">edition</span> = <span class="string">&quot;2021&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies.json_to_enum_macro]</span></span><br><span class="line"><span class="attr">path</span> = <span class="string">&quot;src/json_to_enum_macro&quot;</span></span><br></pre></td></tr></table></figure><p>接下来rust-analyser就会一起解析你的macro库了</p><p>打开<code>lib.rs</code>文件导入依赖</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> proc_macro;</span><br><span class="line"><span class="keyword">use</span> proc_macro::&#123;Span, TokenStream&#125;;</span><br><span class="line"><span class="keyword">use</span> quote::quote;</span><br><span class="line"><span class="keyword">use</span> syn::&#123;parse_macro_input, DeriveInput, Ident, Lit&#125;;</span><br></pre></td></tr></table></figure><p>一般来说基本都会用上这几个：<code>proc_macro::TokenStream, quote::quote, syn::&#123;parse_macro_input, DeriveInput&#125;</code></p><p>proc macro也有好几种，比如 <code>proc_macro_derive</code> 可以给enum，struct啥的实现某个特征， 使用方法比如： <code>#[derive(Debug)] struct DebugStruct;</code>， 比如 <code>proc_macro_attribute</code> 可以扩展函数，enum字段等的功能。</p><p>而这里由于我们连enum都要派生，上面说的两者都要依托于某个对象，所以我们这里也就采用<code>proc_macro</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[proc_macro]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">json_to_enum</span>(input: TokenStream) <span class="punctuation">-&gt;</span> TokenStream &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">input</span> = parse_macro_input!(input <span class="keyword">as</span> DeriveInput);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">gen</span> = quote! &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br><span class="line">    gen.<span class="title function_ invoke__">into</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们要先解析一个attribute，得到json文件的路径，比如这个attribute是 <code>#[from_json(&quot;test.json&quot;)]</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于可以有很多个attribute，所以这里返回的是一个Vec</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">attribute</span> = &amp;input.attrs;</span><br><span class="line"><span class="comment">// 解析出attr里提供的json文件路径</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">json_name</span> = attribute</span><br><span class="line">.<span class="title function_ invoke__">iter</span>()</span><br><span class="line">.<span class="title function_ invoke__">find_map</span>(|attr| &#123;</span><br><span class="line">        <span class="keyword">if</span> attr.<span class="title function_ invoke__">path</span>().<span class="title function_ invoke__">is_ident</span>(<span class="string">&quot;from_json&quot;</span>) &#123;</span><br><span class="line">            <span class="comment">// 尝试把attr解析成字面量(literal)</span></span><br><span class="line">            <span class="keyword">let</span> <span class="variable">lit</span> = <span class="keyword">match</span> attr.parse_args::&lt;Lit&gt;() &#123;</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(lit) =&gt; lit,</span><br><span class="line">                <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, e),</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Lit</span>::<span class="title function_ invoke__">Str</span>(lit) = lit &#123;</span><br><span class="line">                <span class="title function_ invoke__">Some</span>(lit.<span class="title function_ invoke__">value</span>())</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="literal">None</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="literal">None</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"><span class="comment">// 读取文件内容</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">json_content</span> = std::fs::<span class="title function_ invoke__">read_to_string</span>(json_name).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;file not found&quot;</span>);</span><br><span class="line"><span class="comment">// 解析文件内容</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">json</span>: serde_json::Value = serde_json::<span class="title function_ invoke__">from_str</span>(&amp;json_content).<span class="title function_ invoke__">expect</span>(<span class="string">&quot;json parse error&quot;</span>);</span><br></pre></td></tr></table></figure><p>然后获取你传入的enum的名字（标识符），和json的keys就可以派生enum了</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">name</span> = &amp;input.ident;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">variants</span> = json</span><br><span class="line">    .<span class="title function_ invoke__">as_object</span>()</span><br><span class="line">    .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;json should be object&quot;</span>)</span><br><span class="line">    .<span class="title function_ invoke__">keys</span>()</span><br><span class="line">    .<span class="title function_ invoke__">map</span>(|k| &#123;</span><br><span class="line">        <span class="comment">// json里面是snake命名，转成驼峰式命名</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">ident</span> = Ident::<span class="title function_ invoke__">new</span>(&amp;<span class="title function_ invoke__">snake_to_camel</span>(k), Span::<span class="title function_ invoke__">call_site</span>().<span class="title function_ invoke__">into</span>());</span><br><span class="line">        quote! &#123;</span><br><span class="line">            #ident,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>这时候就可以像这样派生一个enum</p><p>是不是感觉和写<code>macro_rules!</code>很像呢</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">quote! &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">enum</span> #name &#123;</span><br><span class="line">        *(#variants)*</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后还要实现一下Display，需求说的是要json字段对应的值（也就是那些中文），这也显然只要获取json的values即可</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">msgs</span> = json.<span class="title function_ invoke__">as_object</span>().<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">values</span>().<span class="title function_ invoke__">map</span>(|v| &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">msg</span> = v.<span class="title function_ invoke__">as_str</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;value should be string&quot;</span>);</span><br><span class="line">        quote! &#123;</span><br><span class="line">            #msg</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>后面实现Display，（我也顺便实现了Debug）也就跟上面一样</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">std</span>::fmt::Display <span class="keyword">for</span> #name &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> std::fmt::Formatter) <span class="punctuation">-&gt;</span> std::fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            #(</span><br><span class="line">                #name::#keys =&gt; <span class="built_in">write!</span>(f, <span class="string">&quot;&#123;&#125;&quot;</span>, <span class="built_in">stringify!</span>(#msgs)),</span><br><span class="line">            )*</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里就已经完成了，如果你不知道后面这部分怎么弄就好好理解一下前面的代码，我故意没有全都写出来（）</p><p>实现完后记得测试一下</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> json_to_enum_macro::json_to_enum;</span><br><span class="line"></span><br><span class="line">json_to_enum! &#123;</span><br><span class="line">    <span class="meta">#[from_json(<span class="string">&quot;test.json&quot;</span>)]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Test</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Test::AppNameNotSet;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(a.<span class="title function_ invoke__">to_string</span>(), <span class="string">&quot;应用名称未设置&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>能正常跑就基本没啥问题了，还担心就展开看看</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo expand</span><br></pre></td></tr></table></figure><p>展开结果：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![feature(prelude_import)]</span></span><br><span class="line"><span class="meta">#[prelude_import]</span></span><br><span class="line"><span class="keyword">use</span> std::prelude::rust_2021::*;</span><br><span class="line"><span class="meta">#[macro_use]</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> std;</span><br><span class="line"><span class="keyword">use</span> parser_macro::json_to_enum;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">enum</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    AppNameAlreadyExists,</span><br><span class="line">    AppNameInvalid,</span><br><span class="line">    AppNameNotSet,</span><br><span class="line">    AppNameTooLong,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">std</span>::fmt::Display <span class="keyword">for</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> std::fmt::Formatter) <span class="punctuation">-&gt;</span> std::fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            Test::AppNameAlreadyExists =&gt; &#123;</span><br><span class="line">                f.<span class="title function_ invoke__">write_fmt</span>(</span><br><span class="line">                    <span class="built_in">format_args!</span>(</span><br><span class="line">                        <span class="string">&quot;&#123;0&#125;&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;\&quot;\u&#123;5e94&#125;\u&#123;7528&#125;\u&#123;540d&#125;\u&#123;79f0&#125;\u&#123;5df2&#125;\u&#123;5b58&#125;\u&#123;5728&#125;\&quot;&quot;</span>,</span><br><span class="line">                    ),</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">            Test::AppNameInvalid =&gt; &#123;</span><br><span class="line">                f.<span class="title function_ invoke__">write_fmt</span>(</span><br><span class="line">                    <span class="built_in">format_args!</span>(</span><br><span class="line">                        <span class="string">&quot;&#123;0&#125;&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;\&quot;\u&#123;5e94&#125;\u&#123;7528&#125;\u&#123;540d&#125;\u&#123;79f0&#125;\u&#123;65e0&#125;\u&#123;6548&#125;\&quot;&quot;</span>,</span><br><span class="line">                    ),</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">            Test::AppNameNotSet =&gt; &#123;</span><br><span class="line">                f.<span class="title function_ invoke__">write_fmt</span>(</span><br><span class="line">                    <span class="built_in">format_args!</span>(</span><br><span class="line">                        <span class="string">&quot;&#123;0&#125;&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;\&quot;\u&#123;5e94&#125;\u&#123;7528&#125;\u&#123;540d&#125;\u&#123;79f0&#125;\u&#123;672a&#125;\u&#123;8bbe&#125;\u&#123;7f6e&#125;\&quot;&quot;</span>,</span><br><span class="line">                    ),</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">            Test::AppNameTooLong =&gt; &#123;</span><br><span class="line">                f.<span class="title function_ invoke__">write_fmt</span>(</span><br><span class="line">                    <span class="built_in">format_args!</span>(</span><br><span class="line">                        <span class="string">&quot;&#123;0&#125;&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;\&quot;\u&#123;5e94&#125;\u&#123;7528&#125;\u&#123;540d&#125;\u&#123;79f0&#125;\u&#123;8fc7&#125;\u&#123;957f&#125;\&quot;&quot;</span>,</span><br><span class="line">                    ),</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">std</span>::fmt::<span class="built_in">Debug</span> <span class="keyword">for</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> std::fmt::Formatter) <span class="punctuation">-&gt;</span> std::fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            Test::AppNameAlreadyExists =&gt; &#123;</span><br><span class="line">                f.<span class="title function_ invoke__">write_fmt</span>(<span class="built_in">format_args!</span>(<span class="string">&quot;&#123;0&#125;&quot;</span>, <span class="string">&quot;AppNameAlreadyExists&quot;</span>))</span><br><span class="line">            &#125;</span><br><span class="line">            Test::AppNameInvalid =&gt; f.<span class="title function_ invoke__">write_fmt</span>(<span class="built_in">format_args!</span>(<span class="string">&quot;&#123;0&#125;&quot;</span>, <span class="string">&quot;AppNameInvalid&quot;</span>)),</span><br><span class="line">            Test::AppNameNotSet =&gt; f.<span class="title function_ invoke__">write_fmt</span>(<span class="built_in">format_args!</span>(<span class="string">&quot;&#123;0&#125;&quot;</span>, <span class="string">&quot;AppNameNotSet&quot;</span>)),</span><br><span class="line">            Test::AppNameTooLong =&gt; f.<span class="title function_ invoke__">write_fmt</span>(<span class="built_in">format_args!</span>(<span class="string">&quot;&#123;0&#125;&quot;</span>, <span class="string">&quot;AppNameTooLong&quot;</span>)),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = Test::AppNameNotSet;</span><br><span class="line">    <span class="title function_ invoke__">match</span> (&amp;a.<span class="title function_ invoke__">to_string</span>(), &amp;<span class="string">&quot;应用名称未设置&quot;</span>) &#123;</span><br><span class="line">        (left_val, right_val) =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> !(*left_val == *right_val) &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">kind</span> = ::core::panicking::AssertKind::<span class="built_in">Eq</span>;</span><br><span class="line">                ::core::panicking::<span class="title function_ invoke__">assert_failed</span>(</span><br><span class="line">                    kind,</span><br><span class="line">                    &amp;*left_val,</span><br><span class="line">                    &amp;*right_val,</span><br><span class="line">                    ::core::option::<span class="type">Option</span>::<span class="literal">None</span>,</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://hacbit.tech/categories/%E5%BC%80%E5%8F%91/">开发</category>
      
      
      <category domain="http://hacbit.tech/tags/Rust/">Rust</category>
      
      
      <comments>http://hacbit.tech/rust%E5%AE%8F%E9%AD%94%E6%B3%95-1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>idapython入门</title>
      <link>http://hacbit.tech/idapython%E5%85%A5%E9%97%A8/</link>
      <guid>http://hacbit.tech/idapython%E5%85%A5%E9%97%A8/</guid>
      <pubDate>Fri, 23 Feb 2024 13:15:03 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;IDA-Python入门（todo）&quot;&gt;&lt;a href=&quot;#IDA-Python入门（todo）&quot; class=&quot;headerlink&quot; title=&quot;IDA Python入门（todo）&quot;&gt;&lt;/a&gt;IDA Python入门（todo）&lt;/h1&gt;&lt;p&gt;ida pro7.7已经基本普及了，所以本篇文章是基于ida pro77和python3环境编写。&lt;/p&gt;
&lt;p&gt;不可否认的是ida pro在静态分析上极为强大，不过动调方面还是比起其他工具稍显不足，而idapython提供了大量的ida的api，能一定程度上缓解动调的缺陷，这里就给大家简单介绍一下（&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;PS：参考了Q神的 &lt;a href=&quot;http://www.qfrost.com/posts/ctf/idapython&quot;&gt;http://www.qfrost.com/posts/ctf/idapython&lt;/a&gt; ，并且修正为了新版ida python的api&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="IDA-Python入门（todo）"><a href="#IDA-Python入门（todo）" class="headerlink" title="IDA Python入门（todo）"></a>IDA Python入门（todo）</h1><p>ida pro7.7已经基本普及了，所以本篇文章是基于ida pro77和python3环境编写。</p><p>不可否认的是ida pro在静态分析上极为强大，不过动调方面还是比起其他工具稍显不足，而idapython提供了大量的ida的api，能一定程度上缓解动调的缺陷，这里就给大家简单介绍一下（</p><p><em><strong>PS：参考了Q神的 <a href="http://www.qfrost.com/posts/ctf/idapython">http://www.qfrost.com/posts/ctf/idapython</a> ，并且修正为了新版ida python的api</strong></em></p><span id="more"></span><p><img src="/idapython%E5%85%A5%E9%97%A8/image-20240223213616667.png" alt="image-20240223213616667"></p><p><img src="/idapython%E5%85%A5%E9%97%A8/image-20240223221902702.png" alt="image-20240223221902702"></p><p><strong>指令相关：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> idaapi <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ida_dbg <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ida_bytes <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># 返回目标地址指向的指令的前一条指令的地址</span></span><br><span class="line"><span class="comment"># 参数一是查找的开始地址，参数二是往前查找的最小地址（在范围内）</span></span><br><span class="line">prev_1 = prev_head(<span class="number">0x00007FF6A1AA2577</span>, <span class="number">1</span>)</span><br><span class="line">prev_2 = prev_head(<span class="number">0x00007FF6A1AA257a</span>, <span class="number">0x00007FF6A1AA2578</span>)<span class="comment"># fail</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(prev_1), <span class="built_in">hex</span>(prev_2))</span><br><span class="line">&gt;&gt; <span class="number">0x7ff6a1aa2573</span> <span class="number">0xffffffffffffffff</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回目标地址指向的指令的后一条指令的地址</span></span><br><span class="line"><span class="comment"># 参数一是查找开始地址，参数二是往后查找的最大地址（不在范围内）</span></span><br><span class="line">next_1 = next_head(<span class="number">0x00007FF6A1AA257a</span>, <span class="number">1</span>)<span class="comment"># fail</span></span><br><span class="line">next_2 = next_head(<span class="number">0x00007FF6A1AA257a</span>, <span class="number">0x00007FF6A1AA2580</span>)</span><br><span class="line">&gt;&gt; <span class="number">0xffffffffffffffff</span> <span class="number">0x7ff6a1aa257b</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出目标地址的反汇编语句（就是有一点点乱码x）</span></span><br><span class="line">a = generate_disasm_line(<span class="number">0x00007FF6A1AA2585</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">&gt;&gt; <span class="string">b&#x27;\x01\x05movzx\x02\x05   \x01)\x01!eax\x02!\x02)\x01\t,\x02\t \x01*\x01 byte ptr\x02  \x01\t[\x02\t\x01!r10\x02!\x01\t]\x02\t\x02*&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取目标地址指令</span></span><br><span class="line">a = print_insn_mnem(<span class="number">0x00007FF6A1AA2585</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">&gt;&gt; movzx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取目标地址的某个操作数（按索引取）</span></span><br><span class="line">a = print_operand(<span class="number">0x00007FF6A1AA2585</span>, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">&gt;&gt; <span class="string">b&#x27;\x01)\x01!eax\x02!\x02)&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取目标地址某个操作数的值（按索引取）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(get_operand_value(<span class="number">0x00007FF6A1AA2577</span>, <span class="number">1</span>)))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(get_operand_value(<span class="number">0x00007FF6A1AA2577</span>, <span class="number">1</span>)))</span><br><span class="line">&gt;&gt; <span class="number">0x10</span></span><br><span class="line">&gt;&gt; &lt;<span class="keyword">class</span> <span class="string">&#x27;int&#x27;</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取目标地址字符串，参数二是长度，参数三是string的类型</span></span><br><span class="line">a = get_strlit_contents(<span class="number">0x00007FF6A1AC28A8</span>, <span class="number">4</span>, <span class="number">0</span>)</span><br><span class="line">b = get_strlit_contents(<span class="number">0x00007FF6A1AC28A8</span>, <span class="number">4</span>, <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line">&gt;&gt; <span class="string">b&#x27;Erro&#x27;</span></span><br><span class="line">&gt;&gt; <span class="string">b&#x27;\xe7\x89\x85\xe6\xbd\xb2&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在目标地址添加注释，参数三为True则不会替换comment</span></span><br><span class="line">a = set_cmt(<span class="number">0x00007FF6A1AA2577</span>, <span class="string">&quot;this is a comment&quot;</span>, <span class="literal">True</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">&gt;&gt; <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 给目标地址的变量改名</span></span><br><span class="line">a = set_name(<span class="number">0x00007FF6A1AC28A8</span>, <span class="string">&quot;err&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">&gt;&gt; <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取当前光标处地址</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(get_screen_ea()))</span><br><span class="line">&gt;&gt; <span class="number">0x7ff6a1ac28a8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计目标地址所在函数有多少个基本块</span></span><br><span class="line"><span class="built_in">print</span>(FlowChart(get_func(<span class="number">0x00007FF6A1AA21B0</span>)).size)</span><br><span class="line">&gt;&gt; <span class="number">149</span></span><br></pre></td></tr></table></figure><p><strong>功能+调试相关：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置断点</span></span><br><span class="line">add_bpt(<span class="number">0x00007FF6A1AA2577</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除断点</span></span><br><span class="line">del_bpt(<span class="number">0x00007FF6A1AA2577</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置断点是否开启</span></span><br><span class="line">enable_bpt(<span class="number">0x00007FF6A1AA2577</span>, <span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置idapython为默认语言，在设置条件断点时不设置会默认使用idc</span></span><br><span class="line">load_and_run_plugin(<span class="string">&quot;idapython&quot;</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">condition</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&gt;&gt;&gt; rip:&quot;</span>, get_reg_val(<span class="string">&quot;rip&quot;</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">add_bpt(<span class="number">0x00007FF6011D2581</span>)</span><br><span class="line"><span class="comment"># 设置条件断点，每次运行到这个断点停下会触发condition</span></span><br><span class="line">set_bpt_cond(<span class="number">0x00007FF6011D2581</span>, <span class="string">&quot;condition()&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看交叉引用，返回一个迭代器，包含idautils._xref对象</span></span><br><span class="line">a = XrefsTo(<span class="number">0x00007FF6011D2577</span>, flags=<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> addr <span class="keyword">in</span> a:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(addr.frm))<span class="comment"># .frm 返回交叉引用地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读/写 1/2/4/8字节， wide是宽字节</span></span><br><span class="line">get_byte(addr)</span><br><span class="line">get_word(addr)</span><br><span class="line">get_dword(addr)</span><br><span class="line">get_qword(addr)</span><br><span class="line">get_wide_byte(addr)</span><br><span class="line">get_wide_word(addr)</span><br><span class="line">get_wide_dword(addr)</span><br><span class="line">get_wide_qword(addr)</span><br><span class="line">patch_byte(addr, val)</span><br><span class="line">patch_word(addr, val)</span><br><span class="line">patch_dword(addr, val)</span><br><span class="line">patch_qword(addr, val)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取寄存器rip的值</span></span><br><span class="line">get_reg_val(<span class="string">&quot;rip&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置寄存器rax的值为0x10</span></span><br><span class="line">set_reg_val(<span class="string">&quot;rax&quot;</span>, <span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始调试</span></span><br><span class="line">start_process()</span><br><span class="line"><span class="comment"># continue</span></span><br><span class="line">continue_process()</span><br><span class="line"><span class="comment"># 运行到目标地址</span></span><br><span class="line">run_to(addr)</span><br><span class="line"><span class="comment"># 获取并清除调试器事件代码，普通代码返回0x20，断点、ret返回0x10，程序结束返回负数</span></span><br><span class="line"><span class="comment"># 必须在进程执行的代码后面调用该函数，以便检索调试器的事件代码，否则可能会阻止后续尝试</span></span><br><span class="line">wait_for_next_event(EVENT_TYPE, flags)</span><br><span class="line"><span class="comment"># 单步</span></span><br><span class="line">step_over()</span><br><span class="line">wait_for_next_event(WFNE_SUSP, -<span class="number">1</span>) <span class="comment"># 每次step_over都要调用一次，continue这些也是</span></span><br><span class="line"><span class="comment"># 事件 WFNE_SUSP 将等待导致被调试进程挂起的事件，比如异常或断点</span></span><br><span class="line"><span class="comment"># 事件 WFNE_CONT 可以恢复被挂起的进程，继续执行</span></span><br><span class="line"><span class="comment"># example:</span></span><br><span class="line">wait_for_next_event(WFNE_SUSP, -<span class="number">1</span>)</span><br><span class="line">wait_for_next_event(WFNE_ANY | WFNE_CONT, -<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h1 id="实战：使用IDApython编写爆破脚本"><a href="#实战：使用IDApython编写爆破脚本" class="headerlink" title="实战：使用IDApython编写爆破脚本"></a>实战：使用IDApython编写爆破脚本</h1><p><strong>PS：使用我给SICTF Round3出的Re题Closeme作为例子</strong></p><p>附件： <a href="../resources/re_asset/closeme_release.zip" target="_block">点击下载附件</a></p><p>这题说实话预期就是爆破（x</p><p>大概回顾一下题目，每次创建几个窗口后都会弹出一个messagebox，点击yes&#x2F;no会被储存为1&#x2F;0，然后长度为16时就check一次，所以先把CreateWindowsEx和MessageBoxW那里的call xxx给nop掉（你也不想开几千上万个窗口把cpu干烧了吧x），然后就需要手动添加各种值了。</p><p>因为每16次循环才能使长度达到16进而check，太影响效率了，所以直接在原来call messagebox那里patch成jmp到cmp rax, 10h这里。</p><p>rax是长度，直接jmp过来就没有调用获取长度的函数，我们需要手动设置0x10</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">breakpoint_addr = <span class="number">0x00007FF6A1AA2577</span></span><br><span class="line">add_bpt(breakpoint_addr)</span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line">rip = get_reg_val(<span class="string">&quot;RIP&quot;</span>)</span><br><span class="line"><span class="comment">#print(&quot;rip: &quot;, hex(rip))</span></span><br><span class="line"><span class="keyword">if</span> rip == breakpoint_addr:</span><br><span class="line">    set_reg_val(<span class="string">&quot;rax&quot;</span>, <span class="number">0x10</span>)</span><br></pre></td></tr></table></figure><p><img src="/idapython%E5%85%A5%E9%97%A8/image-20240224010303964.png" alt="image-20240224010303964"></p><p>但是再执行两步就会把一个局部变量取出来解一层引用给r10，后续就是16个比较，所以r10应该是一个指向我们储存16个1或0的地址。</p><p>那么我们要伪造2层，一是先把那个局部变量的值修改为一个可写地址（同时也要保证运行时不会有其他的写者），然后二是在这个可写地址写入我们爆破的数据。</p><p>我直接找了.data段最末尾的0x10的空间</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># .data section</span></span><br><span class="line">buf_addr = <span class="number">0x7FF6A1ACDFF0</span></span><br><span class="line">patch_qword(get_reg_val(<span class="string">&quot;rbp&quot;</span>) + <span class="number">0x38</span>, buf_addr) <span class="comment"># 写入局部变量</span></span><br></pre></td></tr></table></figure><p>然后写入要爆破的数据需要注意端序问题（</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">send = <span class="comment"># 你要爆破的数据， 比如 0101010101010101</span></span><br><span class="line">left = <span class="string">&#x27;0&#x27;</span> + <span class="string">&#x27;0&#x27;</span>.join(send[:<span class="number">8</span>][::-<span class="number">1</span>])</span><br><span class="line">left = <span class="built_in">int</span>(left, <span class="number">16</span>)</span><br><span class="line">right = <span class="string">&#x27;0&#x27;</span> + <span class="string">&#x27;0&#x27;</span>.join(send[<span class="number">8</span>:][::-<span class="number">1</span>])</span><br><span class="line">right = <span class="built_in">int</span>(right, <span class="number">16</span>)</span><br><span class="line">patch_qword(buf_addr, left)</span><br><span class="line">patch_qword(buf_addr + <span class="number">8</span>, right)</span><br></pre></td></tr></table></figure><p>然后就是爆破2^16次就行了！</p><p><strong>完整爆破脚本：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> idaapi <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ida_dbg <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ida_bytes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">this_input = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">start = <span class="number">0x00007FF6530D220F</span></span><br><span class="line"><span class="comment">#add_bpt(start)</span></span><br><span class="line">breakpoint_addr = <span class="number">0x00007FF6A1AA2577</span></span><br><span class="line">add_bpt(breakpoint_addr)</span><br><span class="line">win_addr = <span class="number">0x00007FF6A1AA2993</span></span><br><span class="line">add_bpt(win_addr)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Start!&quot;</span>)</span><br><span class="line">start_process()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Waiting for next event...&quot;</span>)</span><br><span class="line">wait_for_next_event(WFNE_SUSP, -<span class="number">1</span>)</span><br><span class="line"><span class="comment"># .data section</span></span><br><span class="line">buf_addr = <span class="number">0x7FF6A1ACDFF0</span></span><br><span class="line">patch_qword(get_reg_val(<span class="string">&quot;rbp&quot;</span>) + <span class="number">0x38</span>, buf_addr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">if</span> this_input &gt;= <span class="number">0x10000</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Burst Finished.&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    send = <span class="built_in">bin</span>(this_input)[<span class="number">2</span>:].zfill(<span class="number">16</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;send: &quot;</span>, send)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        rip = get_reg_val(<span class="string">&quot;RIP&quot;</span>)</span><br><span class="line">        <span class="comment">#print(&quot;rip: &quot;, hex(rip))</span></span><br><span class="line">        <span class="keyword">if</span> rip == breakpoint_addr:</span><br><span class="line">            set_reg_val(<span class="string">&quot;rax&quot;</span>, <span class="number">0x10</span>)</span><br><span class="line">            <span class="comment">#print(&quot;set rax to 0x10&quot;)</span></span><br><span class="line"></span><br><span class="line">            left = <span class="string">&#x27;0&#x27;</span> + <span class="string">&#x27;0&#x27;</span>.join(send[:<span class="number">8</span>][::-<span class="number">1</span>])</span><br><span class="line">            left = <span class="built_in">int</span>(left, <span class="number">16</span>)</span><br><span class="line">            right = <span class="string">&#x27;0&#x27;</span> + <span class="string">&#x27;0&#x27;</span>.join(send[<span class="number">8</span>:][::-<span class="number">1</span>])</span><br><span class="line">            right = <span class="built_in">int</span>(right, <span class="number">16</span>)</span><br><span class="line">            patch_qword(buf_addr, left)</span><br><span class="line">            patch_qword(buf_addr + <span class="number">8</span>, right)</span><br><span class="line">        <span class="keyword">elif</span> rip == win_addr:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;win&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;flag: SICTF&#123;&quot;</span> + <span class="built_in">bin</span>(this_input - <span class="number">1</span>)[<span class="number">2</span>:].zfill(<span class="number">16</span>) + <span class="string">&quot;&#125;&quot;</span>)</span><br><span class="line">            exit(<span class="number">0</span>)</span><br><span class="line">        continue_process()</span><br><span class="line">        wait_for_next_event(WFNE_SUSP, -<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;err: &quot;</span>, e)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    this_input += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;out&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://hacbit.tech/categories/CTF/">CTF</category>
      
      
      <category domain="http://hacbit.tech/tags/IDA/">IDA</category>
      
      <category domain="http://hacbit.tech/tags/Tutorial/">Tutorial</category>
      
      
      <comments>http://hacbit.tech/idapython%E5%85%A5%E9%97%A8/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
